<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BASE64加密Demo</title>
    <url>/2019/03/24/BASE64%E5%8A%A0%E5%AF%86Demo-BASE64%E5%8A%A0%E5%AF%86Demo/</url>
    <content><![CDATA[<p>笔记补录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BASE64Encoder en = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">        String s = en.encode(<span class="keyword">new</span> String(<span class="string">&quot;字符串&quot;</span>).getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS 7 MySQL自动备份shell脚本</title>
    <url>/2019/03/05/CentOS%207%20MySQL%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDshell%E8%84%9A%E6%9C%AC-CentOS%207%20MySQL%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDshell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p><img src="https://www.itmengtao.cn/upload/2020/8/%E5%9B%BE%E7%89%87-12d3f60175cd4b2781b0c11d6b34e160.png" alt="图片.png"><br>　　在数据库的日常维护工作中，除了保证业务的正常运行以外，就是要对数据库进行备份，以免造成数据库的丢失，从而给企业带来重大经济损失。<br>　　通常备份可以按照备份时数据库状态分为热备和冷备，按照备份数据库文件的大小分为增量备份、差异备份和全量备份。<br>　　这里，我们讲解一种全量备份的方法，来实现定时备份数据到mysql脚本文件，并且支持过期删除。</p>
<p>系统环境：<br>CentOS7 64位 Minimal版（VMware）<br>MySQL5.7</p>
<p>原理与工具：<br>shell脚本<br>mysqldump程序<br>crontab命令</p>
<p>1、新建shell脚本<br>vi /opt/mysqlBackup.sh<br>#!/bin/bash</p>
<h1 id="以下配置信息请自己修改"><a href="#以下配置信息请自己修改" class="headerlink" title="以下配置信息请自己修改"></a>以下配置信息请自己修改</h1><p>mysql_user=”USER” #MySQL备份用户<br>mysql_password=”PASSWORD” #MySQL备份用户的密码<br>mysql_host=”localhost”<br>mysql_port=”3306”<br>mysql_charset=”utf8” #MySQL编码<br>backup_db_arr=(“db1” “db2”) #要备份的数据库名称，多个用空格分开隔开 如(“db1” “db2” “db3”)<br>backup_location=/opt/mysql  #备份数据存放位置，末尾请不要带”/“,此项可以保持默认，程序会自动创建文件夹<br>expire_backup_delete=”ON” #是否开启过期备份删除 ON为开启 OFF为关闭<br>expire_days=3 #过期时间天数 默认为三天，此项只有在expire_backup_delete开启时有效</p>
<h1 id="本行开始以下不需要修改"><a href="#本行开始以下不需要修改" class="headerlink" title="本行开始以下不需要修改"></a>本行开始以下不需要修改</h1><p>backup_time=<code>date +%Y%m%d%H%M</code>  #定义备份详细时间<br>backup_Ymd=<code>date +%Y-%m-%d</code> #定义备份目录中的年月日时间<br>backup_3ago=<code>date -d &#39;3 days ago&#39; +%Y-%m-%d</code> #3天之前的日期<br>backup_dir=$backup_location/$backup_Ymd  #备份文件夹全路径<br>welcome_msg=”Welcome to use MySQL backup tools!” #欢迎语</p>
<h1 id="判断MYSQL是否启动-mysql没有启动则备份退出"><a href="#判断MYSQL是否启动-mysql没有启动则备份退出" class="headerlink" title="判断MYSQL是否启动,mysql没有启动则备份退出"></a>判断MYSQL是否启动,mysql没有启动则备份退出</h1><p>mysql_ps=<code>ps -ef |grep mysql |wc -l</code><br>mysql_listen=<code>netstat -an |grep LISTEN |grep $mysql_port|wc -l</code><br>if [ [$mysql_ps == 0] -o [$mysql_listen == 0] ]; then<br>        echo “ERROR:MySQL is not running! backup stop!”<br>        exit<br>else<br>        echo $welcome_msg<br>fi</p>
<h1 id="连接到mysql数据库，无法连接则备份退出"><a href="#连接到mysql数据库，无法连接则备份退出" class="headerlink" title="连接到mysql数据库，无法连接则备份退出"></a>连接到mysql数据库，无法连接则备份退出</h1><p>mysql -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password &lt;&lt;end<br>use mysql;<br>select host,user from user where user=’root’ and host=’localhost’;<br>exit<br>end</p>
<p>flag=<code>echo $?</code><br>if [ $flag != “0” ]; then<br>        echo “ERROR:Can’t connect mysql server! backup stop!”<br>        exit<br>else<br>        echo “MySQL connect ok! Please wait……”<br>        # 判断有没有定义备份的数据库，如果定义则开始备份，否则退出备份<br>        if [ “$backup_db_arr” != “” ];then<br>                #dbnames=$(cut -d ‘,’ -f1-5 $backup_database)<br>                #echo “arr is (${backup_db_arr[@]})”<br>                for dbname in ${backup_db_arr[@]}<br>                do<br>                        echo “database $dbname backup start…”<br>                        <code>mkdir -p $backup_dir</code><br>                        <code>mysqldump -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password $dbname --default-character-set=$mysql_charset | gzip &gt; $backup_dir/$dbname-$backup_time.sql.gz</code><br>                        flag=<code>echo $?</code><br>                        if [ $flag == “0” ];then<br>                                echo “database $dbname success backup to $backup_dir/$dbname-$backup_time.sql.gz”<br>                        else<br>                                echo “database $dbname backup fail!”<br>                        fi</p>
<pre><code>            done
    else
            echo &quot;ERROR:No database to backup! backup stop&quot;
            exit
    fi
    # 如果开启了删除过期备份，则进行删除操作
    if [ &quot;$expire_backup_delete&quot; == &quot;ON&quot; -a  &quot;$backup_location&quot; != &quot;&quot; ];then
             #`find $backup_location/ -type d -o -type f -ctime +$expire_days -exec rm -rf &#123;&#125; \;`
             `find $backup_location/ -type d -mtime +$expire_days | xargs rm -rf`
             echo &quot;Expired backup data delete complete!&quot;
    fi
    echo &quot;All database backup success! Thank you!&quot;
    exit
</code></pre>
<p>fi<br>注意：如果这个sh文件是在win下编辑的，需要用编辑器转换为unix格式，否则sh会执行不成功，如图：</p>
<p>2、修改shell脚本属性，赋予执行权限<br>chmod 600 /opt/mysqlBackup.sh<br>chmod +x /opt/mysqlBackup.sh<br>3、定时执行脚本<br>方式一：<br>执行crontab -e命令，创建当前用户级别的定时任务</p>
<p>crontab -e<br>输入以下内容，设置每天凌晨3:00定时自动备份</p>
<p>00 03 * * * /opt/mysqlBackup.sh<br>生成的配置文件位于/var/spool/cron/root</p>
<p>日志记录在/var/spool/mail/root中，可查看日志记录</p>
<p>vi /var/spool/mail/root</p>
<p>crontab文件概要：<br>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br>minute　hour　day　month　week　command<br>　分　　时　　日　　月　　　周　　　命令<br>其中：<br>minute： 表示分钟，可以是从0到59之间的任何整数。（每分钟可用<em>或者</em>/1表示）<br>hour：表示小时，可以是从0到23之间的任何整数。（0表示0点）<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。<br>在以上各个字段中，还可以使用以下特殊字符：<br>星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。</p>
<p>方式二：<br>配置全局定时任务文件</p>
<p>vi /etc/crontab<br>在etc中加入如下内容，让其每天凌晨3:00自动执行任务。</p>
<p>00 03 * * * root /opt/mysqlBackup.sh<br>全局定时任务配置相比于用户级别的任务配置多了一项执行用户user-name</p>
<p>日志记录在/var/log/cron中</p>
<p>4、MySQL恢复<br>mysql -u username -p databse &lt; backup.sql</p>
<p>摘自:  <a href="https://www.jianshu.com/p/746db5ceec02">https://www.jianshu.com/p/746db5ceec02</a></p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7 安装 Docker Compose 以及安装的问题解决</title>
    <url>/2020/02/14/CentOS%207%20%E5%AE%89%E8%A3%85%20Docker%20Compose%20%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-CentOS%207%20%E5%AE%89%E8%A3%85%20Docker%20Compose%20%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p><a href="https://links.jianshu.com/go?to=https://github.com/docker/compose">Docker Compose</a> 是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。使用 compose，我们可以通过 YAML 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。</p>
<h3 id="一、centos7-安装最新版的docker"><a href="#一、centos7-安装最新版的docker" class="headerlink" title="一、centos7 安装最新版的docker"></a>一、centos7 安装最新版的docker</h3><ol>
<li>查看系统要求</li>
</ol>
<p>Docker 要求 CentOS 系统的内核版本高于 3.10 ,查看CentOS的内核版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$  uname -a 或者 uname -r</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用该命令 rpm -qa|grep docker //查看已经安装的docker安装包,列出入校内容 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rpm -qa|grep docker</span><br><span class="line">docker.x86_64 2:1.12.6-16.el7.centos @extras </span><br><span class="line">docker-client.x86_64 2:1.12.6-16.el7.centos @extras </span><br><span class="line">docker-common.x86_64 2:1.12.6-16.el7.centos @extra</span><br></pre></td></tr></table></figure></li>
<li>1分别删除 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum -y remove docker.x86_64</span><br><span class="line">$ yum -y remove docker-client.x86_64</span><br><span class="line">$ yum -y remove docker-common.x86_64</span><br></pre></td></tr></table></figure></li>
<li>2删除原始docker镜像<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm -rf /var/lib/docker </span><br></pre></td></tr></table></figure></li>
<li>安装需要的软件包 </li>
</ol>
<p>yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<p>4.设置Docker yum源 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>5.查看所有仓库中所有docker版本</p>
<p>可以查看所有仓库中所有docker版本,并选择特定的版本安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-c382340399ed4858abb95236a7fd524b.png" alt="image.png"><br> <br>6.安装docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum install docker-ce</span><br></pre></td></tr></table></figure>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-9830a8d82264452394dd4a6dd2d91c23.png" alt="image.png"></p>
<p>由于repo中默认只开启stable仓库，故这里安装的是最新稳19.03.5-3.el7。 如果要安装特定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum install docker18.03.1.ce-1.el7.centos </span><br></pre></td></tr></table></figure>
<p>7.启动 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置为开机启动</span><br><span class="line">systemctl enable docker</span><br><span class="line">启动</span><br><span class="line">systemctl start docker</span><br><span class="line">查看启动状态</span><br><span class="line">systemctl status docker</span><br><span class="line">查看版本</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p> <img src="https://www.itmengtao.cn/upload/2020/12/image-975a06e5d74b4b529904379854383531.png" alt="image.png"></p>
<h3 id="二、安装docker-compose"><a href="#二、安装docker-compose" class="headerlink" title="二、安装docker-compose"></a>二、安装docker-compose</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
<p> 安装完成后发现如下问题：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-e3b1dcf4d81e4cf1b39e2d0c8db0408e.png" alt="image.png"></p>
<p>原因：</p>
<p>使用官方文档中所描述的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.14.0-rc2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>安装时，curl下载下来的文件是<strong>不完整</strong>的，而且没有给出任何错误信息。</p>
<p>可以看到通过curl下载的文件比使用浏览器下载后又上传到服务器上的文件大小要小，所以重新下载文件即可。</p>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>进入下面的网址下载目前的最新版：</p>
<p><a href="https://github.com/docker/compose/releases/tag/1.14.0-rc2">https://github.com/docker/compose/releases/tag/1.14.0-rc2</a></p>
<p>网页拉到最下面，下载：</p>
<p>docker-compose-Linux-x86_64</p>
<p>然后将文件上传到 /usr/local/bin/ 文件夹下，然后将其重命名为docker-compose，修改此文件的权限，</p>
<p>增加可执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>然后再运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>
<p>如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-5c6e5128aa424da9ae298d5e82b17321.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>CentOS | Docker</category>
      </categories>
      <tags>
        <tag>CentOS  | Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7.x 安装Docker</title>
    <url>/2019/07/31/CentOS%207.x%20%E5%AE%89%E8%A3%85Docker-CentOS%207.x%20%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h5 id="1、Docker-要求-CentOS-系统的内核版本高于-3-10-，查看本页面的前提条件来验证你的CentOS-版本是否支持-Docker-。"><a href="#1、Docker-要求-CentOS-系统的内核版本高于-3-10-，查看本页面的前提条件来验证你的CentOS-版本是否支持-Docker-。" class="headerlink" title="1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。"></a>1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</h5><p>通过 uname -r 命令查看你当前的内核版本</p>
<blockquote>
<p> <strong>$ uname -r</strong></p>
</blockquote>
<h5 id="2、使用-root-权限登录-Centos。确保-yum-包更新到最新。"><a href="#2、使用-root-权限登录-Centos。确保-yum-包更新到最新。" class="headerlink" title="2、使用 root 权限登录 Centos。确保 yum 包更新到最新。"></a>2、使用 root 权限登录 Centos。确保 yum 包更新到最新。</h5><blockquote>
<p> <strong>$ sudo yum update</strong></p>
</blockquote>
<h5 id="3、卸载旧版本-如果安装过旧版本的话"><a href="#3、卸载旧版本-如果安装过旧版本的话" class="headerlink" title="3、卸载旧版本(如果安装过旧版本的话)"></a>3、卸载旧版本(如果安装过旧版本的话)</h5><blockquote>
<p> <strong>$ sudo yum remove docker  docker-common docker-selinux docker-engine</strong></p>
</blockquote>
<h5 id="4、安装需要的软件包，-yum-util-提供yum-config-manager功能，另外两个是devicemapper驱动依赖的"><a href="#4、安装需要的软件包，-yum-util-提供yum-config-manager功能，另外两个是devicemapper驱动依赖的" class="headerlink" title="4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的"></a>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</h5><blockquote>
<p> <strong>$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</strong></p>
</blockquote>
<h5 id="5、设置yum源"><a href="#5、设置yum源" class="headerlink" title="5、设置yum源"></a>5、设置yum源</h5><blockquote>
<p> <strong>$ sudo yum-config-manager –add-repo</strong> </p>
</blockquote>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-9855db2571cd47b7a589fd516e4acb93.png" alt="设置yum源"></p>
<h5 id="6、可以查看所有仓库中所有docker版本，并选择特定版本安装"><a href="#6、可以查看所有仓库中所有docker版本，并选择特定版本安装" class="headerlink" title="6、可以查看所有仓库中所有docker版本，并选择特定版本安装"></a>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</h5><blockquote>
<p> <strong>$ yum list docker-ce –showduplicates | sort -r</strong><br><img src="https://www.itmengtao.cn/upload/2020/11/image-b27e0eeaad6946169be05bc7b4b2e63d.png" alt="image.png"></p>
</blockquote>
<h5 id="7、安装docker"><a href="#7、安装docker" class="headerlink" title="7、安装docker"></a>7、安装docker</h5><blockquote>
<p> <strong>$ sudo yum install docker-ce</strong>  #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0<br> <strong>$ sudo yum install <FQPN></strong>  # 例如：sudo yum install docker-ce-17.12.0.ce<br> <img src="https://www.itmengtao.cn/upload/2020/11/image-6be3e29adfeb412483295dff064fad4e.png" alt="image.png"></p>
</blockquote>
<h5 id="8、启动并加入开机启动"><a href="#8、启动并加入开机启动" class="headerlink" title="8、启动并加入开机启动"></a>8、启动并加入开机启动</h5><blockquote>
<p> <strong>$ sudo systemctl start docker<br>$ sudo systemctl enable docker</strong></p>
</blockquote>
<h5 id="9、验证安装是否成功-有client和service两部分表示docker安装启动都成功了"><a href="#9、验证安装是否成功-有client和service两部分表示docker安装启动都成功了" class="headerlink" title="9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)"></a>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</h5><blockquote>
<p> <strong>$ docker version</strong><br><img src="https://www.itmengtao.cn/upload/2020/11/image-b275457edc7840e0839dc4cab39c2c79.png" alt="image.png"></p>
</blockquote>
]]></content>
      <categories>
        <category>CentOS | Docker</category>
      </categories>
      <tags>
        <tag>CentOS  | Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7.x 安装Redis（极简）</title>
    <url>/2019/06/23/CentOS%207.x%20%E5%AE%89%E8%A3%85Redis%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89-CentOS%207.x%20%E5%AE%89%E8%A3%85Redis%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89/</url>
    <content><![CDATA[<p><strong>环境配置：<br>CentOS 7 / redis4.0.6</strong></p>
<p>1.首先下载Redis，下载地址<a href="https://redis.io/%EF%BC%8C%E4%B8%8B%E8%BD%BD%E8%8E%B7%E5%BE%97redis-4.0.6.tar.gz%E5%90%8E%E5%B0%86%E5%AE%83%E6%94%BE%E5%85%A5%E6%88%91%E4%BB%AC%E7%9A%84Linux%E7%9B%AE%E5%BD%95/opt">https://redis.io/，下载获得redis-4.0.6.tar.gz后将它放入我们的Linux目录/opt</a> 下。</p>
<p>2./opt目录下，对文件进行解压，解压命令:tar -zxvf redis-4.0.6.tar.gz</p>
<p>3.解压完成后出现文件夹：redis-4.0.6，进入到该目录中: cd redis-4.0.6</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-5df1d82224a5423b8c5114eb063dc1d6.png" alt="image.png"></p>
<p>4.在redis-4.0.6目录下执行make命令进行编译</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-23f5a3d0066946eebba5a153ce1c4307.png" alt="image.png"></p>
<p>5.make完成后继续执行 make install 命令进行安装。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-6932a0dfa05849edb7d4dcd596afc618.png" alt="image.png"></p>
<p>至此，<strong>redis就算安装成功了。</strong></p>
<p>6.在我们启动之前，需要先做一个简单的配置：修改redis.conf 文件，将里面的daemonize no 改成 yes，让服务在后台启动，如下：<br><img src="https://www.itmengtao.cn/upload/2020/10/image-3693c3aa562b4fbf82db010e1fb9ad9e.png" alt="image.png"></p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-bc04b9974ab549d8ac7c2c0858c1c19d.png" alt="image.png"></p>
<p>7.启动，通过redis-server redis.conf命令启动redis，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-e68b290274c140b2a3e2e283f0477596.png" alt="image.png"></p>
<p>8.测试</p>
<p>通过 redis-cli命令进入到控制台，首先设置你的登录密码，否则会报(error) NOAUTH Authentication required错误，此处密码是123456，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-f47c7ad7cc5242168e195b4ac99c1bfa.png" alt="image.png"></p>
<p>设置成功后，输入 redis-cli -a 123456 登录，然后通过 ping命令进行连通性测试，如果看到 pong，表示连接成功了，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-4d51b2a0880045818f8c5615c2cbd85d.png" alt="image.png"></p>
<p>9.清空/关闭，通过 flushall命令可清空缓存，通过shutdown命令我们可以关闭实例。。。</p>
<p>以上完。</p>
]]></content>
      <categories>
        <category>Redis | CentOS</category>
      </categories>
      <tags>
        <tag>Redis | CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7安装SVN服务器</title>
    <url>/2019/03/01/CentOS%207%E5%AE%89%E8%A3%85SVN%E6%9C%8D%E5%8A%A1%E5%99%A8-CentOS%207%E5%AE%89%E8%A3%85SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/kity9420/article/details/80157476">https://blog.csdn.net/kity9420/article/details/80157476</a><br><a href="https://jingyan.baidu.com/article/148a1921d84be34d71c3b18f.html">https://jingyan.baidu.com/article/148a1921d84be34d71c3b18f.html</a><br><a href="https://www.linuxidc.com/Linux/2017-05/144254.htm">https://www.linuxidc.com/Linux/2017-05/144254.htm</a></p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7快速安装配置MySQL5.7，添加新用户、为用户创建数据库、为新用户分配权限</title>
    <url>/2019/03/29/CentOS%207%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySQL5.7%EF%BC%8C%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7%E3%80%81%E4%B8%BA%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E4%B8%BA%E6%96%B0%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E6%9D%83%E9%99%90-CentOS%207%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySQL5.7%EF%BC%8C%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7%E3%80%81%E4%B8%BA%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E4%B8%BA%E6%96%B0%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="1-安装MySQL"><a href="#1-安装MySQL" class="headerlink" title="1.安装MySQL"></a>1.安装MySQL</h2><p>运行以下命令更新yum源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -Uvh  http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>2.运行以下命令安装MySQL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure>
<p>3.运行以下命令查看MySQL版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -V</span><br></pre></td></tr></table></figure>
<p>4.返回结果如下，表示MySQL安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql  Ver 14.14 Distrib 5.7.25, for Linux (x86_64) using  EditLine wrapper</span><br></pre></td></tr></table></figure>
<h2 id="2-配置MySQL"><a href="#2-配置MySQL" class="headerlink" title="2.配置MySQL"></a>2.配置MySQL</h2><p>1.运行以下命令启动MySQL服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>
<p>2.运行以下命令设置MySQL服务开机自启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld</span><br></pre></td></tr></table></figure>
<p>3.运行以下命令查看/var/log/mysqld.log文件，获取并记录root用户的初始密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br><span class="line">2019-08-08T09:07:47.535748Z 1 [Note] A temporary password is generated for root@localhost: p0/G28g&gt;lsHD</span><br></pre></td></tr></table></figure>
<p>说明：下一步重置root用户密码时，会使用该初始密码。</p>
<p>4.运行下列命令配置MySQL的安全性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>安全性的配置包含以下五个方面：<br>1.重置root账号密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter password for user root: #输入上一步获取的root用户初始密码</span><br><span class="line">The &#x27;validate_password&#x27; plugin is installed on the server.</span><br><span class="line">The subsequent steps will run with the existing configuration of the plugin.</span><br><span class="line">Using existing password for root.</span><br><span class="line">Estimated strength of the password: 100 </span><br><span class="line">Change the password for root ? ((Press y|Y for Yes, any other key for No) : Y #是否更改root用户密码，输入Y</span><br><span class="line">New password: #输入新密码，长度为8至30个字符，必须同时包含大小写英文字母、数字和特殊符号。特殊符号可以是()` ~!@#$%^&amp;*-+=|&#123;&#125;[]:;‘&lt;&gt;,.?/</span><br><span class="line">Re-enter new password: #再次输入新密码</span><br><span class="line">Estimated strength of the password: 100 </span><br><span class="line">Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : Y</span><br></pre></td></tr></table></figure>
<p>2.输入Y删除匿名用户账号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment.</span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : Y  </span><br><span class="line">#是否删除匿名用户，输入Y</span><br><span class="line">Success.</span><br></pre></td></tr></table></figure>
<p>3.输入Y禁止root账号远程登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : Y #禁止root远程登录，输入Y</span><br><span class="line">Success.</span><br></pre></td></tr></table></figure>
<p>4.输入Y删除test库以及对test库的访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : Y #是否删除test库和对它的访问权限，输入Y</span><br><span class="line">- Dropping test database...</span><br><span class="line">Success.</span><br><span class="line">```linux</span><br><span class="line">5.输入Y重新加载授权表。</span><br><span class="line">```linux</span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : Y #是否重新加载授权表，输入Y</span><br><span class="line">Success.</span><br><span class="line">All done!</span><br></pre></td></tr></table></figure>
<p>更多详情，请参见<a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">官方文档</a>。</p>
<ol start="5">
<li><p>使用root用户连接mysql。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li>
<li><p>查看用户信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select host,user,plugin,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure>
<p><img src="/1" alt="image.png"></p>
</li>
<li><p>1 修改root用户密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;newpassword&#x27;; #更新一下用户的密码 root用户密码为newpassword</span><br></pre></td></tr></table></figure></li>
<li><p>2 添加新用户，参考地址点这里。</p>
</li>
</ol>
<p>允许本地 IP 访问 localhost, 127.0.0.1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<p>允许外网 IP 访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<p>刷新授权 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p> 6.3  为用户创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database test DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>
<p> 6.4  为新用户分配权限</p>
<p>授予用户通过外网IP对于该数据库的全部权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all privileges on `testdb`.* to &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<p>授予用户在本地服务器对该数据库的全部权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all privileges on `testdb`.* to &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<p>刷新权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>退出 root 重新登录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<p> 用新帐号 test 重新登录，由于使用的是 % 任意IP连接，所以需要指定外部访问IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u test -h 192.168.1.11 -p</span><br></pre></td></tr></table></figure>
<p>另：在Ubuntu服务器下，MySQL默认是只允许本地登录，因此需要修改配置文件将地址绑定给注释掉： </p>
<p>不然会报如下错误：</p>
<p>ERROR 2003 (HY000): Can’t connect to MySQL server on ‘host’ (111)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Instead of skip-networking the default is now to listen only on</span><br><span class="line"># localhost which is more compatible and is not less secure.</span><br><span class="line"># bind-address = 127.0.0.1		#注释掉这一行就可以远程登录了</span><br></pre></td></tr></table></figure>
<p>7.使用navicat连接远程mysql。</p>
<p>输入下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; grant ALL PRIVILEGES ON *.* to root@&quot;%&quot; identified by &quot;xxxx&quot; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>
<p>（其中 第一个<em>表示数据库名；第二个</em>表示该数据库的表名；如果像上面那样 *.*的话表示所有到数据库下到所有表都允许访问，当然你也可以根据自己的情况修改；%：表示允许访问到mysql的ip地址，当然你也可以配置为具体到ip名称，%表示所有ip均可以访问；后面到‘xxxx为root 用户的password；）   //CentOS 7下亲测 </p>
<p>配置成功后连接测试如下图：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/8/image-1c84d3c5aecb452b9841bc2001b5e906.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>CentOS | MySQL</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 8 官方正式发布了！</title>
    <url>/2019/09/26/CentOS%208%20%E5%AE%98%E6%96%B9%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E4%BA%86%EF%BC%81-CentOS%208%20%E5%AE%98%E6%96%B9%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E4%BA%86%EF%BC%81/</url>
    <content><![CDATA[<p>CentOS 8 官方正式发布了！CentOS 完全遵守 Red Hat 的再发行政策，并且致力与上游产品在功能上完全兼容。CentOS 对组件的修改主要是去除 Red Hat 的商标及美工图。该版本还包含全新的 RHEL upstream, CentOS Streams。</p>
<p>官方中文的发行说明：<a href="https://wiki.centos.org/Manuals/ReleaseNotes/CentOS8.1905">https://wiki.centos.org/Manuals/ReleaseNotes/CentOS8.1905</a></p>
<p>CentOS 8 主要改动和 <a href="https://www.centoschina.cn/go?url=https://www.oschina.net/news/106529/redhat-enterprise-linux-8-final">RedHat Enterprise Linux 8</a> 是一致的，基于 Fedora 28 和内核版本 4.18, 为用户提供一个稳定的、安全的、一致的基础，跨越混合云部署，支持传统和新兴的工作负载所需的工具。此次发布的亮点包括：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-461da55cae164cf38be7dd06b9f8962f.png" alt="image.png"></p>
<p>发行版</p>
<p>通过 BaseOS 和应用流 (AppStream) 仓库发布.<br>AppStream 是对传统 rpm 格式的全新扩展，为一个组件同时提供多个主要版本<br>更详细介绍请看 Chapter 3, Distribution of content in RHEL 8</p>
<p>软件管理</p>
<p>YUM 包管理器基于 DNF 技术，提供模块化内容支持，增强了性能，并且提供了设计良好的 API 用于与其他工具集成<br>详细介绍请看 Section 5.1.4, “Software management”</p>
<p>Shell 和命令行工具</p>
<p>RHEL 8 提供了版本控制工具: Git 2.18, Mercurial 4.8, 和 Subversion 1.10.<br>详情请看 Section 5.1.6, “Shells and command-line tools”</p>
<p>动态编程语言、Web 和数据库服务器</p>
<p>Python 3.6 是默认的 Python 环境，有限支持 Python 2.7<br>Node.js 是在 RHEL 最新包含的，其他动态语言更新包括: PHP 7.2, Ruby 2.5, Perl 5.26, SWIG 3.0<br>RHEL 8 提供的数据库服务包括：MariaDB 10.3, MySQL 8.0, PostgreSQL 10, PostgreSQL 9.6, 和 Redis 5.<br>RHEL 8 提供Apache HTTP Server 2.4 以及首次引入的, nginx 1.14.<br>Squid 版本升级到 4.4 ，同时也首次提供Varnish Cache 6.0.<br>详细介绍请看 Section 5.1.7, “Dynamic programming languages, web and database servers”</p>
<p>桌面环境</p>
<p>GNOME Shell 升级到 3.28.<br>GNOME 会话和显示管理使用 Wayland 作为默认的显示服务器，而 RHEL 7 默认的 X.Org server 依然提供<br>详细信息请看 Section 5.1.8, “Desktop”</p>
<p>安装程序以及镜像的创建</p>
<p>Anaconda 安装程序可使用 LUKS2 磁盘加密，支持 NVDIMM 设备.<br>Image Builder 工具可以创建不同格式的自定义系统镜像，包括满足云平台的各种格式<br>支持使用硬件管理控制台 HMC 从 DVD 安装，同时也提供 IBM Z 主机的 Support Element (SE)<br>详细介绍请看 Section 5.1.2, “Installer and image creation” .</p>
<p>内核</p>
<p>扩展 Berkeley Packet Filtering (eBPF) 特性使得用户空间的各个点上附加自定义程序，包括 (sockets, trace points, packet reception) ，用于接收和处理数据。目前该特性还处于特性预览阶段<br>BPF Compiler Collection (BCC), 这是一个用来创建高效内核跟踪和操作的工具，目前处于技术预览阶段<br>详情请看 Section 5.3.1, “Kernel”</p>
<p>文件系统和存储</p>
<p>LUKS version 2 (LUKS2) 格式替代旧的 LUKS (LUKS1) 格式. dm-crypt 子系统和 cryptsetup 工具现在使用 LUKS2 作为默认的加密卷格式<br>详细介绍请看 Section 5.1.12, “File systems and storage” .</p>
<p>安全</p>
<p>默认的系统级的 加密策略, 用于配置核心加密子系统，覆盖 TLS, IPsec, SSH, DNSSEC, 和 Kerberos 协议。增加全新命令update-crypto-policies, 管理员可以轻松切换不同模式： default, legacy, future, 和 fips.<br>支持智能卡和硬件安全模块 (HSM) 的 PKCS #11<br>详细介绍请看 Section 5.1.15, “Security”</p>
<p>网络</p>
<p>nftables 框架替代 iptables 作为默认的网络包过滤工具<br>firewalld 守护进程使用 nftables 作为默认后端<br>支持 IPVLAN 虚拟网络驱动程序，用于连接多个容器<br>eXpress Data Path (XDP), XDP for Traffic Control (tc), 以及 Address Family eXpress Data Path (AF_XDP), 可作为部分 Berkeley Packet Filtering (eBPF) 扩展特性，目前还是技术预览阶段，详情请看 Section 5.3.7, “Networking”.<br>详细的网络方面的特性请看 Section 5.1.14, “Networking” .</p>
<p>虚拟化</p>
<p>在RHEL8中创建的虚拟机中，现在支持并自动配置更现代的基于PCI Express的计算机类型（Q35）。这在虚拟设备的功能和兼容性方面提供了多种改进。<br>现在可以使用RHEL8Web控制台（也称为“驾驶舱”）创建和管理虚拟机。<br>qemu仿真器引入了沙箱功能，它为系统调用qemu可以执行的操作提供了可配置的限制，从而使虚拟机更加安全。<br>详细介绍请看 Section 5.1.16, “Virtualization”</p>
<p>编译器和开发工具</p>
<p>GCC 编译器更新到 8.2 版本，支持更多 C++标准，更好的优化以及代码增强技术、提升警告和硬件特性支持<br>不同的代码生成、操作和调试工具现在可以处理 DWARF5 调试信息格式（体验阶段）<br>核心支持 eBPF 调试的工具包括BCC, PCP, 和 SystemTap.<br>glibc 库升级到 2.28 支持 Unicode 11, 更新的 Linux 系统调用，关键提升主要在 DNS stub resolver 、额外的安全加强和性能提升<br>RHEL 8 提供 OpenJDK 11, OpenJDK 8, IcedTea-Web, 以及不同 Java 工具，如 Ant, Maven, 或 Scala.<br>详细介绍请看 Section 5.1.11, “Compilers and development tools”.</p>
<p>高可用和集群</p>
<p>Pacemaker 集群资源管理器更新到最新版本 2.0.0, 修复了一系列 bug 以及功能做了提升<br>pcs 配置系统完全支持 Corosync 3, knet, 和节点名称<br>详情请看 Section 5.1.13, “High availability and clusters” .</p>
<p>CentOS 8 官方发行说明：<a href="https://lists.centos.org/pipermail/centos-announce/2019-September/023449.html">https://lists.centos.org/pipermail/centos-announce/2019-September/023449.html</a></p>
<p>完整的 RedHat 8 发行说明请看 <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.0_release_notes/overview">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.0_release_notes/overview</a></p>
<p>CentOS 8 下载：<a href="https://centos.org/download">https://centos.org/download/</a></p>
<p>国内镜像下载：<a href="http://mirrors.neusoft.edu.cn/centos">http://mirrors.neusoft.edu.cn/centos/</a></p>
<p>参考：<a href="https://www.centoschina.cn/news/linuxnews/23068.html">https://www.centoschina.cn/news/linuxnews/23068.html</a></p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Consul 的使用、集群注册与消费简单案例</title>
    <url>/2020/07/02/Consul%20%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E9%9B%86%E7%BE%A4%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B6%88%E8%B4%B9%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B-consul%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B6%88%E8%B4%B9%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="1-Consul-使用"><a href="#1-Consul-使用" class="headerlink" title="1.Consul 使用"></a>1.Consul 使用</h2><p>首先创建一个服务提供者 consul-provider。新建一个 Spring Boot 项目，添加如下依赖：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-c3f03eaf59b249dd81246e0a20b7ace9.png" alt="image.png"></p>
<p>项目创建成功后，application.properties 添加如下配置： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.application.name=consul-provider</span><br><span class="line">server.port=2000</span><br><span class="line"># Consul 相关配置</span><br><span class="line">spring.cloud.consul.host=192.168.1.111 #写自己的ip</span><br><span class="line">spring.cloud.consul.port=8500</span><br><span class="line">spring.cloud.consul.discovery.service-name=consul-provider</span><br><span class="line">spring.cloud.consul.discovery.heartbeat.enabled=true</span><br></pre></td></tr></table></figure>

<p>项目启动类上面开启服务发现功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//开启服务发现的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulProviderApplication</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsulProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后创建测试接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，访问 consul 后台管理页面，看到如下信息，表示已经成功。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-48f1f8f821424a8e9580f67d2e4b6fdb.png" alt="image.png"></p>
<h2 id="2-Consul-集群注册"><a href="#2-Consul-集群注册" class="headerlink" title="2. Consul 集群注册"></a>2. Consul 集群注册</h2><p>为了区分集群中的哪一个 provider 提供的服务，修改一下 consul 的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    Integer port;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&gt;&gt;&quot;</span>+port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对项目进行打包，命令行执行下列命令，启动两个 provider 实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar consul-provider-0.0.1-SNAPSHOT.jar --server.port=2000</span><br><span class="line">java -jar consul-provider-0.0.1-SNAPSHOT.jar --server.port=2001</span><br></pre></td></tr></table></figure>

<p>启动成功后，再去访问 consul 后台管理页面，就可以看到两个实例了：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-9c919e4a7b1f4491affb2aca23a07470.png" alt="image.png"></p>
<h2 id="3-消费"><a href="#3-消费" class="headerlink" title="3. 消费"></a>3. 消费</h2><p> 首先创建一个消费实例 consul-consumer，和 provider 一致。</p>
<p>创建成功后，添加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.application.name=consul-consumer</span><br><span class="line">server.port=2002</span><br><span class="line">spring.cloud.consul.host=192.168.1.111</span><br><span class="line">spring.cloud.consul.port=8500</span><br><span class="line">spring.cloud.consul.discovery.service-name=consul-consumer</span><br><span class="line">spring.cloud.consul.discovery.heartbeat.enabled=true</span><br></pre></td></tr></table></figure>

<p>开启服务发现，并添加 RestTemplate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulConsumerApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsulConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，提供调用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这里通过 loadBalancerClient 实例，可以获取要调用的 ServiceInstance， 获取到调用地址后再 用 RestTemplate 去调用。</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LoadBalancerClient loadBalancerClient;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServiceInstance choose = loadBalancerClient.choose(<span class="string">&quot;consul-provider&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务地址：&quot;</span>+ choose.getUri());</span><br><span class="line">        System.out.println(<span class="string">&quot;服务名称：&quot;</span>+choose.getServiceId());</span><br><span class="line">        String s = restTemplate.getForObject(choose.getUri()+<span class="string">&quot;/hello&quot;</span>, String.class);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后启动项目，浏览器输入： <a href="http://localhost:2002/hello">http://localhost:2002/hello</a> 查看结果，这个请求自带<strong>负载均衡</strong>功能。 </p>
<p>项目示例地址：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a> </p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 入门</title>
    <url>/2019/07/26/Docker%20%E5%85%A5%E9%97%A8-Docker%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Docker-教程"><a href="#Docker-教程" class="headerlink" title="Docker 教程"></a>Docker 教程</h2><p><img src="https://www.itmengtao.cn/upload/2020/11/image-e9ad632be88c4b248e857629e91f1d04.png" alt="image.png"></p>
<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p>
<p>可以通过 <a href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程</a> 来学习相关命令。</p>
<h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul>
<li><p>Web 应用的自动化打包和发布。</p>
</li>
<li><p>自动化测试和持续集成、发布。</p>
</li>
<li><p>在服务型环境中部署和调整数据库或其他的后台应用。</p>
</li>
<li><p>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p>
</li>
</ul>
<h2 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h2><ol>
<li><p>简化程序：<br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。</p>
</li>
<li><p>避免选择恐惧症：<br>如果你有选择恐惧症，还是资深患者。那么你可以使用 Docker 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</p>
</li>
<li><p>节省开支：<br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/ourstronger/article/details/100730903">CentOS 7 安装Docker</a><br>相关链接<br>参考：<a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></p>
<p>Docker 官网：<a href="http://www.docker.com/">http://www.docker.com</a></p>
<p>Github Docker 源码：<a href="https://github.com/docker/docker-ce">https://github.com/docker/docker-ce</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 命令（快速理解）</title>
    <url>/2019/08/15/Docker%20%E5%91%BD%E4%BB%A4%EF%BC%88%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%EF%BC%89-Docker%20%E5%91%BD%E4%BB%A4%EF%BC%88%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<p>最近在看docker，整理了部分命令出来，我都是用大白话写出来的，快速理解！言简意赅，后续继续补充。。。大家将就着看。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#service docker start  开启docker</span><br><span class="line">#service docker restart  重启docker</span><br></pre></td></tr></table></figure>
<p>使用Docker 中国加速器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">vi  /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">#添加后：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost lemon]# docker ps -a   （查看所有容器）</span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS                      PORTS                                                                                                                                                     NAMES</span><br><span class="line">e50ef9a67cab        rabbitmq:3-management   &quot;docker-entrypoint.s…&quot;   14 minutes ago      Up 14 minutes               0.0.0.0:32773-&gt;4369/tcp, 0.0.0.0:32772-&gt;5671/tcp, 0.0.0.0:32771-&gt;5672/tcp, 0.0.0.0:32770-&gt;15671/tcp, 0.0.0.0:32769-&gt;15672/tcp, 0.0.0.0:32768-&gt;25672/tcp   some-rabbit</span><br><span class="line">e15a786d3e8e        hello-world             &quot;/hello&quot;                 34 minutes ago      Exited (0) 34 minutes ago                                                                                                                                                             agitated_tharp</span><br><span class="line">9a989a595613        mysql:5.7               &quot;docker-entrypoint.s…&quot;   3 months ago        Exited (255) 3 months ago   0.0.0.0:3306-&gt;3306/tcp, 33060/tcp                                                                                                                         mysql</span><br></pre></td></tr></table></figure>
<h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ol>
<li>CONTAIINER ID<br>指的是容器的id，是唯一的标识符，在不会混淆的情况下可以采用id的前几位进行标识一个容器。</li>
<li>INAGE<br>表示创建容器时使用的镜像</li>
<li>COMMAND<br>表示容器最后运行的命令。</li>
<li>CREATED<br>创建容器的时间</li>
<li>STATUS<br>容器的状态，这里可能显示的一个容器启动时间，也能显示容器的关闭时间。具体看看容器当前的状态</li>
<li>PORTS<br>容器对外开放的端口</li>
<li>NAMES<br>容器名字，如果不设置，就会有一个默认名。</li>
</ol>
<p>启动docker后， </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># docker ps     查看当前正在运行的容器</span><br><span class="line"># docker ps -a  查看所有容器</span><br><span class="line"># docker ps -l  查看最近创建的容器</span><br><span class="line"># docker ps -n=xxx    docker ps -n=2 查看最新创建的2个容器</span><br></pre></td></tr></table></figure>
<p>【创建容器】<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker create nginx  (创建一个nginx容器,未启动,name是随机的)</span><br></pre></td></tr></table></figure><br>可以使用 docker ps -a 查看，如果status状态没有时间，则是未启动。</p>
<p>也可在创建时指定name,  <strong># docker create –name=nginx nginx (未启动,区别：run启动，create未启动)<br>#docker run –name nginx1 -d -p 8080:80 nginx (name:容器名字，-d表示容器后台运行，-p将80端口映射到8080端口)</strong><br>测试:浏览器输入：127.0.0.1:8080</p>
<p>【创建交互型容器】<br>例：创建ubuntu容器，命令执行完后，会打开一个输入终端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># docker run --name ubuntu -it ubuntu /bin/bash (-it:i表示开发容器的标准输入，t为容器创建一个命令行终端)</span><br></pre></td></tr></table></figure>
<p>【容器启动】<br>docker run （创建的容器就已经启动，用此命令时，就会自动去Docker Hub上下载相关镜像） </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker run --name nginx1 -d -p 8080:80 nginx (name:容器名字，-d表示容器后台运行，-p将80端口映射到8080端口)</span><br></pre></td></tr></table></figure>
<p>测试:浏览器输入：127.0.0.1:8080<br>docker create创建的未启动，需要docker start 容器id/name 启动：<br>例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker start nginx1  或 #docker start e50ef9a67cab </span><br></pre></td></tr></table></figure>
<p>【容器重启】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker restart 容器ID或容器名 (不管容器是否启动，直接重启容器)</span><br><span class="line">#docker restart 参数    (例如：#docker restart -t=60 容器ID或容器名)</span><br></pre></td></tr></table></figure>
<p>-t：关闭容器的限时，如果超时未能关闭则用kill强制关闭，默认值10s，这个时间用于容器的自己保存状态 </p>
<p>【容器自启动】<br>docker服务重启、机器重启、容器本身异常退出等原因，导致容器停止对外工作，需要自动重启，docker有自己的守护方式 restart policy.</p>
<p>restart policy</p>
<p>在docker run时通过–restart 设置守护机制，有四种模式 ：</p>
<p><strong>no</strong>：  不自动重新启动容器。（默认） </p>
<p><strong>on-failure</strong> ：  由于一个错误退出，它表现为退出状态不等于0，自动启动容器 </p>
<p><strong>unless-stopped</strong> ：  除非被显式停止 stop、kill 否则docker服务停止或自动重启，自动启动容器 </p>
<p><strong>always</strong>：  如果容器停止，总是重新启动容器。（这是官方解释，我测试了如果手动kill容器 无法自动重启，应该也属于正常 如果手动都不能让他停止 也许我们会更烦恼怎么停止它。）<br>对于上面的模式 我们生产常用的只有always.</p>
<p>例：**#docker run -d -p 80:12345 –restart always –name web weba:v0.1**<br>(测试自启动是否成功：<br>1、docker ps 查看了当前运行的容器<br>2、service docker restart 重启docker 服务<br>3、再次docker ps 查看当前运行的容器，此时发现已经自动启动容器<br>4、最后用网页查看一下 web是否启动 )</p>
<p>【进入正在运行的docker容器】<br>1、**#docker attach**</p>
<p>docker attach 容器名称或容器ID </p>
<p>此命令如果进入一些web服务会一致卡着无反应，猜测是监听阻塞了进入，而且已此方式进入容器如果执行exit或关闭会话 会停止掉容器。因此我们在生产环境中不用此命令。</p>
<p>2、**#docker exec**</p>
<p>docker exec -it 59ec /bin/bash (后补:如果提示“/bin/bash 未找到”之类的 可以改成:docker exec -it 59ec sh 此种问题我在centos中遇到过，ubuntu未测试)<br>执行会看到命令行的开头出现了变化，因为已经进入到了容器里面。</p>
<p>接下来我们在容器里面访问内部端口12345的站点<br>curl 127.0.0.1:12345<br>我们看到出现 html代码说明访问成功  </p>
<p>【容器停止】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker stop 容器ID或容器名 (停止容器）</span><br><span class="line">#docker kill 容器ID或容器名 (直接关闭容器)</span><br></pre></td></tr></table></figure>
<p>主要区别:stop给与一定的关闭时间交由容器自己保存状态，kill直接关闭(杀死)容器</p>
<p><strong>【容器删除】docker rm …<br>（单个删除）：#docker rm ubuntu (停止运行后删除)<br>              #docker rm -f ubuntu (强制删除)<br> (批量删除) ：#docker rm $(docker ps -a -q)      docker ps -a -q会列出所有容器的id，供rm命令删除<br>              #docker container prune (支持删除已退出的孤立的容器)</strong></p>
<p>【查看容器信息】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker inspect ubuntu  (查看ubuntu详细信息，id,容器名，环境变量，网络配置等)</span><br></pre></td></tr></table></figure>
<p>查看容器运行状态：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker inspect -f=&#x27;&#123;&#123;.Status.Running&#125;&#125;&#x27; ubuntu</span><br></pre></td></tr></table></figure>
<p>查看容器ip地址：  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker inspect -f=&#x27;&#123;&#123;.NetworkSettings.IPAdress&#125;&#125;&#x27; ubuntu</span><br></pre></td></tr></table></figure>
<p>【容器进程】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker top ubuntu (确保容器已启动)</span><br></pre></td></tr></table></figure>
<p>【容器日志】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker logs ubuntu (历史日志)</span><br><span class="line">#docker logs -f ubuntu (实时日志)</span><br></pre></td></tr></table></figure>
<p>【容器导出】(docker的可移植性，导出到当前目录文件夹下)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker export $container_id &gt; 容器快照名  (e：#docker export 5fbe4b029608 &gt; ubuntu.tar)</span><br></pre></td></tr></table></figure>
<p>【容器导入】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># docker images （列出本地镜像。）</span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">rabbitmq            3-management        2fb79bc1163c        30 hours ago        177MB</span><br><span class="line">mysql               5.7                 7faa3c53e6d6        4 months ago        373MB</span><br><span class="line">centos              latest              9f38484d220f        6 months ago        202MB</span><br><span class="line">hello-world         latest              fce289e99eb9        8 months ago        1.84kB</span><br></pre></td></tr></table></figure>
<p>然后：<br><strong>#cat ubuntu.tar | docker import - mycentos:v888  (mycentos:上面的REPOSITORY，v888：上面的TAG)</strong><br>导入成功后，docker run 命令启动</p>
<p>【查看镜像】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker images  （查看本地所有镜像）</span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">rabbitmq            3-management        2fb79bc1163c        30 hours ago        177MB</span><br><span class="line">mysql               5.7                 7faa3c53e6d6        4 months ago        373MB</span><br><span class="line">centos              latest              9f38484d220f        6 months ago        202MB</span><br><span class="line">hello-world         latest              fce289e99eb9        8 months ago        1.84kB</span><br></pre></td></tr></table></figure>
<p>名词解释：1.REPOSITORY：仓库名，一般用来存放同一类型的镜像。<br>      [namespace\ubuntu] 这种仓库名由命名空间和实际的仓库名组成，类似Github<br>      [ubuntu]官方的仓库名<br>      [hub.c.163.com/library/nginx] 用于非Docker Hub上的镜像命名，例如第三方服务商提供的镜像或者开发者自己搭建的镜像中心。<br>       2.TAG：区分同一仓库中的不同镜像，默认为latest<br>       3.IMAGE ID:唯一标识符<br>       4.CREATED:创建时间<br>       5.SIZE:镜像大小</p>
<p>【下载镜像】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker pull hub.c.163.com/library/nginx:latest   (如果docker run下载慢，先pull下载下来，然后再运行)</span><br><span class="line">#docker images 查看</span><br><span class="line">#docker run -itd --name 163nginx -p 80:80 hub.c.163.com/library/nginx:latest (运行)</span><br></pre></td></tr></table></figure>
<p>【删除镜像】<strong>docker rmi …</strong>(参数为镜像的id或者镜像名，可有多个，中间用逗号隔开)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker images 查看</span><br><span class="line">#docker rmi 2fb79bc1163c hello-world:latest (删除id为2fb..和hello-world的镜像)</span><br></pre></td></tr></table></figure>
<p>注:有时候无法删除一个镜像大部分原因是因为该镜像被一个容器所依赖，要先删除容器，再删镜像。</p>
<p>【创建本地镜像】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker commit -m &quot;describe&quot; -author=&quot;zhangsan&quot; ce1fe32739402 zhangsan/nginx:v1</span><br></pre></td></tr></table></figure>
<p>1.参数-m是创建该镜像的一个简单描述<br>2.–author 表示该镜像的作者<br>3.ce1fe32739402 表示创建镜像所依据的容器id<br>4.zhangsan/nginx 为仓库名，zhangsan是命名空间，mginx是镜像名<br>5.v1表示仓库的tag<br>6.创建完成后，通过docker images就可以看到刚刚创建的镜像<br>7.通过刚刚创建的镜像运行一个容器，访问该容器，发现nginx内容已经改变。</p>
<p>【Dockerfile】详细点击下文：<br><a href="https://blog.csdn.net/ourstronger/article/details/100917625">Dockerfile 使用介绍</a></p>
<p><a href="https://blog.csdn.net/ourstronger/article/details/100924945">Dockerfile 命令详解</a></p>
<p>【Docker Hub】<br>类似于GitHub，镜像托管服务，地址为：<a href="https://hub.docker.com/">https://hub.docker.com/</a> (如果嫌太慢，用网易的：<a href="https://c.163yun.com/hub#/m/home">https://c.163yun.com/hub#/m/home</a>)<br>打开Docker Hub，注册一个账号。<br>在客户端命令行登录：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># docker login</span><br></pre></td></tr></table></figure>
<p>看到Login Succeeded表示成功。</p>
<p>登录成功后，就可以使用push命令上传我们自制的镜像了。命名要规范，即namespace/name格式，namespace必须是用户名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#docker build -t iweirdo/nginx:v1</span><br></pre></td></tr></table></figure>
<p>【暴露网络端口】<br>Docker中设计暴露网络端口的参数有两个，分别是-p和-P （大小写）<br>1、使用-P：</p>
<p>Docker会在宿主机上随机为应用分配一个未被使用的端口，并将其映射到容器开放的端口，以Nginx为例，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost lemon]# docker run -itd --name nginx -P 5a3221f0137b</span><br><span class="line">40958d13ea6a274c493bd1e2135f8416d8eb138cf510320c4f68019e1d1e41f8</span><br><span class="line">[root@localhost lemon]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">40958d13ea6a        5a3221f0137b        &quot;nginx -g &#x27;daemon of…&quot;   16 seconds ago      Up 6 seconds        0.0.0.0:32768-&gt;80/tcp   nginx</span><br></pre></td></tr></table></figure>
<p> docker为应用分配了一个随机端口32768,使用该端口可访问容器中的nginx(<a href="http://192.168.1.132:32768/">http://192.168.1.132:32768</a>)</p>
<p>2、使用-p：<br>  -p参数有几种不同的用法：</p>
<p>hostPort:containerPort (这种方法是将宿主机端口和容器端口绑定起来，如下:)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost lemon]# docker run -itd --name nginx -p 80:80 5a3221f0137b  (表示将宿主机的80端口映射到容器的80上，第一个80是宿主机的80，第二个80是容器的80)</span><br></pre></td></tr></table></figure>
<p>ip:hostPort:containerPort (这种方法是将指定的ip的端口和容器的端口进行映射，如下：)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost lemon]# docker run -itd --name nginx -p 192.168.1.132:80:80 5a3221f0137b （表示将192.168.1.132地址的80端口映射到容器的80端口上）</span><br></pre></td></tr></table></figure>
<p>ip::containerPort (这种是将指定的ip地址的随机端口映射到容器的开放端口上，如下：)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost lemon]# docker run -itd --name nginx -p 192.168.1.132::80 5a3221f0137b</span><br></pre></td></tr></table></figure>

<p>未完待续。。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装 Redis</title>
    <url>/2020/03/25/Docker%20%E5%AE%89%E8%A3%85%20Redis-Docker%20%E5%AE%89%E8%A3%85%20Redis/</url>
    <content><![CDATA[<p>CentOS7:</p>
<ol>
<li>查询镜像</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>

<p><img src="https://www.itmengtao.cn/upload/2020/12/image-629b79e3847b495da83efa879ad90a90.png" alt="image.png"></p>
<ol start="2">
<li>拉取官方的镜像，（选 stars 最多的）： </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-c1a1b953b8804eb2bb165e27fe8db0ae.png" alt="image.png"></p>
<ol start="3">
<li>查看一下是否成功：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-d2cf3e437c014f6f88f28243f8d0eb3b.png" alt="image.png"></p>
<ol start="4">
<li>启动镜像：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 -d redis:latest redis-server</span><br></pre></td></tr></table></figure>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-36f66a552af24ec8a0f368b83b900e19.png" alt="image.png"></p>
<ol start="5">
<li>查看容器启动情况：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img src="https://www.itmengtao.cn/upload/2020/12/image-714db11bc9774aae8c608fa421539143.png" alt="image.png"></p>
<ol start="6">
<li>容器运行起来后，若想进入容器内部，并进行命令行操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  docker exec -it intelligent_driscoll bash</span><br></pre></td></tr></table></figure>

<p><img src="https://www.itmengtao.cn/upload/2020/12/image-e52f4fa2935c4512a5a592cdf23f0fba.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.  redis-cli</span><br></pre></td></tr></table></figure>

<p><img src="https://www.itmengtao.cn/upload/2020/12/image-bd12ac5a45774fb2a5f2bb9e34d4a3f4.png" alt="image.png"></p>
<p>查看是否设置了密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> auth root</span><br></pre></td></tr></table></figure>

<p><img src="https://www.itmengtao.cn/upload/2020/12/image-f5fe92fbb9b34c93b77d5f72d1ad2693.png" alt="image.png"></p>
<p>(error) ERR Client sent AUTH, but no password is set</p>
<p>说明没有设置密码，执行命令 (123456 是密码)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config set requirepass 123456</span><br></pre></td></tr></table></figure>

<p><img src="https://www.itmengtao.cn/upload/2020/12/image-5af559c3e34942298eb83d8853fd5f71.png" alt="image.png"></p>
<p>出现 OK 说明设置成功，然后通过 ping命令进行连通性测试，如果看到 pong，表示连接成功了。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-9c7ac4262455466f8b9d431acf258ae3.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Redis | Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker——Dockerfile 使用介绍</title>
    <url>/2019/08/16/Docker%E2%80%94%E2%80%94Dockerfile%20%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D-Docker%E2%80%94%E2%80%94Dockerfile%20%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="Dockerfile-概念"><a href="#Dockerfile-概念" class="headerlink" title="Dockerfile 概念"></a>Dockerfile 概念</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>官方仓库虽然有数十万的镜像资源，但在绝大多数情况下都不符合我们的需求，通常我们都会自己构建镜像。Dockfile 是一种被 Docker 程序解释的脚本， Dockerfile 由一条一条的指令组成，每条指令对应 Linux 下面的一条命令。Docker 程序将这些 Dockerfile 指令翻译真正的Linux命令。Docker 程序将读取 Dockerfile，根据指令生成定制的 image。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了写命令的麻烦。</p>
<p><strong>注意：每一条指令就相当于给镜像加了一层，一个镜像不能超过 127 层</strong></p>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<h2 id="常用指令："><a href="#常用指令：" class="headerlink" title="常用指令："></a>常用指令：</h2><p><img src="https://www.itmengtao.cn/upload/2020/11/image-0c62e19d7a114ade82fd20bd46abc4fe.png" alt="image.png"></p>
<p>ENTRYPOINT与CMD的<strong>区别</strong>在于ENTRYPOINT可以使用CMD作为参数，通常都是用作启动后台服务。</p>
<p>Dockerfile文件格式如下，举个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">##  Dockerfile文件格式</span><br><span class="line"> </span><br><span class="line"># This dockerfile uses the ubuntu image</span><br><span class="line"># VERSION 2 - EDITION 1</span><br><span class="line"># Author: docker_user</span><br><span class="line"># Command format: Instruction [arguments / command] ..</span><br><span class="line"> </span><br><span class="line"># 1、指定基础镜像信息</span><br><span class="line">FROM ubuntu</span><br><span class="line"> </span><br><span class="line"># 2、维护者信息</span><br><span class="line">MAINTAINER docker_user docker_user@email.com</span><br><span class="line"> </span><br><span class="line"># 3、镜像操作指令</span><br><span class="line">RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf</span><br><span class="line"> </span><br><span class="line"># 4、容器启动执行指令</span><br><span class="line">CMD /usr/sbin/nginx</span><br></pre></td></tr></table></figure>
<p> Dockerfile 分为<strong>四部分：基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令</strong>。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 RUN 指令。每执行一条RUN 指令，镜像添加新的一层，并提交；最后是 CMD 指令，来指明运行容器时的操作命令。</p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>docker build 命令会根据 Dockerfile 文件及上下文构建新 Docker 镜像。构建上下文是指 Dockerfile 所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p>
<p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>说明：构建会在 Docker 后台守护进程（daemon）中执行，而不是CLI中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将 Dockerfile 文件放在该目录下。</p>
<p>在构建上下文中使用的 Dockerfile 文件，是一个构建指令文件。为了提高构建性能，可以通过.dockerignore文件排除上下文目录下不需要的文件和目录。</p>
<p>在 Docker 构建镜像的第一步，docker CLI 会先在上下文目录中寻找.dockerignore文件，根据.dockerignore 文件排除上下文目录中的部分文件和目录，然后把剩下的文件和目录传递给 Docker 服务。</p>
<p>Dockerfile 一般位于构建上下文的根目录下，也可以通过-f指定该文件的位置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure>
<p>构建时，还可以通过-t参数指定构建成镜像的仓库、标签。</p>
<h2 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3 .</span><br></pre></td></tr></table></figure>
<p>如果存在多个仓库下，或使用多个镜像标签，就可以使用多个-t参数：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3:1.0.2 -t nginx/v3:latest .</span><br></pre></td></tr></table></figure>
<p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>接下来用一个简单的示例来感受一下 Dockerfile 是如何用来构建镜像启动容器。我们以定制 nginx 镜像为例，在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line">cd mynginx</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure>
<p>构建一个 Dockerfile 文件内容为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">vi Dockerfile</span><br><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Docker!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<p>这个 Dockerfile 很简单，一共就两行涉及到了两条指令：FROM 和 RUN，FROM 表示获取指定基础镜像，RUN 执行命令，在执行的过程中重写了 nginx 的默认页面信息，将信息替换为：Hello, Docker!。</p>
<p>在 Dockerfile 文件所在目录执行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v1 .</span><br></pre></td></tr></table></figure>
<p>命令最后有一个.  表示当前目录</p>
<p>构建完成之后，使用 docker images 命令查看所有镜像，如果存在 REPOSITORY 为 nginx 和 TAG 是 v1 的信息，就表示构建成功。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                           v1                  8c92471de2cc        6 minutes ago       108.6 MB</span><br></pre></td></tr></table></figure>
<p>接下来使用 docker run 命令来启动容器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker run  --name docker_nginx_v1   -d -p 80:80 nginx:v1</span><br></pre></td></tr></table></figure>
<p>这条命令会用 nginx 镜像启动一个容器，命名为docker_nginx_v1，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器：<a href="http://192.168.1.132/%EF%BC%8C%E9%A1%B5%E9%9D%A2%E8%BF%94%E5%9B%9E%E4%BF%A1%E6%81%AF%EF%BC%9A">http://192.168.1.132/，页面返回信息：</a></p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-22bd92a01dab43639e8e9d28eaa6caa4.png" alt="image.png"></p>
<p>这样一个简单使用 Dockerfile 构建镜像，运行容器的示例就完成了！</p>
<h2 id="修改容器内容"><a href="#修改容器内容" class="headerlink" title="修改容器内容"></a>修改容器内容</h2><p>容器启动后，需要对容器内的文件进行进一步的完善，可以使用docker exec -it xx bash命令再次进行修改，以上面的示例为基础，修改 nginx 启动页面内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker exec -it docker_nginx_v1   bash</span><br><span class="line">root@3729b97e8226:/# echo &#x27;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Docker neo!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">root@3729b97e8226:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>以交互式终端方式进入 docker_nginx_v1 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。然后，我们用<h1>Hello, Docker neo!</h1>覆盖了 /usr/share/nginx/html/index.html 的内容。</p>
<p>再次刷新浏览器，会发现内容被改变。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-5df17d0ea9c244268a8d6a3911079a52.png" alt="image.png"></p>
<p>修改了容器的文件，也就是改动了容器的存储层，可以通过 docker diff 命令看到具体的改动。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker diff docker_nginx_v1 </span><br><span class="line">... </span><br></pre></td></tr></table></figure>
<p>这样 Dockerfile 使用方式就为大家介绍完了。以上</p>
<p>参考：</p>
<p><a href="https://itbilu.com/linux/docker/VyhM5wPuz.html">https://itbilu.com/linux/docker/VyhM5wPuz.html</a></p>
<p><a href="https://blog.csdn.net/ityouknow/article/details/79590643">https://blog.csdn.net/ityouknow/article/details/79590643</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker——Dockerfile 命令详解</title>
    <url>/2019/08/25/Docker%E2%80%94%E2%80%94Dockerfile%20%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3-Docker%E2%80%94%E2%80%94Dockerfile%20%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>本文来自：<a href="https://blog.csdn.net/ityouknow/article/details/79600406">https://blog.csdn.net/ityouknow/article/details/79600406</a> ，声明：仅供学习参考。</p>
<p>Dockerfile 指令详解<br>1、FROM 指定基础镜像<br>FROM 指令用于指定其后构建新镜像所使用的基础镜像。FROM 指令必是 Dockerfile 文件中的首条命令，启动构建流程后，Docker 将会基于该镜像构建新镜像，FROM 后的命令也会基于这个基础镜像。</p>
<p>FROM语法格式为：</p>
<p>FROM <image></p>
<p>或</p>
<p>FROM <image>:<tag><br>或</p>
<p>FROM <image>:<digest><br>通过 FROM 指定的镜像，可以是任何有效的基础镜像。FROM 有以下限制：</p>
<p>FROM 必须 是 Dockerfile 中第一条非注释命令<br>在一个 Dockerfile 文件中创建多个镜像时，FROM 可以多次出现。只需在每个新命令 FROM 之前，记录提交上次的镜像 ID。<br>tag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像</p>
<p>2 、RUN 执行命令<br>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。格式:</p>
<p>#shell格式<br>RUN <command><br>#exec格式<br>RUN [“executable”, “param1”, “param2”]<br>RUN 命令将在当前 image 中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行 Dockerfile 中的下一个指令。<br>层级 RUN 指令和生成提交是符合 Docker 核心理念的做法。它允许像版本控制那样，在任意一个点，对 image 镜像进行定制化构建。<br>RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 –no-cache 参数，如：docker build –no-cache。</p>
<p>3 、COPY 复制文件<br>格式：</p>
<p>COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]<br>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。比如：</p>
<p>COPY package.json /usr/src/app/<br>&lt;源路径&gt;可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>
<p>COPY hom* /mydir/<br>COPY hom?.txt /mydir/<br>&lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<p>4、 ADD 更高级的复制文件<br>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如&lt;源路径&gt;可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到&lt;目标路径&gt;去。</p>
<p>在构建镜像时，复制上下文中的文件到镜像内，格式：</p>
<p>ADD &lt;源路径&gt;… &lt;目标路径&gt;<br>ADD [“&lt;源路径&gt;”,… “&lt;目标路径&gt;”]<br>注意 <br>如果 docker 发现文件内容被改变，则接下来的指令都不会再使用缓存。关于复制文件时需要处理的/，基本跟正常的 copy 一致</p>
<p>5 ENV 设置环境变量<br>格式有两种：</p>
<p>ENV <key> <value><br>ENV <key1>=<value1> <key2>=<value2>…<br>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<p>ENV VERSION=1.0 DEBUG=on <br>    NAME=”Happy Feet”<br>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<p>6 EXPOSE<br>为构建的镜像设置监听端口，使容器在运行时监听。格式：</p>
<p>EXPOSE <port> [<port>…]<br>EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 -p、-P 参数来发布容器端口到 host 的某个端口上。</p>
<p>7 VOLUME 定义匿名卷<br>VOLUME用于创建挂载点，即向基于所构建镜像创始的容器添加卷：</p>
<p>VOLUME [“/data”]<br>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p>
<p>卷可以容器间共享和重用<br>容器并不一定要和其它容器共享卷<br>修改卷后会立即生效<br>对卷的修改不会对镜像产生影响<br>卷会一直存在，直到没有任何容器在使用它<br>VOLUME 让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p>
<p>8 WORKDIR 指定工作目录<br>WORKDIR用于在容器内设置一个工作目录：</p>
<p>WORKDIR /path/to/workdir<br>通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。 <br>如，使用WORKDIR设置工作目录：</p>
<p>WORKDIR /a<br>WORKDIR b<br>WORKDIR c<br>RUN pwd<br>在以上示例中，pwd 最终将会在 /a/b/c 目录中执行。在使用 docker run 运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。</p>
<p>9 USER 指定当前用户<br>USER 用于指定运行镜像所使用的用户：</p>
<p>USER daemon<br>使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试：</p>
<p>USER user<br>USER user:group<br>USER uid<br>USER uid:gid<br>USER user:gid<br>USER uid:group<br>使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。镜像构建完成后，通过 docker run 运行容器时，可以通过 -u 参数来覆盖所指定的用户。</p>
<p>10 CMD<br>CMD用于指定在容器启动时所要执行的命令。CMD 有以下三种格式：</p>
<p>CMD [“executable”,”param1”,”param2”]<br>CMD [“param1”,”param2”]<br>CMD command param1 param2<br>省略可执行文件的 exec 格式，这种写法使 CMD 中的参数当做 ENTRYPOINT 的默认参数，此时 ENTRYPOINT 也应该是 exec 格式，具体与 ENTRYPOINT 的组合使用，参考 ENTRYPOINT。</p>
<p>注意 <br>与 RUN 指令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。</p>
<p>11 ENTRYPOINT<br>ENTRYPOINT 用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序。ENTRYPOINT 有以下两种形式：</p>
<p>ENTRYPOINT [“executable”, “param1”, “param2”]<br>ENTRYPOINT command param1 param2<br>ENTRYPOINT 与 CMD 非常类似，不同的是通过docker run执行的命令不会覆盖 ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。</p>
<p>docker run运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。如，执行docker run <image> -d时，-d 参数将被传递给入口点。</p>
<p>也可以通过docker run –entrypoint重写 ENTRYPOINT 入口点。如：可以像下面这样指定一个容器执行程序：</p>
<p>ENTRYPOINT [“/usr/bin/nginx”]<br>完整构建代码：</p>
<h1 id="Version-0-0-3"><a href="#Version-0-0-3" class="headerlink" title="Version: 0.0.3"></a>Version: 0.0.3</h1><p>FROM ubuntu:16.04<br>MAINTAINER 何民三 “<a href="mailto:&#x63;&#x6e;&#46;&#108;&#x69;&#x75;&#104;&#x74;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#x63;&#x6e;&#46;&#108;&#x69;&#x75;&#104;&#x74;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>“<br>RUN apt-get update<br>RUN apt-get install -y nginx<br>RUN echo ‘Hello World, 我是个容器’ \ <br>   &gt; /var/www/html/index.html<br>ENTRYPOINT [“/usr/sbin/nginx”]<br>EXPOSE 80<br>使用docker build构建镜像，并将镜像指定为 itbilu/test：</p>
<p>docker build -t=”itbilu/test” .<br>构建完成后，使用itbilu/test启动一个容器：</p>
<p>docker run -i -t  itbilu/test -g “daemon off;”<br>在运行容器时，我们使用了 -g “daemon off;”，这个参数将会被传递给 ENTRYPOINT，最终在容器中执行的命令为 /usr/sbin/nginx -g “daemon off;”。</p>
<p>12 LABEL<br>LABEL用于为镜像添加元数据，元数以键值对的形式指定：</p>
<p>LABEL <key>=<value> <key>=<value> <key>=<value> …<br>使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。 <br>如，通过LABEL指定一些元数据：</p>
<p>LABEL version=”1.0” description=”这是一个Web服务器” by=”IT笔录”<br>指定后可以通过docker inspect查看：</p>
<p>docker inspect itbilu/test<br>“Labels”: {<br>    “version”: “1.0”,<br>    “description”: “这是一个Web服务器”,<br>    “by”: “IT笔录”<br>},<br>13 ARG<br>ARG用于指定传递给构建运行时的变量：</p>
<p>ARG <name>[=<default value>]<br>如，通过ARG指定两个变量：</p>
<p>ARG site<br>ARG build_user=IT笔录<br>以上我们指定了 site 和 build_user 两个变量，其中 build_user 指定了默认值。在使用 docker build 构建镜像时，可以通过 –build-arg <varname>=<value> 参数来指定或重设置这些变量的值。</p>
<p>docker build –build-arg site=itiblu.com -t itbilu/test .<br>这样我们构建了 itbilu/test 镜像，其中site会被设置为 itbilu.com，由于没有指定 build_user，其值将是默认值 IT 笔录。</p>
<p>14 ONBUILD<br>ONBUILD用于设置镜像触发器：</p>
<p>ONBUILD [INSTRUCTION]<br>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。 <br>如，当镜像被使用时，可能需要做一些处理：</p>
<p>[…]<br>ONBUILD ADD . /app/src<br>ONBUILD RUN /usr/local/bin/python-build –dir /app/src<br>[…]<br>15 STOPSIGNAL<br>STOPSIGNAL用于设置停止容器所要发送的系统调用信号：</p>
<p>STOPSIGNAL signal<br>所使用的信号必须是内核系统调用表中的合法的值，如：SIGKILL。</p>
<p>16 SHELL<br>SHELL用于设置执行命令（shell式）所使用的的默认 shell 类型：</p>
<p>SHELL [“executable”, “parameters”]<br>SHELL在Windows环境下比较有用，Windows 下通常会有 cmd 和 powershell 两种 shell，可能还会有 sh。这时就可以通过 SHELL 来指定所使用的 shell 类型：</p>
<p>FROM microsoft/windowsservercore</p>
<h1 id="Executed-as-cmd-S-C-echo-default"><a href="#Executed-as-cmd-S-C-echo-default" class="headerlink" title="Executed as cmd /S /C echo default"></a>Executed as cmd /S /C echo default</h1><p>RUN echo default</p>
<h1 id="Executed-as-cmd-S-C-powershell-command-Write-Host-default"><a href="#Executed-as-cmd-S-C-powershell-command-Write-Host-default" class="headerlink" title="Executed as cmd /S /C powershell -command Write-Host default"></a>Executed as cmd /S /C powershell -command Write-Host default</h1><p>RUN powershell -command Write-Host default</p>
<h1 id="Executed-as-powershell-command-Write-Host-hello"><a href="#Executed-as-powershell-command-Write-Host-hello" class="headerlink" title="Executed as powershell -command Write-Host hello"></a>Executed as powershell -command Write-Host hello</h1><p>SHELL [“powershell”, “-command”]<br>RUN Write-Host hello</p>
<h1 id="Executed-as-cmd-S-C-echo-hello"><a href="#Executed-as-cmd-S-C-echo-hello" class="headerlink" title="Executed as cmd /S /C echo hello"></a>Executed as cmd /S /C echo hello</h1><p>SHELL [“cmd”, “/S””, “/C”]<br>RUN echo hello<br>Dockerfile 使用经验<br>Dockerfile 示例<br>构建Nginx运行环境</p>
<h1 id="指定基础镜像"><a href="#指定基础镜像" class="headerlink" title="指定基础镜像"></a>指定基础镜像</h1><p>FROM sameersbn/ubuntu:14.04.20161014</p>
<h1 id="维护者信息"><a href="#维护者信息" class="headerlink" title="维护者信息"></a>维护者信息</h1><p>MAINTAINER <a href="mailto:&#115;&#x61;&#x6d;&#101;&#101;&#114;&#64;&#x64;&#x61;&#x6d;&#x61;&#x67;&#101;&#x68;&#101;&#97;&#x64;&#x2e;&#x63;&#x6f;&#x6d;">&#115;&#x61;&#x6d;&#101;&#101;&#114;&#64;&#x64;&#x61;&#x6d;&#x61;&#x67;&#101;&#x68;&#101;&#97;&#x64;&#x2e;&#x63;&#x6f;&#x6d;</a></p>
<h1 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h1><p>ENV RTMP_VERSION=1.1.10 <br>    NPS_VERSION=1.11.33.4 <br>    LIBAV_VERSION=11.8 <br>    NGINX_VERSION=1.10.1 <br>    NGINX_USER=www-data <br>    NGINX_SITECONF_DIR=/etc/nginx/sites-enabled <br>    NGINX_LOG_DIR=/var/log/nginx <br>    NGINX_TEMP_DIR=/var/lib/nginx <br>    NGINX_SETUP_DIR=/var/cache/nginx</p>
<h1 id="设置构建时变量，镜像建立完成后就失效"><a href="#设置构建时变量，镜像建立完成后就失效" class="headerlink" title="设置构建时变量，镜像建立完成后就失效"></a>设置构建时变量，镜像建立完成后就失效</h1><p>ARG BUILD_LIBAV=false<br>ARG WITH_DEBUG=false<br>ARG WITH_PAGESPEED=true<br>ARG WITH_RTMP=true</p>
<h1 id="复制本地文件到容器目录中"><a href="#复制本地文件到容器目录中" class="headerlink" title="复制本地文件到容器目录中"></a>复制本地文件到容器目录中</h1><p>COPY setup/ ${NGINX_SETUP_DIR}/<br>RUN bash ${NGINX_SETUP_DIR}/install.sh</p>
<h1 id="复制本地配置文件到容器目录中"><a href="#复制本地配置文件到容器目录中" class="headerlink" title="复制本地配置文件到容器目录中"></a>复制本地配置文件到容器目录中</h1><p>COPY nginx.conf /etc/nginx/nginx.conf<br>COPY entrypoint.sh /sbin/entrypoint.sh</p>
<h1 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h1><p>RUN chmod 755 /sbin/entrypoint.sh</p>
<h1 id="允许指定的端口"><a href="#允许指定的端口" class="headerlink" title="允许指定的端口"></a>允许指定的端口</h1><p>EXPOSE 80/tcp 443/tcp 1935/tcp</p>
<h1 id="指定网站目录挂载点"><a href="#指定网站目录挂载点" class="headerlink" title="指定网站目录挂载点"></a>指定网站目录挂载点</h1><p>VOLUME [“${NGINX_SITECONF_DIR}”]</p>
<p>ENTRYPOINT [“/sbin/entrypoint.sh”]<br>CMD [“/usr/sbin/nginx”]</p>
<p>构建tomcat 环境<br>Dockerfile文件</p>
<h1 id="指定基于的基础镜像"><a href="#指定基于的基础镜像" class="headerlink" title="指定基于的基础镜像"></a>指定基于的基础镜像</h1><p>FROM ubuntu:13.10  </p>
<h1 id="维护者信息-1"><a href="#维护者信息-1" class="headerlink" title="维护者信息"></a>维护者信息</h1><p>MAINTAINER zhangjiayang “<a href="mailto:&#122;&#104;&#97;&#110;&#103;&#106;&#x69;&#97;&#121;&#x61;&#x6e;&#103;&#64;&#x73;&#99;&#122;&#113;&#46;&#99;&#x6f;&#109;&#x2e;&#x63;&#x6e;">&#122;&#104;&#97;&#110;&#103;&#106;&#x69;&#97;&#121;&#x61;&#x6e;&#103;&#64;&#x73;&#99;&#122;&#113;&#46;&#99;&#x6f;&#109;&#x2e;&#x63;&#x6e;</a>“  </p>
<h1 id="镜像的指令操作"><a href="#镜像的指令操作" class="headerlink" title="镜像的指令操作"></a>镜像的指令操作</h1><h1 id="获取APT更新的资源列表"><a href="#获取APT更新的资源列表" class="headerlink" title="获取APT更新的资源列表"></a>获取APT更新的资源列表</h1><p>RUN echo “deb <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> precise main universe”&gt; /etc/apt/sources.list</p>
<h1 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h1><p>RUN apt-get update  </p>
<h1 id="Install-curl"><a href="#Install-curl" class="headerlink" title="Install curl"></a>Install curl</h1><p>RUN apt-get -y install curl  </p>
<h1 id="Install-JDK-7"><a href="#Install-JDK-7" class="headerlink" title="Install JDK 7"></a>Install JDK 7</h1><p>RUN cd /tmp &amp;&amp;  curl -L ‘<a href="http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz&#39;">http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz&#39;</a> -H ‘Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile’ | tar -xz  <br>RUN mkdir -p /usr/lib/jvm  <br>RUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/  </p>
<h1 id="Set-Oracle-JDK-7-as-default-Java"><a href="#Set-Oracle-JDK-7-as-default-Java" class="headerlink" title="Set Oracle JDK 7 as default Java"></a>Set Oracle JDK 7 as default Java</h1><p>RUN update-alternatives –install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300     <br>RUN update-alternatives –install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300     </p>
<h1 id="设置系统环境"><a href="#设置系统环境" class="headerlink" title="设置系统环境"></a>设置系统环境</h1><p>ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/  </p>
<h1 id="Install-tomcat7"><a href="#Install-tomcat7" class="headerlink" title="Install tomcat7"></a>Install tomcat7</h1><p>RUN cd /tmp &amp;&amp; curl -L ‘<a href="http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz&#39;">http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz&#39;</a> | tar -xz  <br>RUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/  </p>
<p>ENV CATALINA_HOME /opt/tomcat7  <br>ENV PATH $PATH:$CATALINA_HOME/bin  </p>
<h1 id="复件tomcat7-sh到容器中的目录"><a href="#复件tomcat7-sh到容器中的目录" class="headerlink" title="复件tomcat7.sh到容器中的目录"></a>复件tomcat7.sh到容器中的目录</h1><p>ADD tomcat7.sh /etc/init.d/tomcat7  <br>RUN chmod 755 /etc/init.d/tomcat7  </p>
<h1 id="Expose-ports-指定暴露的端口"><a href="#Expose-ports-指定暴露的端口" class="headerlink" title="Expose ports.  指定暴露的端口"></a>Expose ports.  指定暴露的端口</h1><p>EXPOSE 8080  </p>
<h1 id="Define-default-command"><a href="#Define-default-command" class="headerlink" title="Define default command."></a>Define default command.</h1><p>ENTRYPOINT service tomcat7 start &amp;&amp; tail -f /opt/tomcat7/logs/catalina.out</p>
<p>tomcat7.sh命令文件</p>
<p>export JAVA_HOME=/usr/lib/jvm/java-7-oracle/  <br>export TOMCAT_HOME=/opt/tomcat7  </p>
<p>case $1 in  <br>start)  <br>  sh $TOMCAT_HOME/bin/startup.sh  <br>;;  <br>stop)  <br>  sh $TOMCAT_HOME/bin/shutdown.sh  <br>;;  <br>restart)  <br>  sh $TOMCAT_HOME/bin/shutdown.sh  <br>  sh $TOMCAT_HOME/bin/startup.sh  <br>;;  <br>esac  <br>exit 0<br>原则与建议<br>容器轻量化。从镜像中产生的容器应该尽量轻量化，能在足够短的时间内停止、销毁、重新生成并替换原来的容器。<br>使用 .gitignore。在大部分情况下，Dockerfile 会和构建所需的文件放在同一个目录中，为了提高构建的性能，应该使用 .gitignore 来过滤掉不需要的文件和目录。<br>为了减少镜像的大小，减少依赖，仅安装需要的软件包。<br>一个容器只做一件事。解耦复杂的应用，分成多个容器，而不是所有东西都放在一个容器内运行。如一个 Python Web 应用，可能需要 Server、DB、Cache、MQ、Log 等几个容器。一个更加极端的说法：One process per container。<br>减少镜像的图层。不要多个 Label、ENV 等标签。<br>对续行的参数按照字母表排序，特别是使用apt-get install -y安装包的时候。<br>使用构建缓存。如果不想使用缓存，可以在构建的时候使用参数–no-cache=true来强制重新生成中间镜像。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker一键安装RabbitMQ</title>
    <url>/2019/08/04/Docker%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85RabbitMQ-%E9%82%A3%E6%9D%AF%E7%83%AD%E5%92%96%E5%95%A1Docker%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>
<p>RabbitMQ是采用Erlang语言实现AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBM WEBSPHERE MQ等等。</p>
<h2 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h2><p>消息（Message）是指在应用间传送的数据，消息可以很简单，如：文本字符串、JSON等，也可以很复杂，如：内嵌对象等。</p>
<p>消息队列中间件（Message Queue Middleware，简称MQ）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成，通过提供消息传递和消息排队模型，可以在分布式环境下扩展进程间的通信。</p>
<p>消息队列中间件，也可成为消息队列或者消息中间件，它一般有二种传递模式：</p>
<ol>
<li><p>点对点（P2P，Point-to-Point）模式<br>点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输成为可能。</p>
</li>
<li><p>发布/订阅（Pub/Sub）模式<br>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点成为主题，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息的订阅者则从主题中订阅消息。主题使得消息的订阅和消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</p>
</li>
</ol>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul>
<li><p>可伸缩性：集群服务</p>
</li>
<li><p>消息持久化：从内存持久化消息到硬盘，再从硬盘加载到内存</p>
</li>
<li><p>可靠性：使用一些机制来保证可靠性，如持久化、传输确认及发布确认等；</p>
</li>
<li><p>灵活的路由：在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ已经提供了一些内置的交换器来实现；</p>
</li>
<li><p>扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点；</p>
</li>
<li><p>高可用性：队列可以在集群中的机器上设置镜像，使得在部分 节点出现问题的情况下队列仍然可用；</p>
</li>
<li><p>多种协议：RabbitMQ除了原生支持AMQP协议，还支持 STOMP、MQTT等多种消息中间件协议；</p>
</li>
<li><p>多语言客户端：RabbitMQ几乎支持所有常用语言，比如Java、 Python、Ruby、PHP、C#、JavaScript等；</p>
</li>
<li><p>管理界面：RabbitMQ提供了一个易用的用户界面，使得用户 可以监控和管理消息、集群中的节点等；</p>
</li>
<li><p>插件机制：RabbitMQ提供了许多插件，以实现从多方面进行 扩展，当然也可以编写自己的插件。</p>
</li>
</ul>
<h2 id="RabbitMQ-核心概念"><a href="#RabbitMQ-核心概念" class="headerlink" title="RabbitMQ 核心概念"></a>RabbitMQ 核心概念</h2><ol>
<li>Publisher：生产者，消息的发送方。</li>
<li>Connection：网络连接。</li>
<li>Channel：信道，多路复用连接中的一条独立的双向数据流通道。</li>
<li>Exchange：交换器（路由器），负责消息的路由到相应队列。</li>
<li>Binding：队列与交换器间的关联绑定。消费者将关注的队列绑定到指定交换器上，以便Exchange能准确分发消息到指定队列。</li>
<li>Queue：队列，消息的缓冲存储区。</li>
<li>Virtual Host：虚拟主机，虚拟主机提供资源的逻辑分组和分离。包含连接，交换，队列，绑定，用户权限，策略等。</li>
<li>Broker：消息队列的服务器实体。</li>
<li>Consumer：消费者，消息的接收方。</li>
</ol>
<h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><p>原始的安装方法有点复杂，现在有一个强大的东西叫Docker， 直接用docker一键安装快速方便。如果不会用docker的话<a href="https://blog.csdn.net/ourstronger/article/category/9344348">请点击这里的教程</a>安装学习。这里就假设已经成功安装了docker.</p>
<p>1.首先来到docker hub首页：<a href="https://hub.docker.com/">https://hub.docker.com</a>  ，搜索RabbitMQ，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-d3df41e9b86c4f08a13dcd987063288e.png" alt="image.png"></p>
<p>找到Management Plugin，复制下列命令:<br><img src="https://www.itmengtao.cn/upload/2020/11/image-e361152089c749ba8dab5a4320b948ff.png" alt="image.png"><br> 然后打开命令框，先开启docker，然后将刚才复制的命令粘进去，此处的 -P 是随机端口，便于测试</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost lemon]# service docker start</span><br><span class="line">Redirecting to /bin/systemctl start docker.service</span><br><span class="line">[root@localhost lemon]# docker run -d --hostname my-rabbit --name some-rabbit -P rabbitmq:3-management</span><br><span class="line">f5eb3c4645a2b844253021210a171143eeadac912f21a8c9d7be0f8371fcad2e</span><br></pre></td></tr></table></figure>
<p>然后看有没有跑起来，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost lemon]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                                                                                                                                                     NAMES</span><br><span class="line">f5eb3c4645a2        rabbitmq:3-management   &quot;docker-entrypoint.s…&quot;   3 minutes ago       Up 3 minutes        0.0.0.0:32773-&gt;4369/tcp, 0.0.0.0:32772-&gt;5671/tcp, 0.0.0.0:32771-&gt;5672/tcp, 0.0.0.0:32770-&gt;15671/tcp, 0.0.0.0:32769-&gt;15672/tcp, 0.0.0.0:32768-&gt;25672/tcp   some-rabbit</span><br></pre></td></tr></table></figure>
<p>这里的15672为管理端口，映射到了32769端口。通信端口为 5672，映射到了32771 端口，浏览器输入：<a href="http://192.168.1.132:32769/">http://192.168.1.132:32769</a></p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-118e3df2f3cf4ac28201598770cd1bbd.png" alt="image.png"></p>
<p> 如果看到上面页面就说明你的rabbitmq已经安装好了，默认用户名密码为：<strong>guest</strong> ，点击登录。如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-1479343afc154b01b368e3628a8a3ce7.png" alt="image.png"></p>
<p>登陆成功页面。 </p>
]]></content>
      <categories>
        <category>Docker | RabbitMQ</category>
      </categories>
      <tags>
        <tag>Docker | RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装MySQL 5.7</title>
    <url>/2020/01/01/Docker%E5%AE%89%E8%A3%85MySQL%205.7-Docker%E5%AE%89%E8%A3%85MySQL%205.7/</url>
    <content><![CDATA[<p>1、拉取mysql镜像，采用网易加速地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull hub.c.163.com/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<p>2、重命名镜像名 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag hub.c.163.com/library/mysql:5.7 mysql:5.7</span><br></pre></td></tr></table></figure>
<p>3、创建容器且安装镜像.启动。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql-main -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-name:容器名称mysql-main</span><br><span class="line">-p：将端口号映射到主机</span><br><span class="line">最后设置密码123456</span><br><span class="line">*如果是云服务器，记得配置安全组设置端口。</span><br></pre></td></tr></table></figure>
<p>4、通过命令进入mysql-main容器 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql-main bash</span><br></pre></td></tr></table></figure>
<p>5、然后进入MySQL。并设置远程的授权等信息。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br><span class="line"></span><br><span class="line">grant all privileges on *.* to root@<span class="string">&quot;%&quot;</span> identified by <span class="string">&quot;123456&quot;</span> with grant option; </span><br><span class="line"></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>6、然后重启mysql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart mysql-main</span><br></pre></td></tr></table></figure>
<p>7、本地连接测试。<br><img src="https://www.itmengtao.cn/upload/2020/11/image-08ea1e89bfbc436d8c0d2d634bc1a88d.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Docker | MySQL</category>
      </categories>
      <tags>
        <tag>Docker | MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka 服务注册与消费（超详细）</title>
    <url>/2020/06/24/Eureka%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B6%88%E8%B4%B9%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89-Eureka%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B6%88%E8%B4%B9%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/</url>
    <content><![CDATA[<h3 id="1-服务注册"><a href="#1-服务注册" class="headerlink" title="1. 服务注册"></a>1. 服务注册</h3><p>服务注册就是把一个微服务注册到 Eureka Server 上，当其它服务需要调用该服务时，只需从 Eureka Server 上查询该服务的信息即可。</p>
<p>下面创建一个 provider，作为服务提供者，创建项目时，选择 Eureka Client 依赖，这样，当服务创建成功后，简单配置一下，就可以被注册到 Eureka Server 上了。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-359116fcf0004ccc8141c34bcd4c6899.png" alt="image.png"></p>
<p>项目创建成功后，只需在 application.properties 中配置一下项目的注册地址即可。注册地址的配置，和 Eureka Server 集群的配置很像。配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.application.name=provider</span><br><span class="line">server.port=1113</span><br><span class="line">eureka.client.service-url.defaultZone=http://127.0.0.1:1111/eureka</span><br></pre></td></tr></table></figure>
<p> 然后启动 Eureka Server ，待服务注册中心启动后，再启动 provider。两者启动成功后，浏览器输入 <a href="http://localhost:1111，就可以看到">http://localhost:1111，就可以看到</a> provider 的注册信息，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-0660e5b4ec934a8889bdd432f1c1fc98.png" alt="image.png"></p>
<h3 id="2-服务消费"><a href="#2-服务消费" class="headerlink" title="2. 服务消费"></a>2. 服务消费</h3><h4 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h4><p>首先提供者创建访问接口，然后创建消费者，消费这个访问接口 (在 provider 中提供一个 hello 接口)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello 你好&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然后，创建一个 consumer 项目，consumer 去消费 provider 提供的接口。consumer 想要获取到 provider 这个接口的地址，他就去 Eureka Server 中查询，如果直接在 consumer 中写死 provider 地址，意味着这两个服务之间的耦合度就太高了，我们要降低耦合度。先看一个写死的调用：</p>
<p>创建一个 consumer 项目，添加 web 和 eureka client 依赖：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-5af7a2caec064d41855d4f944b005de3.png" alt="image.png"></p>
<p> 创建成功后，在 application.properties 中配置一下项目的注册地址。配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.application.name=consumer</span><br><span class="line">server.port=1115</span><br><span class="line">eureka.client.service-url.defaultZone=http://127.0.0.1:1111/eureka</span><br></pre></td></tr></table></figure>
<p>配置完成后，假设我们在 consumer 中调用 provider 提供的服务，我们可以直接将调用写死，就是说，整个调用过程不会涉及到 Eureka Server。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 测试死的地址访问</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/hello1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">hello1</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">       HttpURLConnection con = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://127.0.0.1:1113/hello&quot;</span>);<span class="comment">//这里测试写死provider地址，耦合度太高</span></span><br><span class="line">           con = (HttpURLConnection) url.openConnection();</span><br><span class="line">           <span class="keyword">if</span>(con.getResponseCode() == <span class="number">200</span>)&#123;</span><br><span class="line">               BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(con.getInputStream()));</span><br><span class="line">               String s = bufferedReader.readLine();</span><br><span class="line">               bufferedReader.close();</span><br><span class="line">               <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>浏览器访问如下，调用成功：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-ff0e184455944566ab07e60895354c0c.png" alt="image.png"></p>
<p>这是一段利用了 HttpURLConnection 来发起的请求，请求中的 provider 地址写死了，意味着 provider 和 consumer 高度绑定在一起，耦合度太高。</p>
<h4 id="2-2-消费的接口改造"><a href="#2-2-消费的接口改造" class="headerlink" title="2.2 消费的接口改造"></a>2.2 消费的接口改造</h4><p>要改造它，我们借助 Eureka Client 提供的 DiscoveryClient 工具，根据服务名从 Eureka Server 上查询到一个服务的详细地址，改造后的代码如下：</p>
<pre><code>@Autowired
DiscoveryClient discoveryClient;

@GetMapping(&quot;/hello2&quot;)
public String hello2()&#123;
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(&quot;provider&quot;);
    ServiceInstance serviceInstance = list.get(0);
    String host = serviceInstance.getHost();
    int port = serviceInstance.getPort();
    StringBuffer sb = new StringBuffer();
    sb.append(&quot;http://&quot;)
            .append(host)
            .append(&quot;:&quot;)
            .append(port)
            .append(&quot;/hello&quot;);
    HttpURLConnection connection = null;
try &#123;
            
            URL url = new URL(sb.toString());
            connection = (HttpURLConnection) url.openConnection();

            if (200 == connection.getResponseCode()) &#123;
                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                
                String s = reader.readLine();
                reader.close(); 
                return s;
            &#125;

        &#125; catch (MalformedURLException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
    return &quot;error&quot;;
&#125;
</code></pre>
<p> 重新启动项目，浏览器访问如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-ba7ed87178e74a62acb3b8a92facc93b.png" alt="image.png"></p>
<h4 id="2-3-集群化部署和简单的负载均衡"><a href="#2-3-集群化部署和简单的负载均衡" class="headerlink" title="2.3 集群化部署和简单的负载均衡"></a>2.3 集群化部署和简单的负载均衡</h4><p> DiscoveryClient 查询到的服务列表是一个集合，因为服务在部署的过程中，可能是集群部署，集合中的每一项就是一个实例。</p>
<p>集群化部署：</p>
<ol>
<li>修改 provider 中的 hello 接口【因为要启动多个 provider 实例，多个实例端口则不同，用端口直接区分每个 provider 提供的服务】：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    Integer port;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello 你好&quot;</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
修改完成后，对 provider 进行打包，打包后在 IDEA 命令行启动两个 provider 实例 【集群】：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar provider-0.0.1-SNAPSHOT.jar --server.port=1113</span><br><span class="line">java -jar provider-0.0.1-SNAPSHOT.jar --server.port=1116</span><br></pre></td></tr></table></figure>
启动完成后，访问注册中心看有没有注册上来。然后再去调用 provider ，DiscoveryClient 集合中，获取到的就不是一个实例了，而是两个实例。这里我们可以手动实现一个负载均衡：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">&quot;provider&quot;</span>);</span><br><span class="line">    ServiceInstance serviceInstance = list.get((count++) % list.size());</span><br><span class="line">    String host = serviceInstance.getHost();</span><br><span class="line">    <span class="keyword">int</span> port = serviceInstance.getPort();</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(<span class="string">&quot;http://&quot;</span>)</span><br><span class="line">            .append(host)</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">            .append(port)</span><br><span class="line">            .append(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">    HttpURLConnection connection = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(sb.toString());</span><br><span class="line">            connection = (HttpURLConnection) url.openConnection();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">200</span> == connection.getResponseCode()) &#123;</span><br><span class="line">                BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(connection.getInputStream()));</span><br><span class="line">                String s = reader.readLine();</span><br><span class="line">                reader.close(); </span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 target 文件上右键 open in terminal 分别输入 java -jar provider-0.0.1-SNAPSHOT.jar –server.port=1113 、</li>
</ol>
<p>java -jar provider-0.0.1-SNAPSHOT.jar –server.port=1116 启动两个 provider ，打开 Eureka Server 如下图：已经注册成功。</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/12/image-b8bce99d2f3844d48a2b81e687d0869b.png" alt="image.png"></p>
<p>接着访问 <a href="http://localhost:1115/hello3%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E3%80%90%E5%A4%9A%E6%AC%A1%E8%AE%BF%E9%97%AE%E7%AB%AF%E5%8F%A3%E5%B7%B2%E6%94%B9%E5%8F%98%E3%80%91%EF%BC%8C%E5%B7%B2%E5%AE%9E%E7%8E%B0**%E7%BA%BF%E6%80%A7%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1**%EF%BC%9A">http://localhost:1115/hello3，如下图【多次访问端口已改变】，已实现**线性负载均衡**：</a></p>
<p> <img src="https://www.itmengtao.cn/upload/2020/12/image-e007fdf45e2b4045bea4ebd2faab2b25.png" alt="image.png"></p>
<h4 id="2-4-升级改造"><a href="#2-4-升级改造" class="headerlink" title="2.4 升级改造"></a>2.4 升级改造</h4><p> 主要从两方面动手:</p>
<p><strong>http 调用：spring 提供 RestTemplate<br>负载均衡 ： Ribbon</strong></p>
<p> 2.4.1 http 调用</p>
<p> 用 spring 提供 RestTemplate 来实现，以下提供一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplateOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 将 HttpURLConnection 以及下面的那一段用 RestTemplate 替换，一行代码实现 http 调用，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DiscoveryClient discoveryClient;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;restTemplateOne&quot;)</span></span><br><span class="line">RestTemplate restTemplateOne; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">&quot;provider&quot;</span>);</span><br><span class="line">    ServiceInstance serviceInstance = list.get(<span class="number">0</span>);</span><br><span class="line">    String host = serviceInstance.getHost();</span><br><span class="line">    <span class="keyword">int</span> port = serviceInstance.getPort();</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(<span class="string">&quot;http://&quot;</span>)</span><br><span class="line">            .append(host)</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">            .append(port)</span><br><span class="line">            .append(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">    String s = restTemplateOne.getForObject(sb.toString(), String.class);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.4.2 开启负载均衡 </p>
<p> 使用 Ribbon 来快速实现负载均衡。只需要给 RestTemplate 实例添加一个 @LoadBalanced 注解，开启负载均衡：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span> <span class="comment">//【客户端负载均衡】</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;restTemplate&quot;)</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//restTemplate有负载均衡功能，直接给服务名调用就行</span></span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://provider/hello&quot;</span>,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着访问 <a href="http://localhost:1115/hello3%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:1115/hello3，如下图：</a><br><img src="https://www.itmengtao.cn/upload/2020/12/image-036baf7d0e704066b5f68f279b3477f8.png" alt="image.png"><br> <img src="https://www.itmengtao.cn/upload/2020/12/image-a8c15361f1354e8bbb40de2c79b41c63.png" alt="image.png"></p>
<p> <strong>给 RestTemplate 添加负载均衡的注解也可以理解为 RestTemplate = http 调用 + 负载均衡</strong>。</p>
<p> 项目实例地址：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 关联远程仓库GitHub</title>
    <url>/2019/10/02/Git%20%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93GitHub-Git%20%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93GitHub/</url>
    <content><![CDATA[<h1 id="配置-SSH-KEY"><a href="#配置-SSH-KEY" class="headerlink" title="配置 SSH KEY"></a>配置 SSH KEY</h1><p>SSH KEY 的配置不是必须的，不配置的话我们就只能使用 HTTPS 协议，这样每次提交时要输入用户名密码，所以还是配置一下。配置 SSH KEY 的原理很简单，采用非对称加密方式生成公钥和私钥，公钥告诉 GitHub ，私钥留在自己电脑上(私钥不可泄露)，当我们向 GitHub 上提交数据时，GitHub 会用我们留给它的公钥加密一段消息返回给我们的电脑，如果我们能够用私钥解密成功，说明是合法的用户，这样就避免我们输入用户名密码了。大致的原理就是这样，现在很多免登录的系统都采用了这种方式，比如 Hadoop 免登录配置也是这样。那我们就来看看这个 SSH　KEY 要怎么生成。　　</p>
<h2 id="1-查看本地是否已有-SSHKEY"><a href="#1-查看本地是否已有-SSHKEY" class="headerlink" title="1.查看本地是否已有 SSHKEY"></a>1.查看本地是否已有 SSHKEY</h2><p>查看当前用户目录下是否有 .ssh 文件，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-6bb9742967544cca8de4c716c8728a53.png" alt="image.png"></p>
<p>如果查看之后有结果，则直接跳转到第四步，什么都没有就继续生成。</p>
<h2 id="2-生成-SSH"><a href="#2-生成-SSH" class="headerlink" title="2.生成 SSH"></a>2.生成 SSH</h2><p>命令很简单，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱地址&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-添加-ssh-到-ssh-agent-中"><a href="#3-添加-ssh-到-ssh-agent-中" class="headerlink" title="3.添加 ssh 到 ssh-agent 中"></a>3.添加 ssh 到 ssh-agent 中</h2><p>执行如下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>做好这一切之后，我们当前用户目录(C:\Users\Administrator.ssh)下已经有了一个名为 .ssh 的隐藏文件夹了，打开这个目录，会发现有一个名为 id_rsa.pub 的文件，这就是我们一会要使用的公钥文件。</p>
<h2 id="4-将公钥保存在-GitHub"><a href="#4-将公钥保存在-GitHub" class="headerlink" title="4.将公钥保存在 GitHub"></a>4.将公钥保存在 GitHub</h2><p>登录 GitHub ，点击右上角头像，选择 Settings ，在新打开的页面中左边侧栏选择 <strong>SSH and GPG keys</strong> ，如下： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-0e3f087afcf24c358795c2bf8f7d35f3.png" alt="image.png"></p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-3b21ef00468a4bb88c9042749e651855.png" alt="image.png"></p>
<p>完了之后点击最下面的 Add SSH key 按钮即可，如此之后，我们的 SSH KEY 就配置成功了。 </p>
<h1 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h1><p> 接下来我们在 GitHub 上创建一个仓库，登录成功之后，直接点击右上角绿色的 New repository 按钮，如下： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-10bf0759aacd4bb597ae4b8f0d6d6809.png" alt="image.png"></p>
<p>这里创建了远程 test仓库。 </p>
<h1 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h1><p> 创建成功之后，我们会看到仓库的地址，如下： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-1b584b99ddf44a758e31655bf86e097a.png" alt="image.png"></p>
<p> 然后我需要将我们之前的本地仓库 【(1)test】 和这个远程仓库【(github)test】进行关联，首先进入你本地的原始仓库【(1)test】，然后配置如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://github.com/astronger/test.git</span><br><span class="line"> git 会自动将远程仓库的名字设置为 origin ，方便我们的后续操作。  </span><br></pre></td></tr></table></figure>
<p>穿插一句：如果是本地的文件直接上传到远程仓库，直接下面一套走完即可： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init     <span class="comment">#初始化仓库</span></span><br><span class="line">$ git add .    <span class="comment">#添加到暂存区</span></span><br><span class="line">$ git commit -m <span class="string">&quot;first commit&quot;</span>   <span class="comment">#将当前暂存区的文件提交到本地仓库</span></span><br><span class="line">$ git remote add origin https://github.com/astronger/test.git  <span class="comment">#将我们之前的本地仓库和这个远程仓库进行关联</span></span><br><span class="line">$ git push -u origin master   <span class="comment">#将内容推送到远程 master 分支上</span></span><br></pre></td></tr></table></figure>
<h1 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h1><h2 id="推送到master分支"><a href="#推送到master分支" class="headerlink" title="推送到master分支"></a>推送到master分支</h2><p>假设我想将本地 master 分支上的内容推送到远程 master 分支上，方式如下： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>-u 参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull 命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。这个参数也只用在第一次 push 时加上，以后直接运行 git push 命令即可。  </p>
<h1 id="推送到其他分支"><a href="#推送到其他分支" class="headerlink" title="推送到其他分支"></a>推送到其他分支</h1><p>如果想推送到其他分支，还是这条命令，修改一下分支的名字即可，比如我也想把我的 two 分支推送到远程仓库中，执行如下命令： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-669c0e901c7b48d0945b292fd4acca78.png" alt="image.png"></p>
<p> 先切换到 two 分支，然后执行 git push 命令，参数含义和之前的一样，这里我们创建的远程仓库的分支名也为 two（当然我们可以取任何名字，但是为了不混淆，最好取一致的名字）。这两条命令执行成功之后，此时在网页中我们就可以看到已经有多个分支了，如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-68e40361c8ed45e99dbce277837bf6ea.png" alt="image.png"></p>
<h1 id="从远程仓库获取"><a href="#从远程仓库获取" class="headerlink" title="从远程仓库获取"></a>从远程仓库获取</h1><h2 id="首次获取"><a href="#首次获取" class="headerlink" title="首次获取"></a>首次获取</h2><p>刚刚是我们向远程仓库提交数据，有提交当然就有获取，我们可以通过 git clone 命令克隆一个远程仓库到本地，方式也简单，在本地创建一个空文件夹【(2)test】，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/astronger/test.git</span><br></pre></td></tr></table></figure>
<p>此时克隆的远程仓库的 master 分支到本地仓库【(2)test】，我们可以通过 git branch -a 来查看本地仓库和远程仓库的信息，-a 参数可以同时显示本地仓库和远程仓库的信息，如下： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-5784fd94b4094209ae481d9b24895dc3.png" alt="image.png"></p>
<p>我们看到远程仓库中已经有了 two 分支了，如果我们想把 two 分支也克隆下来，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b two origin/two</span><br></pre></td></tr></table></figure>
<p>表示根据远程仓库的 two 分支创建一个本地仓库的 two 分支，创建完成之后进行切换，也可以通过如下命令只创建不切换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch two origin/two</span><br></pre></td></tr></table></figure>
<p>此时我在 two 分支下修改 test.txt 文件并提交，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-1d1be36cfcb3410298ca888827c2cf23.png" alt="image.png"></p>
<p>注意由于 two 分支就是从远程仓库克隆下来的，所以这里可以不添加 -u 参数。 </p>
<h2 id="从远程仓库更新"><a href="#从远程仓库更新" class="headerlink" title="从远程仓库更新"></a>从远程仓库更新</h2><p>此时我们回到第一次最早的那个 【(1)test】本地仓库中，那个 test 仓库的 two 分支现在和远程仓库不一致了，我们可以通过 git pull 命令来更新，如下： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-05817dc3c3b342e6978e9c492828cd2e.png" alt="image.png"></p>
<p>其它文章：</p>
<p><a href="https://blog.csdn.net/ourstronger/article/details/101028450">Git 基本操作</a><br><a href="https://blog.csdn.net/ourstronger/article/details/101033323">Git 分支管理</a><br><a href="https://blog.csdn.net/ourstronger/article/details/101106544">git stash工作区储藏</a></p>
<p> 参考：<a href="https://www.javaboy.org/2019/0612/git-remote.html">https://www.javaboy.org/2019/0612/git-remote.html</a></p>
]]></content>
      <categories>
        <category>Git | Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 分支管理</title>
    <url>/2019/09/26/Git%20%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-Git%20%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>我们在完成一个项目时，不可能是“单线程”开发的，很多时候任务是并行的，举个栗子：项目2.0版本上线了，现在要着手开发3.0版本，同时2.0版本可能还有一些bug需要修复，这些bug修复之后我们可能还会发2.1，2.2，2.3这些版本，我们不可能等所有bug都修复完了再去开发3.0版本，修复2.0的bug和开发3.0的新功能是两个并行的任务，这个时候我们3.0的功能开发直接在master分支上进行肯定不合适，我们要保证有一个稳定，可以随时发版本的分支存在（一般情况下这个角色由master分支来扮演），此时我们就可以灵活的使用Git中的分支管理功能：</p>
<p>1.创建一个长期分支用来开发3.0功能，假设这个分支的名字就叫v3，我们在v3上添加新功能，并不断测试，当v3稳定后，将v3合并到master分支上。<br>2.创建一个特性分支用来修复2.0的bug，一旦bug修复成功，就将该分支合并到master上，一旦发现新bug，就立马再创建分支进行修复，修复成功之后再合并。</p>
<p>以上两个步骤同步进行，这在Svn中简直是不可想象的，因为Svn的分支管理太low，而Git能够让我们做到随心所欲的创建、合并和删除分支。</p>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>我们可以通过 <strong>git branch</strong> 命令来查看当前仓库有哪些分支，而我们处于哪一个分支中，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-4c3cd948249a46e5b94bfc5d7e444c1c.png" alt="image.png"></p>
<p>这里显示当前仓库只有一个master分支，这是git默认创建出来的，master前面的 * 表示我们当前处于这一个分支中。 </p>
<h2 id="分支创建和切换"><a href="#分支创建和切换" class="headerlink" title="分支创建和切换"></a>分支创建和切换</h2><p>我们可以利用 <strong>git branch &lt;分支名&gt;</strong> 命令来创建一个分支，然后利用 <strong>git checkout &lt;分支名&gt;</strong> 来切换分支，如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-f0988ef9332f4f158b784ecc51d64569.png" alt="image.png"></p>
<p>还可以通过 <strong>git checkout -b &lt;分支名&gt;</strong> 来一步到位，创建并切换分支，如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-5b7aa1d9b28b49edbf184c3a6e94d50f.png" alt="image.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -     <span class="comment"># 切换回上一个分支 </span></span><br></pre></td></tr></table></figure>
<h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>首先切换到four分支中，由于four分支和three分支是从master分支中创建出来的，所以此时four分支、three分支的内容和master分支的内容是一致的，然后我在three分支中向test.txt文件添加一行内容并提交，最终可以看到 three分支中的test.txt和master分支中test.txt的内容就不相同了，具体操作如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-2aa96817841a4c3c9cbbd45faade324e.png" alt="image.png"></p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-f1014b8a0e994d768fa5f7b87ff3de6d.png" alt="image.png"></p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-b7c71eb4666a4152a395e261bbc6c3fa.png" alt="image.png"></p>
<p>上图展示了此时master分支和 three 分支的不同，现在我通过 <strong>git merge –no-ff &lt;分支名&gt;</strong> 命令将 three 分支合并到master分支上。其中—no-ff 表示<strong>强行关闭fast-forward</strong>方式，fast-forward方式表示当条件允许时，git直接把HEAD指针指向合并分支的头，完成合并，这种方式合并速度快，但是在整个过程中没有创建commit，所以如果当我们删除掉这个分支时就再也找不回来了，因此在这里我们将之关闭。</p>
<p>想要合并分支，我们先切换到master分支上，然后执行 <strong>git merge –no-ff three</strong> 命令即可完成分支合并，如下图：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-fd41383e78264c4b85a73300ff850e1f.png" alt="image.png"></p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-748ea82a11cb453fb54a2fa4c630afee.png" alt="image.png"></p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-5dbf61f27eb04f41b3b5c4b4c569d454.png" alt="image.png"></p>
<p>合并成功后，我们看到master分支上的文件中已经有了three分支中更新的内容了。 </p>
<p>git merge 合并分支时如果出现冲突还是先重新编辑冲突文件，编辑完成之后，再执行git add 和git commit即可。</p>
<h2 id="以图表方式查看分支"><a href="#以图表方式查看分支" class="headerlink" title="以图表方式查看分支"></a>以图表方式查看分支</h2><p>通过 <strong>git log –graph</strong> 命令来直观的查看分支的创建和合并等操作，如下图：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-e727635879094d06ab8cc686df4431c6.png" alt="image.png"></p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>大多数情况下我们都是要解决冲突的，解决之后继续提交。</p>
<h2 id="rebase合并"><a href="#rebase合并" class="headerlink" title="rebase合并"></a>rebase合并</h2><p>（1）远程fetch的代码，本地没有修改，直接rebase即可；</p>
<p>（2）若本地对文件修改，没有add，rebase时，会提示“Cannot rebase: You have unstaged changes.Please commit or stash them.”，add后没有commit，会提示“Cannot rebase: Your index contains uncommitted changes.Please commit or stash them.”。commit后，如果没有修改同一文件，rebase不会冲突。</p>
<p>（3）若本地对同一个文件修改，commit后，rebase时，有2种情况：</p>
<p>　　　　① 如果没有修改同一位置，则可以rebase，不会产生冲突；</p>
<p>　　　　② 如果修改了同一处，则rebase时会出现冲突，也不用怕，此时git已经进行了合并，只是没有应用自己的提交，解决办法：修改冲突的文件，然后执行git add xxx和 git rebase –continue操作即可。如果不小心，执行完add后执行了commit，此时本地仓库HEAD处于游离态，如何解决，后续再补充。</p>
<p> merge合并<br>merge合并也可能存在冲突，解决冲突与rebase相似，处理完冲突文件后，重新提交即可。</p>
<h1 id="冲突总结"><a href="#冲突总结" class="headerlink" title="冲突总结"></a>冲突总结</h1><ul>
<li>修改同文件不同处，rebase和merge合并不会冲突</li>
<li>修改同文件同一处，合并会冲突，解决方式：rebase，解决冲突，执行add+rebase continue；merge，解决冲突，重新提交<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2>删除分支命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d &lt;分支名&gt;  <span class="comment">#没事别乱删 </span></span><br></pre></td></tr></table></figure>
<h2 id="退回到之前的状态"><a href="#退回到之前的状态" class="headerlink" title="退回到之前的状态"></a>退回到之前的状态</h2>我们可以通过如下命令来回到之前的状态：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure>
其它文章：</li>
</ul>
<p><a href="https://blog.csdn.net/ourstronger/article/details/101028450">Git 基本操作</a><br><a href="https://blog.csdn.net/ourstronger/article/details/101106544">git stash工作区储藏</a><br><a href="https://blog.csdn.net/ourstronger/article/details/101059246">Git 关联远程仓库GitHub</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 删除已经提交的文件</title>
    <url>/2020/05/05/Git%20%E5%88%A0%E9%99%A4%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6-Git%20%E5%88%A0%E9%99%A4%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>工作中我们可能在上传项目到 github 或者 gitee 时，忘记忽略了某个文件，就直接 push 上去了，最后发现上传多了，如何删除掉远程仓库中的文件呢？</p>
<p>在 github 上我们只能删除仓库，无法删除文件夹或文件，所以只能通过命令来解决：</p>
<p>首先进入你的项目 master 文件夹下， Git Bash Here 打开命令窗口；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin master                    # 将远程仓库里面的项目拉下来</span><br><span class="line"></span><br><span class="line">$ dir                                                # 查看有哪些文件夹【cd 进入想要删除文件的跟目录】</span><br><span class="line"></span><br><span class="line">$ git rm -r --cached edits.html              # 删除文件 edits.html </span><br><span class="line">$ git commit -m &#x27; 删除 edits.html &#x27;        # 提交，添加操作说明</span><br><span class="line"></span><br><span class="line">$ git push -u origin master               # 将本次更改更新到 github 项目上去</span><br></pre></td></tr></table></figure>

<p><img src="https://www.itmengtao.cn/upload/2020/12/image-874e095005f64a198c658bcc45382c71.png" alt="image.png"></p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-ffd0a9318dbe41d0859e0625d4feda45.png" alt="image.png"></p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-270b09b093234ea5ae56f4c9faa7d985.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git 取消远程分支关联，并关联到新的远程分支，将代码推上去</title>
    <url>/2019/12/29/Git%20%E5%8F%96%E6%B6%88%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%85%B3%E8%81%94%EF%BC%8C%E5%B9%B6%E5%85%B3%E8%81%94%E5%88%B0%E6%96%B0%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%EF%BC%8C%E5%B0%86%E4%BB%A3%E7%A0%81%E6%8E%A8%E4%B8%8A%E5%8E%BB-Git%20%E5%8F%96%E6%B6%88%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%85%B3%E8%81%94%EF%BC%8C%E5%B9%B6%E5%85%B3%E8%81%94%E5%88%B0%E6%96%B0%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%EF%BC%8C%E5%B0%86%E4%BB%A3%E7%A0%81%E6%8E%A8%E4%B8%8A%E5%8E%BB/</url>
    <content><![CDATA[<h3 id="在工作中，经常需要将同一份代码传到不同的git仓库中去"><a href="#在工作中，经常需要将同一份代码传到不同的git仓库中去" class="headerlink" title="在工作中，经常需要将同一份代码传到不同的git仓库中去"></a>在工作中，经常需要将同一份代码传到不同的git仓库中去</h3><p>如果本地同样一份代码，已经关联了一个与远程分支，那么怎么才能解除原程分支，并关联到一个新的分支将代码提交到新的分支上去呢？ </p>
<ol>
<li>如果你已经在远程创建了一个分支，远程分支地址：<a href="https://xxxxxxx/xxxx/xxxx.git">https://xxxxxxx/xxxx/xxxx.git</a> </li>
<li>从命令行创建一个新的仓库，关联到该远程分支<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git remote add origin https://xxxxxxx/xxxx/xxxx.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li>
<li>如果本地的代码，没有关联任何远程分支<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://xxxxxxx/xxxx/xxxx.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li>
<li>如果本地代码，已经关联了远程分支，则需要先解除关联<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure></li>
<li>解除后、重新关联新的远程分支，并将代码传上去<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/dev33/alioss-file on  master ⌚ 10:44:56</span><br><span class="line">$ git remote add origin https://xxxxxxx/xxxx/xxxx.git</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/dev33/alioss-file on  master ⌚ 10:45:01</span><br><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 102, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (82/82), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (102/102), 62.52 KiB | 7.81 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 102 (delta 26), reused 0 (delta 0)</span><br><span class="line">To https://xxxxxxx/xxxx/xxxx.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch master from origin.</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>完成</li>
</ol>
<h3 id="还有一种简单粗暴的方法，如果此无需再关联其它分支，只需要将本地文件的-git删除即可。"><a href="#还有一种简单粗暴的方法，如果此无需再关联其它分支，只需要将本地文件的-git删除即可。" class="headerlink" title="还有一种简单粗暴的方法，如果此无需再关联其它分支，只需要将本地文件的.git删除即可。"></a>还有一种简单粗暴的方法，如果此无需再关联其它分支，只需要将本地文件的.git删除即可。</h3><p><img src="https://www.itmengtao.cn/upload/2020/11/image-4f3eb9f42689451691480521cefc3d6e.png" alt="image.png"></p>
<p>删除后继续下面的流程即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init     <span class="comment">#初始化仓库</span></span><br><span class="line">$ git add .    <span class="comment">#添加到暂存区</span></span><br><span class="line">$ git commit -m <span class="string">&quot;first commit&quot;</span>   <span class="comment">#将当前暂存区的文件提交到本地仓库</span></span><br><span class="line">$ git remote add origin https://xxxxxxx/xxxx/xxxx.git  <span class="comment">#将我们之前的本地仓库和这个远程仓库进行关联</span></span><br><span class="line">$ git push -u origin master   <span class="comment">#将内容推送到远程 master 分支上</span></span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/ourstronger/article/details/101059246">https://blog.csdn.net/ourstronger/article/details/101059246</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基本操作</title>
    <url>/2019/09/24/Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Git概念"><a href="#Git概念" class="headerlink" title="Git概念"></a>Git概念</h2><p><img src="https://www.itmengtao.cn/upload/2020/11/image-a3a614ccf7c74a60a3a79626189be4dd.png" alt="image.png"></p>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
<h2 id="Git-与-SVN-区别"><a href="#Git-与-SVN-区别" class="headerlink" title="Git 与 SVN 区别"></a>Git 与 SVN 区别</h2><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p>
<p>如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。</p>
<h3 id="Git-与-SVN-区别点："><a href="#Git-与-SVN-区别点：" class="headerlink" title="Git 与 SVN 区别点："></a>Git 与 SVN 区别点：</h3><ol>
<li><p>Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</p>
</li>
<li><p>Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</p>
</li>
<li><p>Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</p>
</li>
<li><p>Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</p>
</li>
</ol>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-15e75943c93342708efd03822b4befbc.png" alt="image.png"></p>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><ol>
<li>工作区就是我们能看到的工作目录，就是本地的文件夹。</li>
<li>这些本地的文件夹我们要通过git add命令先将他们添加到暂存区中。</li>
<li>git commit命令则可以将暂存区中的文件提交到本地仓库中去。 </li>
</ol>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p>仓库的初始化有两种方式：一种是直接从远程仓库克隆，另一种则是直接从当前目录初始化，这里我们主要介绍当前目录初始化，远程仓库克隆我们在后面的文章中会说到。从当前目录初始化的方式很简单，直接执行如下命令:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>执行完成后当前目录下会多出一个.git的隐藏文件夹，所有git需要的数据和资源都存放在该目录中。</p>
<h2 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h2><p>git status 命令来查看仓库中文件的状态，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-160e4d0b7597426abb49cee9b7cbe927.png" alt="image.png"></p>
<p>结果显示我们当前处于master分支下，然后显示暂时没有东西可以提交，因为当前仓库中还没有记录任何文件的任何状态。此时，我在当前目录下创建一个名为test.txt的文件，然后再执行 git status ，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-844a8304fd3547869200d5be19230f80.png" alt="image.png"></p>
<p>此时结果中显示有一个文件就是我刚刚添加的test.txt，这个表示该文件目前并未被git仓库所管理，所以接下来我们要将这个文件添加到暂存区。 </p>
<h2 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h2><p>使用git add 可以将一个文件添加到暂存区。添加完后，再执行 git status查看结果，文件已经提交到了暂存区。如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-8accbfed9c2d4a0c88bdaf03a35553ce.png" alt="image.png"></p>
<h2 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h2><p> 当文件提交到暂存区之后，此时我们可以使用 git commit 命令将当前暂存区的文件提交到本地仓库，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-113fbae4dcc9487cb8222c02f2273eca.png" alt="image.png"></p>
<p>-m参数是添加的备注，提交成功之后，我们再执行git status命令，结果如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-28ab044017d145fbb0f297e596219cb2.png" alt="image.png"></p>
<p>结果显示没有需要add的东西，也没有需要commit的东西。 </p>
<h2 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h2><p>git log 查看以往仓库中提交的日志，比如提交的版本号、提交者、提交者邮箱、提交时间、提交备注等信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --pretty=short  <span class="comment">#显示简略的信息</span></span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> test.txt   <span class="comment">#如果只想查看某一个文件的提交日志，在git log后面加上文件名即可。</span></span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> -p test.txt  <span class="comment">#如果我还想查看提交时文件的变化，加上-p参数即可(绿色的+表示新增的行，红色的-表示删除的行)</span></span><br><span class="line">$ git reflog    <span class="comment"># 用户重返回来,查看确定的版本，查看命令记录,以及对应的版本号</span></span><br></pre></td></tr></table></figure>
<h2 id="查看更改前后的差异"><a href="#查看更改前后的差异" class="headerlink" title="查看更改前后的差异"></a>查看更改前后的差异</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure>
<p>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。</p>
<ul>
<li>尚未缓存的改动：git diff</li>
<li>查看已缓存的改动： git diff –cached</li>
<li>查看已缓存的与未缓存的所有改动：git diff HEAD</li>
<li>显示摘要而非整个 diff：git diff –stat</li>
</ul>
<p>继续看例子，执行 git diff 命令我们可以查看工作区和暂存区的区别以及工作区和最新提交的差别，在 test.txt 文件中再添加一行hello，此时执行git diff 命令，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-809728264adb4362b6ee1189e5371146.png" alt="image.png"></p>
<p>此时我再执行git add命令，将文件提交到暂存区，然后再执行git diff，如下： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-730aae124ddf4752984db544c0d5966c.png" alt="image.png"></p>
<p>此时工作区的内容和暂存区的内容已经保持一致了。但是此时工作区和本地仓库中最新提交的内容还是不一致，我们可以通过</p>
<p>git diff HEAD 来查看，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-2353d2ae75604e6782503918af3ed75a.png" alt="image.png"></p>
<p>此时我们需要执行git commit命令将暂存区中的文件提交，提交成功之后，就无区别。<br><img src="https://www.itmengtao.cn/upload/2020/11/image-cc4eb8cb3e8249c7af5e00a1ae08e3bb.png" alt="image.png"></p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> rm [文件名]     <span class="comment"># 从缓存区删除文件（add中没有了）</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$git</span> rm [文件]     <span class="comment"># 删除文件，直接rm 文件,那么你还需要add到缓存区再进行提交。这个命令,执行了删除后.直接提交就是了.不用add</span></span><br></pre></td></tr></table></figure>
<p>先说这么多吧…… </p>
<p>其它文章：</p>
<p><a href="https://blog.csdn.net/ourstronger/article/details/101033323">Git 分支管理</a><br><a href="https://blog.csdn.net/ourstronger/article/details/101106544">git stash工作区储藏</a><br><a href="https://blog.csdn.net/ourstronger/article/details/101059246">Git 关联远程仓库GitHub</a><br>参考：<a href="https://git-scm.com/docs">https://git-scm.com/docs</a></p>
<p>   <a href="https://www.runoob.com/git/git-basic-operations.html">https://www.runoob.com/git/git-basic-operations.html</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap的两种取出方式</title>
    <url>/2019/03/27/HashMap%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8F%96%E5%87%BA%E6%96%B9%E5%BC%8F-HashMap%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8F%96%E5%87%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;Student,String&gt; map = <span class="keyword">new</span> HashMap&lt;Student,String&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Kevin&quot;</span>,<span class="number">21</span>),<span class="string">&quot;重庆&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Litch&quot;</span>,<span class="number">21</span>),<span class="string">&quot;四川&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Rocco&quot;</span>,<span class="number">24</span>),<span class="string">&quot;江西&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Lenka&quot;</span>,<span class="number">21</span>),<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        <span class="comment">//----------第一种keySet</span></span><br><span class="line">        Set&lt;Student&gt; set = map.keySet();</span><br><span class="line">        Iterator&lt;Student&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            System.out.println(map.get(it.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//-----------第二种取出方式entrySet</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Student,String&gt;&gt; s = map.entrySet();</span><br><span class="line">        Iterator&lt;Entry&lt;Student, String&gt;&gt; its = s.iterator();</span><br><span class="line">        <span class="keyword">while</span>(its.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Student, String&gt; ma = (Map.Entry&lt;Student, String&gt;)its.next();</span><br><span class="line">            System.out.println(ma.getKey()+<span class="string">&quot;--&quot;</span>+ma.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Hystrix 简单请求合并</title>
    <url>/2020/08/07/Hystrix%20%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6-hystrix%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>频繁的调用provider接太浪费了， 就有了将多个请求合并为一个请求的方式。<br>首先在provider中提供一个请求合并的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**【既可以处理多个，也可以处理单个请求】</span></span><br><span class="line"><span class="comment">    *单个请求的话，List中只有一项数据</span></span><br><span class="line"><span class="comment">    *假设 consumer 传过来的多个id格式是 1,2,3,4....*/</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;ids&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByIds</span><span class="params">(<span class="meta">@PathVariable</span> String ids)</span></span>&#123;</span><br><span class="line">        System.out.println(ids);</span><br><span class="line">        String[] split = ids.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;User&gt; user = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : split)&#123;</span><br><span class="line">            User user1 = <span class="keyword">new</span> User();</span><br><span class="line">            user1.setId(Integer.parseInt(s));</span><br><span class="line">            user.add(user1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Hystrix中定义UserService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsersByIds</span><span class="params">(List&lt;Integer&gt; ids)</span></span>&#123;</span><br><span class="line">        User[] users = restTemplate.getForObject(<span class="string">&quot;http://provider/user/&#123;1&#125;&quot;</span>, User[].class, StringUtils.join(ids, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来定义 UserBatchCommand ，相当于我们之前的 HelloCommand：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBatchCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">List</span>&lt;<span class="title">User</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserBatchCommand</span><span class="params">(List&lt;Integer&gt; ids, UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;batchCmd&quot;</span>)).andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">&quot;batchKey&quot;</span>)));</span><br><span class="line">        <span class="keyword">this</span>.ids = ids;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;User&gt; <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsersByIds(ids);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="一、最后定请求合并方法，【继承方式，做为了解】："><a href="#一、最后定请求合并方法，【继承方式，做为了解】：" class="headerlink" title="一、最后定请求合并方法，【继承方式，做为了解】："></a>一、最后定<strong>请求合并</strong>方法，【继承方式，做为了解】：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCollapseCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCollapser</span>&lt;<span class="title">List</span>&lt;<span class="title">User</span>&gt;, <span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserCollapseCommand</span><span class="params">(UserService userService, Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCollapser.Setter.withCollapserKey(HystrixCollapserKey.Factory.asKey(<span class="string">&quot;UserCollapseCommand&quot;</span>)).andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter().withTimerDelayInMilliseconds(<span class="number">200</span>)));</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRequestArgument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求合并的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> HystrixCommand&lt;List&lt;User&gt;&gt; createCommand(Collection&lt;CollapsedRequest&lt;User, Integer&gt;&gt; collection) &#123;</span><br><span class="line">        List&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;(collection.size());</span><br><span class="line">        <span class="keyword">for</span> (CollapsedRequest&lt;User, Integer&gt; userIntegerCollapsedRequest : collection) &#123;</span><br><span class="line">            ids.add(userIntegerCollapsedRequest.getArgument());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserBatchCommand(ids, userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求结果分发</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> users</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">mapResponseToRequests</span><span class="params">(List&lt;User&gt; users, Collection&lt;CollapsedRequest&lt;User, Integer&gt;&gt; collection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (CollapsedRequest&lt;User, Integer&gt; request : collection) &#123;</span><br><span class="line">            request.setResponse(users.get(count++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后测试调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello5&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello5</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException,InterruptedException</span>&#123;</span><br><span class="line">        HystrixRequestContext ctx = HystrixRequestContext.initializeContext();</span><br><span class="line">        UserCollapseCommand cmd1 = <span class="keyword">new</span> UserCollapseCommand(userService, <span class="number">99</span>);</span><br><span class="line">        UserCollapseCommand cmd2 = <span class="keyword">new</span> UserCollapseCommand(userService, <span class="number">98</span>);</span><br><span class="line">        UserCollapseCommand cmd3 = <span class="keyword">new</span> UserCollapseCommand(userService, <span class="number">97</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;User&gt; q1 = cmd1.queue();</span><br><span class="line">        Future&lt;User&gt; q2 = cmd2.queue();</span><br><span class="line">        Future&lt;User&gt; q3 = cmd3.queue();</span><br><span class="line"></span><br><span class="line">        User u1 = q1.get();</span><br><span class="line">        User u2 = q2.get();</span><br><span class="line">        User u3 = q3.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(u1);</span><br><span class="line">        System.out.println(u2);</span><br><span class="line">        System.out.println(u3);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);<span class="comment">//睡2秒就变成两次请求，</span></span><br><span class="line">        UserCollapseCommand cmd4 = <span class="keyword">new</span> UserCollapseCommand(userService, <span class="number">96</span>);</span><br><span class="line">        Future&lt;User&gt; q4 = cmd4.queue();</span><br><span class="line">        User u4 = q4.get();</span><br><span class="line">        System.out.println(u4);</span><br><span class="line">        ctx.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、通过注解实现请求合并【掌握】："><a href="#二、通过注解实现请求合并【掌握】：" class="headerlink" title="二、通过注解实现请求合并【掌握】："></a>二、通过<strong>注解实现请求合并</strong>【掌握】：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解方式实现请求合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> HystrixCollapse</span></span><br><span class="line"><span class="comment">     *【重要：<span class="doctag">@HystrixCollapser</span> 注解指定批处理方法】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HystrixCollapser(batchMethod = &quot;getUsersByIds&quot;,collapserProperties = &#123;@HystrixProperty(name = &quot;timerDelayInMilliseconds&quot;,value = &quot;200&quot;)&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsersByIds</span><span class="params">(List&lt;Integer&gt; ids)</span></span>&#123;</span><br><span class="line">        User[] users = restTemplate.getForObject(<span class="string">&quot;http://provider/user/&#123;1&#125;&quot;</span>, User[].class, StringUtils.join(ids, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式实现请求合并 测试方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello6&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello6</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();</span><br><span class="line">    Future&lt;User&gt; q1 = userService.getUserById(<span class="number">99</span>);</span><br><span class="line">    Future&lt;User&gt; q2 = userService.getUserById(<span class="number">98</span>);</span><br><span class="line">    Future&lt;User&gt; q3 = userService.getUserById(<span class="number">97</span>);</span><br><span class="line">    User u1 = q1.get();</span><br><span class="line">    User u2 = q2.get();</span><br><span class="line">    User u3 = q3.get();</span><br><span class="line">    System.out.println(u1);</span><br><span class="line">    System.out.println(u2);</span><br><span class="line">    System.out.println(u3);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    Future&lt;User&gt; q4 = userService.getUserById(<span class="number">96</span>);</span><br><span class="line">    User u4 = q4.get();</span><br><span class="line">    System.out.println(u4);</span><br><span class="line">    ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结 ：@HystrixCollapser(batchMethod = “getUserByIds”,collapserProperties = {@HystrixProperty(name = “timerDelayInMilliseconds”,value = “200”)})  </p>
<p>@HystrixCommand</p>
<p>代码地址：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a> </p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix 请求命令 &amp; 异常处理</title>
    <url>/2020/08/07/Hystrix%20%E8%AF%B7%E6%B1%82%E5%91%BD%E4%BB%A4%20&amp;%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-hystrix%E8%AF%B7%E6%B1%82%E5%91%BD%E4%BB%A4%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="1-请求命令"><a href="#1-请求命令" class="headerlink" title="1.请求命令"></a>1.请求命令</h3><p>请求命令就是以继承类的方式来代替前面的注解方式。</p>
<p>接着上文，首先定义一个helloCommand：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloCommand</span><span class="params">(Setter setter,RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String类型为上面定义的泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://provider/hello&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloCommand helloCommand = <span class="keyword">new</span> HelloCommand(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;hellojava&quot;</span>)), restTemplate);</span><br><span class="line">        <span class="comment">/** 两种调用方法</span></span><br><span class="line"><span class="comment">         *  一、直接调用【同步】</span></span><br><span class="line"><span class="comment">         *  【注意：HelloCommand new出来之后只能调用一次，两种方法只执行一次】</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        String execute = helloCommand.execute();</span><br><span class="line">        System.out.println(execute);</span><br><span class="line">        HelloCommand helloCommand2 = <span class="keyword">new</span> HelloCommand(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;hellojava&quot;</span>)), restTemplate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 二、先入队，后执行 【异步】*/</span></span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;String&gt; queue = helloCommand2.queue();</span><br><span class="line">            s = queue.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 启动eureka server和provider以及hystrix ，访问<a href="http://localhost:3000/hello2">http://localhost:3000/hello2</a> 在控制台查看结果。</p>
<h4 id="1-1通过注解实现请求异步调用"><a href="#1-1通过注解实现请求异步调用" class="headerlink" title="1.1通过注解实现请求异步调用"></a>1.1通过注解实现请求异步调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;error&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">hello2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;String&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://provider/hello&quot;</span>,String.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Future&lt;String&gt; stringFuture = helloService.hello2();</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = stringFuture.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 重启hystrix项目，访问：<a href="http://localhost:3000/hello3">http://localhost:3000/hello3</a> 如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-9db745274cb74fdd9893be94b94b5934.png" alt="image.png"></p>
<h4 id="1-2通过继承方式使用Hystrix，-重写继承类的-getFallback-方法实现服务容错-降级。"><a href="#1-2通过继承方式使用Hystrix，-重写继承类的-getFallback-方法实现服务容错-降级。" class="headerlink" title="1.2通过继承方式使用Hystrix， 重写继承类的 getFallback 方法实现服务容错/降级。"></a>1.2通过继承方式使用Hystrix， 重写继承类的 getFallback 方法实现服务容错/降级。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloCommand</span><span class="params">(Setter setter,RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://provider/hello&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求失败的回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error-extends&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启hystrix项目 访问hello2接口。(启动2个provider，都注册到eureka,，再关闭一个，刷新才能看到效果，与一开始的注解式方式相似)</p>
<h3 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2.异常处理"></a>2.异常处理</h3><p> 就是当发起服务时，如果不是provider的原因导致请求调用失败，而是 consumer 中本身代码有问题导致的请求失败，即 consumer中抛出了异常，这个时候，也会自动进行服务降级，只不过这个时候降级，我们还需要知道到底哪里出错了。</p>
<p>如下例实例代码，如果hello方法执行时抛出异常，那么一样会进行服务降级，进入到 error 方法中，然后获取到异常的详细及信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在这个方法中，将发起一个远程调用，去调用provider中提供的 /hello接口</span></span><br><span class="line"><span class="comment">     * 但是调用这个方法可能会失败，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以在方法上面添加 <span class="doctag">@HystrixCommand</span> ，配置fallbackMethod 属性，这个属性表示该方法调用失败时的临时替代方法</span></span><br><span class="line"><span class="comment">     * 【专业术语：服务降级】 */</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;error&quot;)</span><span class="comment">//如果希望直接抛出异常，不做服务降级 。则再加上ignoreExceptions配置(fallbackMethod = &quot;error&quot;,ignoreExceptions = ArithmeticException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://provider/hello&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法名要和 fallbackMethod一致</span></span><br><span class="line"><span class="comment">     * 方法返回值也要一致 【比如这里都是String类型，error也要一致】</span></span><br><span class="line"><span class="comment">     * 此处 调用 备案方案 ，比如数据库崩了，就要去查缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * *    **下面也可以继续写HystrixCommand调用error2 ，然后error2再去调用其它的方法，方法一样，依次往下，这就是【服务降级】</span></span><br><span class="line"><span class="comment">     * *    **越往下，数据的获取能力越来越容易，准确性可能降低，但不会让系统挂掉。</span></span><br><span class="line"><span class="comment">     * *    ** 这就是Hystrix 的作用： 1. 降级  2. 容错。  避免雪崩  。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@HystrixCommand(fallbackMethod = &quot;error2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">(Throwable t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>+t.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是注解的方式，也可以通过继承的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloCommand</span><span class="params">(Setter setter,RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String类型为上面定义的泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;<span class="comment">//测试异常</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://provider/hello&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求失败的回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error-extends&quot;</span>+getFailedExecutionException().getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是通过继承的方式来做 Hystrix ，在getFallback 方法中，我们可以通过 getExecutionException 方法来获取执行的异常信息。</p>
<p>另一种可能性。如果抛出异常了，我们希望异常直接抛出，不要服务降级，那么只需要配置忽略某一个异常即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;<span class="comment">//测试异常</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://provider/hello&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码示例地址：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a> </p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix的简单介绍与使用</title>
    <url>/2020/07/08/Hystrix%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8-hystrix%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Hystrix 是 Netflix 针对微服务分布式系统采用的熔断保护中间件，相当于电路中的保险丝。</p>
<p>在分布式环境中，许多服务依赖项中的一些必然会失败。Hystrix 是一个库，通过添加延迟容忍和容错逻辑，帮助你控制这些分布式服务之间的交互。Hystrix 通过隔离服务之间的访问点、停止级联失败和提供回退选项来实现这一点，所有这些都可以提高系统的整体弹性。</p>
<p>在微服务架构下，很多服务都相互依赖，如果不能对依赖的服务进行隔离，那么服务本身也有可能发生故障，Hystrix 通过 HystrixCommand 对调用进行隔离，这样可以阻止故障的连锁效应，能够让接口调用快速失败并迅速恢复正常，或者回退并优雅降级。</p>
<p>Hystrix 的简单使用 </p>
<p>首先创建一个Spring Boot 模块，然后添加如下依赖：</p>
<p> 创建成功后，添加如下配置，将Hystrix 注册到 Eureka 上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=hystrix</span><br><span class="line">server.port=3000</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:1111/eureka</span><br></pre></td></tr></table></figure>

<p>然后在项目启动类上添加如下注解，开启断路器，同时提供一个RestTemplate ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringBootApplication</span></span><br><span class="line"><span class="comment">//@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span> <span class="comment">//【组合注解】@SpringCloudApplication = @SpringBootApplication + @EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来提供Hystrix 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在这个方法中，将发起一个远程调用，去调用provider中提供的 /hello接口</span></span><br><span class="line"><span class="comment">     * 但是调用这个方法可能会失败，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以在方法上面添加 <span class="doctag">@HystrixCommand</span> ，配置fallbackMethod 属性，这个属性表示该方法调用失败时的临时替代方法</span></span><br><span class="line"><span class="comment">     * 【专业术语：服务降级】 */</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;error&quot;)</span><span class="comment">//如果希望直接抛出异常，不做服务降级 。则再加上ignoreExceptions配置(fallbackMethod = &quot;error&quot;,ignoreExceptions = ArithmeticException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://provider/hello&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法名要和 fallbackMethod一致</span></span><br><span class="line"><span class="comment">     * 方法返回值也要一致 【比如这里都是String类型，error也要一致】</span></span><br><span class="line"><span class="comment">     * 此处 调用 备案方案 ，比如数据库崩了，就要去查缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * **下面也可以继续写HystrixCommand调用error2 ，然后error2再去调用其它的方法，方法一样，依次往下，这就是【服务降级】</span></span><br><span class="line"><span class="comment">     * **越往下，数据的获取能力越来越容易，准确性可能降低，但不会让系统挂掉。</span></span><br><span class="line"><span class="comment">     * **这就是Hystrix 的作用： 1. 降级  2. 容错。  避免雪崩  。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@HystrixCommand(fallbackMethod = &quot;error2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 启动Eureka 服务，启动两个provider实例(打两个包)，启动一个consumer，访问consumer 去调用两个provider接口(负载均衡方式)，访问成功之后然后突然关闭一个provider服务，再去刷新请求consumer，会有短时间的报错。（原因是一个provider掉线，它自己要把掉线的消息告诉Eureka，Eureka再把provider掉线的消息告诉consumer，在这个过程中肯定是有延迟的，在consumer没收到provider掉线的消息之前就有可能会去访问已经掉线的provider，这时就会有异常抛出。Hystrix在这里其实就是解决很短时间内的问题，consumer访问掉线的provider时不让弹出错误页面就行）</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA 中java文件右下角红色J的解决方法</title>
    <url>/2019/06/05/IDEA%20%E4%B8%ADjava%E6%96%87%E4%BB%B6%E5%8F%B3%E4%B8%8B%E8%A7%92%E7%BA%A2%E8%89%B2J%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-IDEA%20%E4%B8%ADjava%E6%96%87%E4%BB%B6%E5%8F%B3%E4%B8%8B%E8%A7%92%E7%BA%A2%E8%89%B2J%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>此处的意思是不可编译，点击 File——&gt; project structure——&gt;Modules，</p>
<p>点击如下图的Sources，把右边第一个路径X掉，去掉Root路径后，重新添加即可成功。<br><img src="https://www.itmengtao.cn/upload/2020/10/image-49c6bfd14c324ac4b33caa720b83407b.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA 设置方法自动显示参数提示功能</title>
    <url>/2020/02/24/IDEA%20%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA%E5%8F%82%E6%95%B0%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD-IDEA%20%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA%E5%8F%82%E6%95%B0%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>在写注解的时候，IDEA 如下图所示，没有提示，需要手动输入才行，比较浪费时间。 </p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-324fa333f5fc4bc183bdeec078f6d652.png" alt="image.png"></p>
<p><strong>解决方法</strong>：</p>
<p> 点击 File——&gt;Setting——&gt; 点击 Editor——&gt;General——&gt;Code Completion，如下图：</p>
<p>去掉 Match case 前的对勾，点击保存即可。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-445b1d78b91746548fc2df0ce31ddc95.png" alt="image.png"></p>
<p>测试如下图，输入小写即可提示：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-cf96773a52fa4cf9bb4b1bdfd365b86b.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA解决 Could not Autowired,No Beans of &#39;Mapper&#39; type found 报错</title>
    <url>/2019/11/13/IDEA%E8%A7%A3%E5%86%B3%20Could%20not%20Autowired,No%20Beans%20of%20&#39;Mapper&#39;%20type%20found%20%E6%8A%A5%E9%94%99-IDEA%E8%A7%A3%E5%86%B3%20Could%20not%20Autowired,No%20Beans%20of%20&#39;Mapper&#39;%20type%20found%20%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>错误如下，网上大多数的说法都是要求我们把这个提示功能关闭，解决如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-a28205b1c5914d3b99abffd34279d4d1.png" alt="image.png"></p>
<ol>
<li><p>在mapper文件上加 <strong>@Repository</strong> 注解，这是从spring2.0新增的一个注解，用于简化 Spring 的开发，实现数据访问</p>
</li>
<li><p>在mapper文件上加 <strong>@Component</strong> 注解，把普通pojo实例化到spring容器中，相当于配置文件中的 &lt; bean id=”” class=””/&gt;</p>
</li>
</ol>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Illegal invocation 解决方法</title>
    <url>/2020/05/06/Illegal%20invocation%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-Illegal%20invocation%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>使用 ajax 传送数据时，出现如下图错误情况： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-1fb788aac69e423c8c770cb0e9c54a44.png" alt="image.png"></p>
<p>我的 ajax 代码如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-f653e516f33e4a87a456e1f7da7d6500.png" alt="image.png"></p>
<p>解决方法如下：<br>因为此处使用 formData ，所以需要增加两个参数：</p>
<p><strong>contentType : false,<br>processData : false,</strong></p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-65bb7e9de1754470821c6ad6ae41adfd.png" alt="image.png"></p>
<p>重新启动，问题解决！</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>JSONArray、JSONObject删除指定键值对</title>
    <url>/2019/03/11/JSONArray%E3%80%81JSONObject%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E9%94%AE%E5%80%BC%E5%AF%B9-JSONArray%E3%80%81JSONObject%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E9%94%AE%E5%80%BC%E5%AF%B9/</url>
    <content><![CDATA[<p>笔记补录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">net.sf.json.JSONArray和net.sf.json.JSONObject的删除指定键值对的方法</span><br><span class="line"></span><br><span class="line">json数组删除指点的对象：</span><br><span class="line"></span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject(list);</span><br><span class="line">JSONArray jsonArray2 = jsonArray.discard(0);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">json对象删除指定的键：</span><br><span class="line"></span><br><span class="line">JSONObject jsonObject = JSONObject.fromObject(map);</span><br><span class="line">JSONObject jsonObject2 = jsonObject.discard(&quot;name1&quot;); //name1为指定的键。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">json数据删除对象里指点的键：</span><br><span class="line"></span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject(list);</span><br><span class="line"></span><br><span class="line">JSONArray jsonArray1 = new JSONArray();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; jsonArray.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">JSONObject jsonObject = (JSONObject) jsonArray.get(i);</span><br><span class="line"></span><br><span class="line">JSONObject jsonObject2 = jsonObject.discard(&quot;name1&quot;);</span><br><span class="line"></span><br><span class="line">jsonArray1.add(jsonObject2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JSP中的EL表达式使用大于小于等符号</title>
    <url>/2019/07/07/JSP%E4%B8%AD%E7%9A%84EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%A4%A7%E4%BA%8E%E5%B0%8F%E4%BA%8E%E7%AD%89%E7%AC%A6%E5%8F%B7-JSP%E4%B8%AD%E7%9A%84EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%A4%A7%E4%BA%8E%E5%B0%8F%E4%BA%8E%E7%AD%89%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<p><img src="https://www.itmengtao.cn/upload/2020/11/image-da6986b2dc8b4dc296538f9fa465069c.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Jsp</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 加密、解密PDF文档</title>
    <url>/2020/01/05/Java%20%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86PDF%E6%96%87%E6%A1%A3-Java%20%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86PDF%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>本篇文章将介绍通过Java来设置PDF文档保护的方法。我们可以设置仅用于查阅文档的密码，即该通过该密码打开文档仅用于文档阅读，无法编辑；也可以设置文档编辑权限的密码，即通过该密码打开文档时，文档为可编辑状态。</p>
<p>使用工具<a href="https://www.e-iceblue.cn/Downloads/Free-Spire-PDF-JAVA.html">Free Spire.PDF for Java V2.0.0</a>：（免费版）</p>
<p>首先，在pom.xml文件中配置Maven仓库路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>com.e-iceblue<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>e-iceblue<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.e-iceblue.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入免费版本（免费版有页数限制，不能超出10页）： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spire.pdf.free&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p> 1】加密PDF文档</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">import java.util.EnumSet;</span><br><span class="line">import com.spire.pdf.PdfDocument;</span><br><span class="line">import com.spire.pdf.security.PdfEncryptionKeySize;</span><br><span class="line">import com.spire.pdf.security.PdfPermissionsFlags;</span><br><span class="line"></span><br><span class="line">public class EncryptPDF &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        //创建PdfDocument实例</span><br><span class="line">        PdfDocument doc = new PdfDocument();</span><br><span class="line">        //加载PDF文件</span><br><span class="line">        doc.loadFromFile(&quot;sample.pdf&quot;);</span><br><span class="line"></span><br><span class="line">        //加密PDF文件</span><br><span class="line">        PdfEncryptionKeySize keySize = PdfEncryptionKeySize.Key_128_Bit;</span><br><span class="line">        String openPassword = &quot;123456&quot;;//打开文档时，仅用于查看文档</span><br><span class="line">        String permissionPassword = &quot;test&quot;;//打开文档时，可编辑文档</span><br><span class="line">        EnumSet flags = EnumSet.of(PdfPermissionsFlags.Print, PdfPermissionsFlags.Fill_Fields);</span><br><span class="line">        doc.getSecurity().encrypt(openPassword, permissionPassword, flags, keySize);</span><br><span class="line"></span><br><span class="line">        //保存文件</span><br><span class="line">        doc.saveToFile(&quot;Encrypt.pdf&quot;);</span><br><span class="line">        doc.close();             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，生成文档。打开文档时，输入密码，可查看文档加密的具体情况。如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-5c8c64861ac44be980b9a3ca9855126f.png" alt="image.png"></p>
<p>注意：如果不想给某项加密的话只需给个空值就行。</p>
<p>2】解除PDF密码保护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.spire.pdf.PdfDocument;</span><br><span class="line">import com.spire.pdf.security.PdfEncryptionKeySize;</span><br><span class="line">import com.spire.pdf.security.PdfPermissionsFlags;</span><br><span class="line"></span><br><span class="line">public class DecryptPDF &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        //创建PdfDocument实例</span><br><span class="line">        PdfDocument doc = new PdfDocument();</span><br><span class="line">        //加载带密码保护的PDF文件</span><br><span class="line">        doc.loadFromFile(&quot;Encrypt.pdf&quot;, &quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">        //解除文档中的密码保护</span><br><span class="line">        doc.getSecurity().encrypt(&quot;&quot;, &quot;&quot;, PdfPermissionsFlags.getDefaultPermissions(), PdfEncryptionKeySize.Key_256_Bit, &quot;test&quot;);</span><br><span class="line">        </span><br><span class="line">        //保存文件</span><br><span class="line">        doc.saveToFile(&quot;Decrypt.pdf&quot;);</span><br><span class="line">        doc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序后，生成的文档将不再受密码保护。</p>
<p>参考：<a href="https://www.cnblogs.com/Yesi/p/10244405.html">https://www.cnblogs.com/Yesi/p/10244405.html</a></p>
]]></content>
      <categories>
        <category>Spring Boot | java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 快速安装 Prometheus</title>
    <url>/2020/08/11/Linux%20%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%20Prometheus-linux%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85prometheus/</url>
    <content><![CDATA[<p>安装：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载Prometheus</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">wget</span> https://github.com/prometheus/prometheus/releases/download/v2.<span class="number">16.0</span>/prometheus<span class="literal">-2</span>.<span class="number">16.0</span>.linux<span class="literal">-amd64</span>.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar <span class="literal">-zxvf</span> prometheus<span class="literal">-2</span>.<span class="number">16.0</span>.linux<span class="literal">-amd64</span>.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解压完成后，配置一下数据路径和要监控的服务地址：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> prometheus<span class="literal">-2</span>.<span class="number">16.0</span>.linux<span class="literal">-amd64</span>/</span><br><span class="line"></span><br><span class="line">vi prometheus.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改 prometheus.yml 文件住要改两个地方，一个是数据接口，一个是服务地址：<br><img src="https://img-blog.csdnimg.cn/20201116104523265.png#pic_center" alt="在这里插入图片描述"><br>然后启动 Prometheus 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./prometheus --config.file=prometheus.yml</span><br></pre></td></tr></table></figure>

<p>启动成功后，<strong>结合这篇文章</strong>，浏览器输入 <a href="http://192.168.1.132:9090/graph">http://192.168.1.132:9090/graph</a>，查看 Prometheus 数据信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20201116114410815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 用命令安装 jar 包到本地仓库</title>
    <url>/2020/02/28/Maven%20%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%20jar%20%E5%8C%85%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93-Maven%20%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%20jar%20%E5%8C%85%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>如果 pom 文件中 maven 无法引用中央仓库的 jar，或者是想把自己生成的 jar 包放到的 Maven 仓库中时，可以使用 Maven install 命令来安装到本地仓库。</p>
<h3 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h3><p>此处假设你已经安装 maven，并且配置 OK.</p>
<ol>
<li>将需要安装的 jar 包放入到固定位置，我这里假设放到 D 盘。</li>
</ol>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-8d2e6a3dabe94e3e98f29847a5947e15.png" alt="image.png"></p>
<ol start="2">
<li>打开命令行，输入如下命令</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=jar包的位置 -DgroupId=groupId名称 -DartifactId=artifactId名称 -Dversion=版本号 -Dpackaging=jar </span><br></pre></td></tr></table></figure>
<p>示例如下，图中红色标记位置依次对应上述的公式中的位置：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-ba9339c1f0b0434bbfc815f917899ebd.png" alt="image.png"></p>
<ol start="3">
<li>安装完成后，打开 Maven 仓库，根据 groupId 查找刚才安装的 jar 包  </li>
</ol>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-6018c646786f44c8954b807554c013bc.png" alt="image.png"></p>
<ol start="4">
<li>打开图中的 pom 文件，将内容复制到项目中的 pom 文件即可。</li>
</ol>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-0c262d41266a4f99829e97f98b61c1fd.png" alt="image.png"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.icepdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>icepdf-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis 中配置主键回填</title>
    <url>/2020/02/22/MyBatis%20%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%B8%BB%E9%94%AE%E5%9B%9E%E5%A1%AB-MyBatis%20%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%B8%BB%E9%94%AE%E5%9B%9E%E5%A1%AB/</url>
    <content><![CDATA[<p>主键回填是一个很常见的需求，我们经常需要添加完数据之后，需要获取刚刚添加的数据 id，数据库主键回填在 MyBatis 中的简单实现如下：</p>
<p>useGeneratedKeys 设置为 true，keyProperty 为要回填的属性名。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-2b1ba182a78e484e885bff2cedc351e2.png" alt="image.png"></p>
<p>当插入完成后，这个对象的 id 就会被自动赋值，值就是刚刚插入成功的 id。 </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 连接查询汇总（极简）</title>
    <url>/2019/03/03/MySQL%20%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E6%B1%87%E6%80%BB%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89-MySQL%20%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E6%B1%87%E6%80%BB%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89/</url>
    <content><![CDATA[<p>MYSQL-连接查询：<br>    # 连接查询:把多张表进行记录的连接(按照某个条件进行数据的拼接)<br>    # 分类<br>        1,内链接<br>        2,外连接<br>            # 左外<br>            # 右外<br>        3,自然连接<br>        4,交叉连接</p>
<p>MYSQL-内链接 :<br>    # inner join (inner关键字可以省略)  [inner join比left join快]<br>    # 从左表中取出每一条记录,与右表中的所有记录进行匹配<br>    # 匹配必须是某个条件,在左表和右表中相同【公共部分】,才会保留结果.否则,不保留<br>    # 基本语法<br>        SELECT * FROM [左表] innder join [右表] on [左表].[字段]=[右表].[字段];<br>    # 内连接,可以没有on,那么系统会保留所有的结果,没错.又是传说中的笛卡尔积<br>    # ‘还可以使用where代替on,但是效率没有on高’</p>
<p>例子：<br>排他性: A,B表中至少有1个匹配时，才返回行。两表的【交集】<br>SQL语句如下：<br>select A.name,B.address from A<br>inner join B<br>on A.id = B.A_id</p>
<p>查询结果为：<br>name     address<br>张     北京<br>王     上海</p>
<p>inner join  内连接等价于下面的sql:<br>SELECT A.name, B.address<br>FROM A, B<br>WHERE A.id = B.A_id</p>
<p>MYSQL-外连接:<br>1, 左外<br>   左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。</p>
<p>【通俗：就是2张表，查左表满足条件的所有以及右表中含有左表条件的数据，where (右表条件)..is not null显示不为null的数】<br>    # 以某张表为主,取出里面的所有记录.每条与另外一张表.不管能不能匹配上条件.最终都会保留.如果不能匹配,那么其他表的字段都置空</p>
<pre><code>    # left join (left join 是left outer join的简写)
    # 基本语法
        SELECT
            ...
        FROM
            [左表]
        LEFT JOIN
            [右表]
        ON
            [条件]
    # 会把左边所有的数据都显示出来,如果右表没有匹配的数据.以null显示
   例：SELECT * from a_table a LEFT  JOIN b_table b on a.a_id = b.b_id (where b_id is not NULL);

2,右外
右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行
</code></pre>
<p>   【通俗：就是2张表，查右表满足条件的所有以及左表中含有右表条件的数据，where (左表条件)..is not null显示不为null的数】</p>
<pre><code>    # right join
    # 基本语法
        SELECT
            ...
        FROM
            [左表]
        RIGHT JOIN
            [右表]
        ON
            [条件]
    # 会把右表所有的数据都显示出来,如果左表没有匹配的数据.以null显示
    例：SELECT * from a_table a RIGHT JOIN b_table b on a.a_id = b.b_id (where a_id is not NULL);
</code></pre>
<p>MYSQL-自然连接：<br>    # natural join<br>    # MYSQL方言,其他数据库不一定有<br>    # ‘自动的匹配连接条件’,但是.不怎么建议使用.是以’字段名称作为匹配模式’<br>    # 基本语法<br>        SELECT …FROM [表1] natural join [表2];        //内连接<br>            * 自动使用同名字段作为连接条件,结果中会合并该字段<br>        SELECT …FROM [表1] left natural join [表2];    //左外自然连接<br>        SELECT …FROM [表1] right natural join [表2];    //右外自然连接</p>
<p>MYSQL-交叉连接：<br>    # cross join<br>    # 从一张表中循环取出每一条记录,每条记录都去另外一张表进行匹配.而且匹配一定保留(没有条件匹配不带条件where…)<br>    # 而连接本身字段就会增加(保留)    –    笛卡尔积(笛卡尔是没有意义的,【尽量要避免】)<br>    # 存在的价值:保证连接这种结构的完整性而已.<br>    # 基本语法<br>        SELECT * from [左表] cross join [右表];    == select * from [左表],[右表];<br>        select * from emp cross join dept;</p>
<pre><code>    # 也可以加上条件
    select * 
        from emp e 
    cross join 
        dept d 
    on e.deptno=d.deptno ;
【两表连接如果要避免返回笛卡尔积，必须确保至少一方表是唯一的，否则在能查到记录的情况下，不论哪一种连接方式一定会返回笛卡尔积记录集的。】
</code></pre>
<p>MYSQL-全外：<br>    # 全外(MYSQL不支持,但是我们可以通过其他方式实现)<br>    # 这个就是,左右两表都是相同的,两个表的所有内容都必须全部出来,如果没有对应记录的,就用null填充</p>
<pre><code>select * from 表1 left outer join 表2 on 表1.字段=表2.字段
    union 
select * from 表1 right outer join 表2 on 表1.字段=表2.字段;
-联合查询 ,把他们的结果集合并一下就出来了

例: SELECT * from a_table a LEFT  JOIN b_table b on a.a_id = b.b_id (where b_id is not NULL) UNION SELECT * from a_table a
</code></pre>
<p>LEFT  JOIN b_table b on a.a_id = b.b_id (where b_id is not NULL);</p>
<p>例子：<a href="https://blog.csdn.net/plg17/article/details/78758593">https://blog.csdn.net/plg17/article/details/78758593</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 之 xml 中日期时间段查询的 sql 语句</title>
    <url>/2020/04/30/Mybatis%20%E4%B9%8B%20xml%20%E4%B8%AD%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%AE%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%20sql%20%E8%AF%AD%E5%8F%A5-Mybatis%20%E4%B9%8B%20xml%20%E4%B8%AD%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%AE%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%20sql%20%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>&lt; if test=”startDate!=null and startDate!=’’” &gt; and CREATEDATE &gt;=#{startDate} &lt; /if&gt;<br>&lt; if test=”endDate!=null and endDate!=’’” &gt; and CREATEDATE &lt;=#{endDate}&lt; /if&gt;</p>
<p>日期字段存入数据库都是字符串，不是 date 型，xml 中 &gt;,&lt; 不能被正确解析，所以需要 XML 转义字符。</p>
]]></content>
      <categories>
        <category>Spring Boot | java</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx 入门教程（极简）</title>
    <url>/2019/06/03/Nginx%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89-Nginx%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Nginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。</p>
<p>Nginx 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。</p>
<p>Nginx 特点是占有内存少，并发能力强。</p>
<p>事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了 Nginx ，我们的项目架构可能是这样：<br><img src="https://www.itmengtao.cn/upload/2020/10/image-2a7f4515343b424987b4dfe885f02285.png" alt="image.png"></p>
<p>在这样的架构中 ， Nginx 所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达 Nginx 上，再由 Nginx 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 Tomcat 上去。</p>
<p>那么这里涉及到两个概念：</p>
<h4 id="1-负载均衡服务器"><a href="#1-负载均衡服务器" class="headerlink" title="1. 负载均衡服务器"></a>1. 负载均衡服务器</h4><p>就是进行请求转发，降低某一个服务器的压力。负载均衡策略很多，也有很多层，对于一些大型网站基本上从 DNS 就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 F5 和 Nginx （目前 Nginx 已经被 F5 收购），早些年，也可以使用 Apache 来做负载均衡，但是效率不如 Nginx ，所以现在主流方案是 Nginx 。</p>
<h4 id="2-反向代理服务器"><a href="#2-反向代理服务器" class="headerlink" title="2. 反向代理服务器"></a>2. 反向代理服务器</h4><p>另一个概念是反向代理服务器，得先说正向代理，看下面一张图：<br><img src="https://www.itmengtao.cn/upload/2020/10/image-1418b3cdd1da40d3a16bbc182cfacfc9.png" alt="image.png"></p>
<p>在这个过程中，Google 并不知道真正访问它的客户端是谁，它只知道这个中间服务器在访问它。因此，这里的代理，实际上是中间服务器代理了客户端，这种代理叫做正向代理。</p>
<p>那么什么是反向代理呢？看下面一张图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-dfbf136b638f4da49271a6c800d2413c.png" alt="image.png"></p>
<p>所有的请求打到 10086 上，再由 10086 将请求转发给某一个话务员去处理。因此，在这里，10086 就相当于是一个代理，只不过它代理的是话务员而不是客户端，这种代理称之为反向代理。</p>
<h2 id="Nginx-的优势"><a href="#Nginx-的优势" class="headerlink" title="Nginx 的优势"></a>Nginx 的优势</h2><p>在 Java 开发中，Nginx 有着非常广泛的使用，随便举几点：</p>
<ol>
<li>使用 Nginx 做静态资源服务器：Java 中的资源可以分为动态和静态，动态需要经过 Tomcat 解析之后，才能返回给浏览器，例如 JSP 页面、Freemarker 页面、控制器返回的 JSON 数据等，都算作动态资源，动态资源经过了 Tomcat 处理，速度必然降低。对于静态资源，例如图片、HTML、JS、CSS 等资源，这种资源可以不必经过 Tomcat 解析，当客户端请求这些资源时，之间将资源返回给客户端就行了。此时，可以使用 Nginx 搭建静态资源服务器，将静态资源直接返回给客户端。</li>
<li>使用 Nginx 做负载均衡服务器，无论是使用 Dubbo 还是 Spirng Cloud ，除了使用各自自带的负载均衡策略之外，也都可以使用 Nginx 做负载均衡服务器。</li>
<li>支持高并发、内存消耗少、成本低廉、配置简单、运行稳定等。<h2 id="Nginx-安装（CentOS-7）"><a href="#Nginx-安装（CentOS-7）" class="headerlink" title="Nginx 安装（CentOS 7）"></a>Nginx 安装（CentOS 7）</h2></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wget http:<span class="comment">//nginx.org/download/nginx-1.17.3.tar.gz   #下载</span></span><br><span class="line"></span><br><span class="line">tar -zxvf nginx-<span class="number">1.17</span><span class="number">.3</span>.tar.gz #解压到当前目录</span><br></pre></td></tr></table></figure>
<p>进入解压目录中，在编译安装之前，需要安装两个依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum -y install pcre-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure>
<p>然后开始编译安装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>装好之后，默认安装位置在 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
<p>进入到该目录的 sbin 目录下，执行 nginx 即可启动 Nginx ：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-f83f07d9e4694b10b1f3d5596833613b.png" alt="image.png"></p>
<p>启动成功之后，在浏览器中直接访问 Nginx 地址：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-55d69b4a5f544f00a4e6d404291e3b6d.png" alt="image.png"></p>
<p>看到如上页面，表示 Nginx 已经安装成功了。</p>
<p>如果修改了 Nginx 配置，则可以通过如下命令重新加载 Nginx 配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>
<p>本文摘自：<a href="http://springboot.javaboy.org/2019/0605/nginx-guide">http://springboot.javaboy.org/2019/0605/nginx-guide</a> </p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign 从入门到放弃</title>
    <url>/2020/08/08/OpenFeign%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-openfeign%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<p>@<a href="OpenFeign%E5%A4%A7%E7%99%BD%E8%AF%9D">TOC</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前使用的eureka/hystrix 都是调用RestTemplate(繁琐 重复高) 。而OpenFeign对请求进行简化(<strong>实际上就是对之前请求的一个封装</strong>)。Feign停更了 OpenFeign是在Feign基础上开发出来的。</p>
<p>常用的几种接口调用方法：</p>
<ul>
<li>Httpclient 易用 灵活 </li>
<li>Okhttp 处理网络请求 轻量级 支持多协议。。 </li>
<li>HttpURLConnection 使用复杂</li>
<li>RestTemplate Rest服务的客户端 提供多种便携访问HTTP服务的方法</li>
</ul>
<h1 id="1-HelloWorld"><a href="#1-HelloWorld" class="headerlink" title="1.HelloWorld"></a>1.HelloWorld</h1><p>还是继续使用之前的 provider 和 eureka配置，重新建一个spring boot项目，创建时选OpenFeign 依赖。如下：<br><img src="https://img-blog.csdnimg.cn/20201026112319987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="配置 OpenFeign 依赖"><br>创建成功后，在application.properties中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=openfeign</span><br><span class="line">server.port=5000</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:1111/eureka</span><br></pre></td></tr></table></figure>
<p>接下来，在项目启动类上面添加注解，开启Feign的支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>  <span class="comment">//开启feign支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenfeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OpenfeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义HelloService 接口，使用OpenFeign：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;<span class="comment">//这里的方法名随意取 无需遵循java规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用 HelloController 中，调用 HelloService 进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> helloService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201026114144840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="测试结果"></p>
<h1 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2.参数传递"></a>2.参数传递</h1><p>和普通参数传递的区别：</p>
<ul>
<li>参数一定要绑定参数名</li>
<li>如果通过Header来传递参数，一定要中文转码</li>
</ul>
<p>测试的服务端接口，继续使用 provider 的接口；然后，在 openFeign 中添加调用接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;<span class="comment">//这里的方法名随意取 无需遵循java规则</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">hello2</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;<span class="comment">// k/v形式要标记参数名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user2&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">addUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user14/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUserByName</span><span class="params">(<span class="meta">@RequestHeader(&quot;name&quot;)</span> String name)</span></span>;<span class="comment">//放在header之后的参数，一定要转码传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：凡是k/v形式的参数，要标记参数名称。</strong></p>
<p>然后分别启动 Eureka、Provider、OpenFeign，访问 <a href="http://localhost:5000/hello">http://localhost:5000/hello</a> ，控制台如下：<br><img src="https://img-blog.csdnimg.cn/20201102185548223.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="3-继承特性"><a href="#3-继承特性" class="headerlink" title="3.继承特性"></a>3.继承特性</h1><p>将 provider 和 openfeign 中公共的部分提取出来一起使用。<br>新建一个Moudule ，叫做 first-api，由于这个模块要被其它模块所依赖，所以这个模块是一个maven项目，还有用springmvc的东西，因此在创建成功后，要添加 web 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后定义公共接口，就是provider 和 openfeign中公共的部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;<span class="comment">//这里的方法名随意取 无需遵循java规则</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">hello2</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;<span class="comment">// k/v形式要标记参数名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user2&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">addUser2</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user14/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteUser2</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUserByName</span><span class="params">(<span class="meta">@RequestHeader(&quot;name&quot;)</span> String name)</span> <span class="keyword">throws</span> UnsupportedEncodingException</span>;<span class="comment">//放在header之后的参数，一定要转码传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在provider 和 openfeign 中，分别引用该模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>first-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加成功后，在 provider 中实现该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    Integer port;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello 你好&quot;</span>+port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key/value形式传递</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">addUser1</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json传递</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user2&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">addUser2</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user11&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser1</span><span class="params">(User user1)</span></span>&#123;</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user12&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser2</span><span class="params">(<span class="meta">@RequestBody</span> User user2)</span></span>&#123;</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user13&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser1</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user14/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user3&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByName</span><span class="params">(<span class="meta">@RequestHeader</span> String name)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        System.out.println(URLDecoder.decode(name,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 openfeign 中，定义接口继承自公共接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="title">entends</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，测试代码不变。<br>小结：</p>
<ol>
<li>使用继承特性，代码简洁不易出错。服务端和消费端的代码统一，一改俱改，不易出错。这样会提高服务端和消费端的耦合度；</li>
<li>上面所讲的参数传递，在使用了继承之后，依然不变，参数该怎么传还是怎么传。</li>
</ol>
<h1 id="4-日志"><a href="#4-日志" class="headerlink" title="4.日志"></a>4.日志</h1><p>加日志，查看请求调用过程，级别共分四种：</p>
<ol>
<li>NONE：不开启日志，默认就是这个</li>
<li>BASIC：记录请求方法、URL、响应状态码、执行时间</li>
<li>HEADERS：在BASIC 的基础上，加载请求/响应头</li>
<li>FULL：在HEADERS基础上，再增加body 以及请求元数据 </li>
</ol>
<p>四种级别，可以通过Bean 来配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>  <span class="comment">//开启feign支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenfeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OpenfeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">loggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 application.properties 中开启日志级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging.level.com.example.openfeign=debug</span><br></pre></td></tr></table></figure>
<p>重启openfeign ，观察效果。</p>
<h1 id="5-数据压缩"><a href="#5-数据压缩" class="headerlink" title="5.数据压缩"></a>5.数据压缩</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 开启请求的数据压缩</span><br><span class="line">feign.compression.request.enabled=true</span><br><span class="line"># 开启响应的数据压缩</span><br><span class="line">feign.compression.response.enabled=true</span><br><span class="line"># 压缩的数据类型</span><br><span class="line">feign.compression.request.mime-types=text/html,application/json</span><br><span class="line"># 压缩的数据下限，2048 表示当要传输的数据大于 2048 时，才会进行数据压缩</span><br><span class="line">feign.compression.request.min-request-size=2048</span><br></pre></td></tr></table></figure>
<h1 id="6-OpenFeign-Hystrix"><a href="#6-OpenFeign-Hystrix" class="headerlink" title="6.OpenFeign+Hystrix"></a>6.OpenFeign+Hystrix</h1><p>6.1 OpenFeig实际上就是对之前请求的一个封装，所以也需要服务降级等功能，首先定义服务降级的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/java&quot;)</span><span class="comment">//防止请求地址重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceFallback</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">addUser2</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser2</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 HelloService 配置服务降级类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;provider&quot;,fallback = HelloService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 application.properties 中开启 Hystrix.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#开启Hystrix</span><br><span class="line">feign.hystrix.enabled=true</span><br></pre></td></tr></table></figure>
<p>6.2 也可以通过自定义  FallbackFactory 来实现服务降级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">HelloService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;error1--&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;error2--&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">addUser2</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser2</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloService 中配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;provider&quot;,fallbackFactory = HelloServiceFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问如下：<br><img src="https://img-blog.csdnimg.cn/20201104150810540.png#pic_center" alt="在这里插入图片描述"><br>小结：</p>
<ol>
<li>openfeign+hystrix降级操作 在yml中开启hystrix 在@FeignClient中实现fallbackFactory属性(需要implement  FallbackFactory<T>)</li>
<li>或fallback(实现接口implement  Hello1Service添加@RequestMapping(“/xx”)作为区分)</li>
<li>两种实现方式都要添加@Component注解</li>
</ol>
<p><strong>项目地址</strong>：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMq exchange四种方式总结 (极简)</title>
    <url>/2019/09/08/RabbitMq%20exchange%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%20(%E6%9E%81%E7%AE%80)-RabbitMq%20exchange%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%20(%E6%9E%81%E7%AE%80)/</url>
    <content><![CDATA[<h1 id="1-direct"><a href="#1-direct" class="headerlink" title="1.direct"></a>1.direct</h1><p>   Direct Exchange ：<strong>一对一</strong>完全匹配，需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。exchange在和queue进行binding时会设置routingkey，将消息发送到exchange时会设置对应的routingkey，只有这两个routingkey完全相同，exchange才会选择对应的binging进行消息路由。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-8bbf2789428c466eb90f833227586496.png" alt="image.png"></p>
<h1 id="2-fanout"><a href="#2-fanout" class="headerlink" title="2.fanout"></a>2.fanout</h1><p>   Fanout Exchange ：<strong>一对多</strong>完全匹配。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。</p>
<p>总结：直接将消息路由到所有绑定的队列中，无须对消息的routingkey进行匹配操作。（广播）<br><img src="https://www.itmengtao.cn/upload/2020/11/image-87acdc364fbf47309c7659f34cc79dc5.png" alt="image.png"></p>
<h1 id="3-topic"><a href="#3-topic" class="headerlink" title="3.topic"></a>3.topic</h1><p>Topic Exchange ：<strong>多对多</strong>正则匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.*” 只会匹配到“audit.irs”</p>
<p>此类型exchange和direct类型差不多，但direct类型要求routingkey完全相等，这里的routingkey可以有通配符：’*’,’#’。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-4d2ebcfad05e443ab58f5969c699b351.png" alt="image.png"></p>
<h1 id="4-headers"><a href="#4-headers" class="headerlink" title="4.headers"></a>4.headers</h1><p>headers Exchange ：headers交换器允许你匹配AMQP消息的header而非路由键。除此之外，headers交换器和direct交换器完全一致，但性能会差很多。因此它并不太实用，而且<strong>几乎再也用不到了</strong>。</p>
<p><a href="https://github.com/astronger/Springboot-rabbitmq">springboot+rabbitmq的简单案例(4种方式)</a></p>
]]></content>
      <categories>
        <category>Spring Boot | RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 中通用命令 (key) 和补充</title>
    <url>/2020/06/29/Redis%20%E4%B8%AD%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4%20(key)%20%E5%92%8C%E8%A1%A5%E5%85%85-redis%E4%B8%AD%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4key%E5%92%8C%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p><strong>DEL</strong></p>
<p>删除一个 key / value<br><img src="https://img-blog.csdnimg.cn/20201214152330806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>DUMP</strong></p>
<p>序列化给定的 key</p>
<p><img src="https://img-blog.csdnimg.cn/2020121415250753.png" alt="在这里插入图片描述"><br><strong>EXISTS</strong></p>
<p>判断一个 key 是否存在</p>
<p><img src="https://img-blog.csdnimg.cn/20201214152625366.png" alt="在这里插入图片描述"><br><strong>TTL</strong></p>
<p>查看一个 key 的有效期【-1 表示永不过期，-2 表示已经过期】</p>
<p><img src="https://img-blog.csdnimg.cn/20201214152830696.png" alt="在这里插入图片描述"><br><strong>EXPIRE</strong></p>
<p>给一个 key 设置有效期，<strong>如果 key 在过期之前被重新 set 了，则过期时间会失效</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214153150790.png" alt="在这里插入图片描述"><br><strong>PERSIST</strong></p>
<p>移除一个 key 的过期时间</p>
<p><img src="https://img-blog.csdnimg.cn/20201214153733368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>PTTL</strong></p>
<p>和 ttl 一样，只不过这里返回的是毫秒。</p>
<p><strong>keys</strong> * </p>
<p>查看所有的 key </p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>针对四种数据类型 (list/hash/set/zset)：</p>
<ol>
<li>若初次使用，如果容器不存在，就自动创建一个；</li>
<li>若里面空值没有元素，则自动删除容器，释放内存。</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 做分布式锁及Lua 脚本使用笔记</title>
    <url>/2020/06/29/Redis%20%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%8ALua%20%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0-Redis%20%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%8ALua%20%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>@[TOC](Redis 做分布式锁及Lua 脚本使用)</p>
<h1 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h1><p><strong>问题场景</strong>：在单线程中，一个线程去修改用户的状态，首先从数据库中读出用户的状态，然后在内存中进行修改，修改完成后，再存回去。这个操作没有问题，但是在多线程中，由于读取、修改、存这是三个操作，不是原子操作，所以在多线程中，这样会出问题。</p>
<p>我们可以使用<strong>分布式锁来限制程序的并发执行</strong>。</p>
<blockquote>
<p><strong>原理</strong>：分布式锁实现的思路很简单，就是进来一个线程先占位，当别的线程进来操作时，发现已经有人占位了，就会放弃或者稍后再试。</p>
</blockquote>
<p>在 Redis 中，占位一般使用 <strong>setnx</strong> 指令，先进来的线城先占位，线城的操作执行完成后，再调用 <strong>del</strong> 指令释放位子。</p>
<p>根据上面的思路，我们写出的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JedisPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Redis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">        <span class="comment">//连接池最大空闲数</span></span><br><span class="line">        config.setMaxIdle(<span class="number">300</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        config.setMaxTotal(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//连接最大等待时间，如果是 -1 表示没有限制</span></span><br><span class="line">        config.setMaxWaitMillis(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">//在空闲时检测有效性</span></span><br><span class="line">        config.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.Redis 地址</span></span><br><span class="line"><span class="comment">         * 2.redis 端口</span></span><br><span class="line"><span class="comment">         * 3.连接超时时间</span></span><br><span class="line"><span class="comment">         * 4.密码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pool= <span class="keyword">new</span> JedisPool(config,<span class="string">&quot;192.168.1.132&quot;</span>,<span class="number">6379</span>,<span class="number">30000</span>,<span class="string">&quot;javaboy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(CallwithJedis callwithJedis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Jedis jedis = pool.getResource())&#123;</span><br><span class="line">            callwithJedis.call(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallwithJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Jedis jedis)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">        redis.execute(jedis -&gt; &#123;</span><br><span class="line">            String s = jedis.set(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="keyword">new</span> SetParams().nx().ex(<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; <span class="string">&quot;OK&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="comment">//给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放</span></span><br><span class="line">                jedis.expire(<span class="string">&quot;s1&quot;</span>,<span class="number">5</span>);</span><br><span class="line">                <span class="comment">//没人占位</span></span><br><span class="line">                jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">                String name = jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                jedis.del(<span class="string">&quot;s1&quot;</span>);<span class="comment">//释放资源</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有人占位，停止/暂缓 操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 Redis2.8 开始，<strong>setnx</strong> 和 <strong>expire</strong> 可以通过一个命令一起来执行了。</p>
<h1 id="2-解决超时问题"><a href="#2-解决超时问题" class="headerlink" title="2. 解决超时问题"></a>2. 解决超时问题</h1><p>场景：接上文，为了防止业务代码在执行的时候抛出异常，我们给每一个锁添加了一个超时时间，超时之后，锁会被自动释放，但是这也带来了一个新的问题：如果要执行的业务非常耗时，可能会出现紊乱。举个例子：第一个线程首先获取到锁，然后开始执行业务代码，但是业务代码比较耗时，执行了 8 秒，这样，会在第一个线程的任务还未执行成功锁就会被释放了，此时第二个线程会获取到锁开始执行，在第二个线程刚执行了 3 秒，第一个线程也执行完了，此时第一个线程会释放锁，但是注意，它释放的第二个线程的锁，释放之后，第三个线程进来。</p>
<p>对于这个问题，我们可以从两个角度入手：</p>
<ol>
<li>尽量避免在获取锁之后，执行耗时操作。</li>
<li>可以在锁上面做文章，将锁的 value 设置为一个随机字符串，每次释放锁的时候，都去比较随机字符串是否一致，如果一致，再去释放，否则，不释放。</li>
</ol>
<h2 id="2-1-Lua-脚本"><a href="#2-1-Lua-脚本" class="headerlink" title="2.1 Lua 脚本"></a>2.1 Lua 脚本</h2><p>对于第二种方案，由于释放锁的时候，要去查看锁的 value，第二个比较 value 的值是否正确，第三步释放锁，有三个步骤，很明显三个步骤不具备原子性，为了解决这个问题，我们得引入 <strong>Lua 脚本</strong>。</p>
<p>Lua 脚本的<strong>优势</strong>：</p>
<ul>
<li>使用方便，Redis 中内置了对 Lua 脚本的支持。</li>
<li>Lua 脚本可以在 Redis 服务端原子的执行多个 Redis 命令。</li>
<li>由于网络在很大程度上会影响到 Redis 性能，而使用 Lua 脚本可以让多个命令一次执行，可以有效解决网络给 Redis 带来的性能问题。</li>
</ul>
<p>在 Redis 中，使用 Lua 脚本，大致<strong>两种思路</strong>：</p>
<ol>
<li>提前在 Redis 服务端写好 Lua 脚本，然后在 Java 客户端去调用脚本（<strong>推荐</strong>）。</li>
<li>可以直接在 Java 端去写 Lua 脚本，写好之后，需要执行时，每次将脚本发送到 Redis 上去执行。</li>
</ol>
<p>首先在 Redis 服务端创建 Lua 脚本，内容如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用 get 命令，KEYS[1] 表示只有1个，可以n个，下标从1开始；ARGV 除过key之外的其它参数，ARGV[1] 表示只有1个，可以n个。</p>
</blockquote>
<p>接下来，可以给 Lua 脚本求一个 <strong>SHA1</strong> 和(相当于唯一标识符)，命令如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cat lua/releasewherevalueequal.lua | redis-cli -a javaboy script load --pipe</span><br></pre></td></tr></table></figure>
<p>script load 这个命令会在 Redis 服务器中缓存 Lua 脚本，并返回脚本内容的 SHA1 校验和，然后在Java 端调用时，传入 SHA1 校验和作为参数，这样 Redis 服务端就知道执行哪个脚本了。</p>
<p>执行完后如下：<br><img src="https://img-blog.csdnimg.cn/20201224103447309.png" alt="在这里插入图片描述"></p>
<p>接下来，在 Java 端调用这个脚本（代码接上文）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;<span class="comment">//加for循环测试拿不到锁的情况，默认没有</span></span><br><span class="line">            redis.execute(jedis -&gt; &#123;</span><br><span class="line">                <span class="comment">//1.先获取一个随机字符串</span></span><br><span class="line">                String value = UUID.randomUUID().toString();</span><br><span class="line">                <span class="comment">//2.获取锁</span></span><br><span class="line">                String k1 = jedis.set(<span class="string">&quot;k1&quot;</span>, value, <span class="keyword">new</span> SetParams().nx().ex(<span class="number">5</span>));</span><br><span class="line">                <span class="comment">//3.判断是否成功拿到锁</span></span><br><span class="line">                <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; <span class="string">&quot;OK&quot;</span>.equals(k1)) &#123;</span><br><span class="line">                    <span class="comment">//4. 具体的业务操作</span></span><br><span class="line">                    jedis.set(<span class="string">&quot;site&quot;</span>, <span class="string">&quot;拿到锁了&quot;</span>);</span><br><span class="line">                    String site = jedis.get(<span class="string">&quot;site&quot;</span>);</span><br><span class="line">                    System.out.println(site);</span><br><span class="line"><span class="comment">//                  jedis.eval() //lua脚本拼成字符串用此方法</span></span><br><span class="line">                    <span class="comment">//5.释放锁</span></span><br><span class="line">                    jedis.evalsha(<span class="string">&quot;b8059ba43af6ffe8bed3db65bac35d452f8115d8&quot;</span>,Arrays.asList(<span class="string">&quot;k1&quot;</span>), Arrays.asList(value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;没拿到锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020122410463473.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 入门</title>
    <url>/2019/06/21/Redis%20%E5%85%A5%E9%97%A8-Redis%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。</p>
<h2 id="2-优势"><a href="#2-优势" class="headerlink" title="2.优势"></a>2.优势</h2><ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
<li>灵活的数据模型，无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。</li>
<li>取最新N个数据的操作</li>
<li>数据可以设置过期时间</li>
<li>自带发布、订阅消息系统</li>
<li>定时器、计数器</li>
</ul>
<p>详情请参考：<a href="https://redis.io/">https://redis.io/</a><br>CentOS 7安装Redis（详细）：<a href="https://blog.csdn.net/ourstronger/article/details/100590486">https://blog.csdn.net/ourstronger/article/details/100590486</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 基本数据类型 (Hash) 的操作命令</title>
    <url>/2020/06/29/Redis%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20(Hash)%20%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bhash%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在 Hash 结构中， key 是一个字符串， value 则是一个 key/value 键值对。</p>
<p><strong>HSET</strong></p>
<p>添加值。<br><img src="https://img-blog.csdnimg.cn/20201214105336876.png" alt="在这里插入图片描述"><br><strong>HGET</strong></p>
<p>获取值。</p>
<p><img src="https://img-blog.csdnimg.cn/2020121410544843.png" alt="在这里插入图片描述"><br><strong>HMSET</strong></p>
<p>批量添加。<br><img src="https://img-blog.csdnimg.cn/20201214105746177.png" alt="在这里插入图片描述"><br><strong>HMGET</strong></p>
<p>批量获取。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214105830519.png" alt="在这里插入图片描述"><br><strong>HDEL</strong></p>
<p>删除一个指定的 field</p>
<p><img src="https://img-blog.csdnimg.cn/20201214110022626.png" alt="在这里插入图片描述"><br><strong>Hsetnx</strong></p>
<p>默认情况下，如果 key 和 field 相同，会覆盖掉已有的 value ，hsetnx 则不会。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214110625525.png" alt="在这里插入图片描述"></p>
<p><strong>Hvals</strong></p>
<p>获取所有的 value<br><img src="https://img-blog.csdnimg.cn/20201214110750269.png" alt="在这里插入图片描述"><br><strong>Hkeys</strong></p>
<p>获取所有的 key</p>
<p><img src="https://img-blog.csdnimg.cn/20201214110914906.png" alt="在这里插入图片描述"><br><strong>Hgetall</strong></p>
<p>同时获取 key 和 value</p>
<p><img src="https://img-blog.csdnimg.cn/2020121411102328.png" alt="在这里插入图片描述"><br><strong>HEXISTS</strong></p>
<p>返回 field 是否存在</p>
<p><img src="https://img-blog.csdnimg.cn/20201214111152918.png" alt="在这里插入图片描述"><br><strong>HINCRBY</strong></p>
<p>给指定的 value 自增（指定数），不能加浮点。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214111702658.png" alt="在这里插入图片描述"></p>
<p><strong>HINCRBYFLOAT</strong></p>
<p>自增一个浮点数<br><img src="https://img-blog.csdnimg.cn/20201214111811212.png" alt="在这里插入图片描述"></p>
<p><strong>HLEN</strong></p>
<p>返回某一个 key 中 value 的数量</p>
<p><img src="https://img-blog.csdnimg.cn/20201214112054656.png" alt="在这里插入图片描述"></p>
<p><strong>HSTRHLEN</strong></p>
<p>返回某一个 key 中的某一个 field 的字符串长度</p>
<p><img src="https://img-blog.csdnimg.cn/20201214112211668.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 (List) 的操作命令</title>
    <url>/2020/06/29/Redis%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20(List)%20%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-Redis%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20(List)%20%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>添加元素可重复。</p>
<p><strong>LPUSH</strong><br>表示 将 value 的值<strong>从左到右</strong>依次插入表头的位置。将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。如果 key 对应的值不是一个 list 的话，那么会返回一个错误。<br><img src="https://img-blog.csdnimg.cn/20201211095227829.png" alt="在这里插入图片描述"><br><strong>LRANGE</strong></p>
<p>返回列表指定区间内的元素(倒叙)<br><img src="https://img-blog.csdnimg.cn/2020121109553477.png" alt="在这里插入图片描述"><br><strong>RPUSH</strong> </p>
<p>这个和 lpush 功能类似。不同的是 rpush 是<strong>从右往左</strong>依次插入表头的位置。向存于 key 的列表的尾部插入所有指定的值。<br><img src="https://img-blog.csdnimg.cn/20201211101043317.png" alt="在这里插入图片描述"></p>
<p><strong>RPOP</strong> </p>
<p>移除并返回列表的尾元素。</p>
<p><img src="https://img-blog.csdnimg.cn/20201211113041979.png" alt="在这里插入图片描述"><br><strong>LPOP</strong></p>
<p>移除并返回列表的头元素。</p>
<p><img src="https://img-blog.csdnimg.cn/20201211113206697.png" alt="在这里插入图片描述"><br><strong>LINDEX</strong></p>
<p><strong>返回</strong>列表中，小标为 index 的元素。</p>
<p><img src="https://img-blog.csdnimg.cn/2020121111350672.png" alt="在这里插入图片描述"><br><strong>LTRIM</strong></p>
<p>可以对一个列表进行修剪，让列表只保留指定区间内的元素，不在区间内就会被移除，类似于区间截取。0~-1 从0到最后一个。</p>
<p><img src="https://img-blog.csdnimg.cn/20201211113959391.png" alt="在这里插入图片描述"><br><strong>BLPOP</strong></p>
<p>阻塞式的弹出，相当于 lpop 的阻塞版。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 (ZSet) 的操作命令</title>
    <url>/2020/06/29/Redis%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20(ZSet)%20%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-Redis%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20(ZSet)%20%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>ZADD</strong></p>
<p>将指定的元素添加到有序集合中。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214113117793.png" alt="在这里插入图片描述"><br><strong>ZSCORE</strong></p>
<p>返回 member 的 score 值<br><img src="https://img-blog.csdnimg.cn/20201214113241284.png" alt="在这里插入图片描述"><br><strong>ZRANGE</strong></p>
<p>返回集合中的一组元素。</p>
<p><img src="https://img-blog.csdnimg.cn/2020121411365528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>ZREVRANGE</strong></p>
<p>返回一组元素，但是是倒叙。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214114112789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>ZCARD</strong></p>
<p>返回元素个数</p>
<p><img src="https://img-blog.csdnimg.cn/20201214114228993.png" alt="在这里插入图片描述"></p>
<p><strong>ZCOUNT</strong></p>
<p>返回 score 在某一个区间内的元素。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214114552937.png" alt="在这里插入图片描述"></p>
<p><strong>ZRANGEBYSCORE</strong></p>
<p>按照 score 的范围返回元素。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214142006472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>ZRANK</strong></p>
<p>返回元素的排名（从小到大）</p>
<p><img src="https://img-blog.csdnimg.cn/20201214143534177.png" alt="在这里插入图片描述"></p>
<p><strong>zrevrank</strong></p>
<p>返回元素的排名（从大到小）<br><img src="https://img-blog.csdnimg.cn/2020121414403175.png" alt="在这里插入图片描述"></p>
<p><strong>ZINCRBY</strong></p>
<p>score 自增</p>
<p><img src="https://img-blog.csdnimg.cn/20201214144402496.png" alt="在这里插入图片描述"><br><strong>ZINTERSTORE</strong></p>
<p>给两个集合求交集，求和</p>
<p><img src="https://img-blog.csdnimg.cn/20201214145128760.png" alt="在这里插入图片描述"></p>
<p><strong>ZREM</strong></p>
<p>弹出一个元素</p>
<p><img src="https://img-blog.csdnimg.cn/20201214145438669.png" alt="在这里插入图片描述"></p>
<p><strong>ZLEXCOUNT</strong></p>
<p>统计有序集合中成员数量</p>
<p><img src="https://img-blog.csdnimg.cn/20201214150058944.png" alt="在这里插入图片描述"></p>
<p><strong>ZRANGEBYLEX</strong></p>
<p>返回指定区间内的成员。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214150243108.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型(Set) 的操作命令</title>
    <url>/2020/06/29/Redis%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(Set)%20%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-Redis%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(Set)%20%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>SADD</strong></p>
<p>添加元素到 key 中，添加的元素<strong>不可重复</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214100335314.png" alt="在这里插入图片描述"></p>
<p><strong>SMEMBERS</strong></p>
<p>获取一个 key 下的所有元素</p>
<p><img src="https://img-blog.csdnimg.cn/20201214100515839.png" alt="在这里插入图片描述"></p>
<p><strong>SREM</strong></p>
<p>在 key 集合中移除指定的元素</p>
<p><img src="https://img-blog.csdnimg.cn/20201214100600897.png" alt="在这里插入图片描述"></p>
<p><strong>SISMEMBER</strong></p>
<p>返回某一个成员是否在集合中<br><img src="https://img-blog.csdnimg.cn/20201214100858969.png" alt="在这里插入图片描述"><br><strong>SCARD</strong></p>
<p>返回集合的数量</p>
<p><img src="https://img-blog.csdnimg.cn/20201214101113623.png" alt="在这里插入图片描述"><br><strong>SRANDMEMBER</strong></p>
<p>随机返回一个元素，[count] 是几就返回几个，不会删除元素<br><img src="https://img-blog.csdnimg.cn/20201214101321178.png" alt="在这里插入图片描述"><br><strong>SPOP</strong></p>
<p>随机返回并出栈( 删除 )一个元素。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214101732654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>SMOVE</strong></p>
<p>把一个元素从一个集合移除到另一个集合中去。<br><img src="https://img-blog.csdnimg.cn/20201214102415728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>SDIFF</strong></p>
<p>返回两个集合的<strong>差集</strong> （注意顺序）。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214103041232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>SINTER</strong></p>
<p>返回两个集合的<strong>交集</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214103239418.png" alt="在这里插入图片描述"></p>
<p><strong>SDIFFSTRORE</strong></p>
<p>这个类似与 sdiff ，不同的是，计算出来的结果会保存在一个新的集合中。</p>
<p><img src="https://img-blog.csdnimg.cn/20201214104217988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>SINTERSTORE</strong></p>
<p>类似于 sinter ，只是将计算出来的交集保存到一个新的集合中。</p>
<p><strong>SUNION</strong></p>
<p>求并集。</p>
<p><strong>SUNIONSTORE</strong></p>
<p>求并集，将计算出来的交集保存到一个新的集合中。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 的Java 客户端笔记整理</title>
    <url>/2020/06/29/Redis%20%E7%9A%84Java%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86-redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>@[TOC](Redis 的Java 客户端笔记整理)</p>
<h1 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h1><p>redis 默认不支持远程连接，需手启：</p>
<p>修改地方 (找到 config)</p>
<ol>
<li>把 bind:127.0.0.1 注释掉 </li>
<li>密码校验开启 (去掉 requirepass 注解 在 vim 搜索:/requirepass，加上自己的密码)</li>
</ol>
<p>ok 保存退出启redis。</p>
<h1 id="Jedis-maven-篇-基本使用"><a href="#Jedis-maven-篇-基本使用" class="headerlink" title="Jedis (maven 篇) 基本使用"></a>Jedis (maven 篇) 基本使用</h1><p>Jedis的Github地址：<a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p>
<p>1、创建 maven 项目，添加Jedis依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 new一个jedis对象 默认6379</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.1.132&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 2 密码认证</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">// 3 测试是否连通</span></span><br><span class="line">        String ping = jedis.ping();</span><br><span class="line">        <span class="comment">// 4 返回PONG 说明连接成功</span></span><br><span class="line">        System.out.println(ping);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 main 方法，输出 <strong>PONG</strong> 则成功。</p>
<p>在 Jedis 中，由于方法的API 与 redis 命令高度一致。直接使用即可。</p>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><p>在实际应用中，Jedis 实例我们一般是通过连接池来获取，由于 Jedis 对象不是线程安全的，所以当我们使用 Jedis 对象时，从连接池获取 Jedis ，使用完成后，再还给连接池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//1.构造一个 jedis 连接池</span></span><br><span class="line">            JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="string">&quot;192.168.1.132&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">            <span class="comment">//2. 从连接池中获取一个 jedis 连接</span></span><br><span class="line">            jedis = pool.getResource();</span><br><span class="line">            jedis.auth(<span class="string">&quot;javaboy&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3. Jedis 操作</span></span><br><span class="line">            String ping = jedis.ping();</span><br><span class="line">            System.out.println(ping);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4. 归还连接</span></span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JedisPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Redis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">        <span class="comment">//连接池最大空闲数</span></span><br><span class="line">        config.setMaxIdle(<span class="number">300</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        config.setMaxTotal(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//连接最大等待时间，如果是 -1 表示没有限制</span></span><br><span class="line">        config.setMaxWaitMillis(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">//在空闲时检测有效性</span></span><br><span class="line">        config.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.Redis 地址</span></span><br><span class="line"><span class="comment">         * 2.redis 端口</span></span><br><span class="line"><span class="comment">         * 3.连接超时时间</span></span><br><span class="line"><span class="comment">         * 4.密码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pool= <span class="keyword">new</span> JedisPool(config,<span class="string">&quot;192.168.1.132&quot;</span>,<span class="number">6379</span>,<span class="number">30000</span>,<span class="string">&quot;javaboy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(CallwithJedis callwithJedis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Jedis jedis = pool.getResource())&#123;</span><br><span class="line">            callwithJedis.call(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallwithJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Jedis jedis)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">        redis.execute(jedis -&gt; &#123;</span><br><span class="line">            System.out.println(jedis.ping());</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h1><p>Lettuce 和 Jedis 的<strong>区别</strong>：</p>
<ol>
<li>Jedis 在实现的过程中是直接连接 Redis 的，在多个线程之间共享一个 Jedis 实例，这是线程不安全的，如果想在多线程场景下使用 Jedis，就得使用连接池，这样每个连接池都有自己的 Jedis 实例。</li>
<li>Lettuce 基于 Netty NIO 框架来构建，所以克服了 Jedis 中线程不安全的问题， Lettuce 支持同步、异步以及响应式调用，多个线程可以共享一个连接实例。</li>
</ol>
<p>使用 Lettuce ，首先创建一个 Maven 项目，添加 Lettuce 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>简单测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//这里密码直接写在连接池里，在 @ 前</span></span><br><span class="line">        RedisClient redisClient = RedisClient.create(<span class="string">&quot;redis://javaboy@192.168.1.132&quot;</span>);</span><br><span class="line">        StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class="line">        RedisCommands&lt;String, String&gt; sync = connect.sync();</span><br><span class="line">        sync.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        String name = sync.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis中的五种数据类型以及Key的相关命令简介</title>
    <url>/2019/12/16/Redis%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8AKey%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-Redis%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8AKey%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>上篇文章我们介绍了如何在 <a href="https://blog.csdn.net/ourstronger/article/details/100590486">Linux(CentOS 7.x)中安装Redis</a>，本文我们来了解下Redis中的<strong>五种</strong>数据类型。</p>
<h2 id="五大数据类型介绍"><a href="#五大数据类型介绍" class="headerlink" title="五大数据类型介绍"></a>五大数据类型介绍</h2><p>redis中的数据都是以<strong>key / value</strong>的形式存储的，五大数据类型主要是指value的数据类型，包含如下五种：</p>
<h2 id="1-STRING"><a href="#1-STRING" class="headerlink" title="1.STRING"></a>1.STRING</h2><p>STRING是redis中最基本的数据类型，redis中的STRING类型是二进制安全的，即它可以包含任何数据，比如一个序列化的对象甚至一个jpg图片，要注意的是redis中的字符串大小上限是<strong>512M</strong>。</p>
<h2 id="2-LIST"><a href="#2-LIST" class="headerlink" title="2.LIST"></a>2.LIST</h2><p>LIST是一个简单的字符串列表，按照插入顺序进行排序，我们可以从LIST的头部(LEFT)或者尾部(RIGHT)插入一个元素，也可以从LIST的头部(LEFT)或者尾部(RIGHT)弹出一个元素。</p>
<h2 id="3-HASH"><a href="#3-HASH" class="headerlink" title="3.HASH"></a>3.HASH</h2><p>HASH类似于Java中的Map，是一个键值对集合，在redis中可以用来存储对象。</p>
<h2 id="4-SET"><a href="#4-SET" class="headerlink" title="4.SET"></a>4.SET</h2><p>SET是STRING类型的无序集合，不同于LIST，SET中的元素不可以重复。</p>
<h2 id="5-ZSET"><a href="#5-ZSET" class="headerlink" title="5.ZSET"></a>5.ZSET</h2><p>ZSET和SET一样，也是STRING类型的元素的集合，不同的是ZSET中的每个元素都会关联一个double类型的分数，ZSET中的成员都是唯一的，但是所关联的分数可以重复。</p>
<p>OK，通过上面的介绍，相信小伙伴们对五大数据类型都有一个大致的认识了，接下来我们就来看看这<strong>五种数据类型要怎么操作</strong>。</p>
<h2 id="key相关的命令"><a href="#key相关的命令" class="headerlink" title="key相关的命令"></a>key相关的命令</h2><p>由于五大数据类型的数据结构本身有差异，因此对应的命令也会不同，但是有一些命令不管对于哪种数据类型都是存在的，我们今天就先来看看这样一些特殊的命令。</p>
<p>首先通过redis-server redis.conf命令启动redis，再通过redis-cli命令进入到控制台中，如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-82a49cb20c1f4d3ea4f5a23a63651063.png" alt="image.png"></p>
<p> 首先我们可以通过<strong>set</strong>命令插入一条记录：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-a1331eeac61a44a599239ad68069b2c7.png" alt="image.png"></p>
<h2 id="DEL命令"><a href="#DEL命令" class="headerlink" title="DEL命令"></a>DEL命令</h2><p>看到OK表示插入成功。通过DEL命令我们可以删除一个已经存在的key，如下：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-74b70e691080437ebe42722383eba4ec.png" alt="image.png"></p>
<h2 id="DUMP命令"><a href="#DUMP命令" class="headerlink" title="DUMP命令"></a>DUMP命令</h2><p>DUMP命令可以序列化给定的key，并返回序列化之后的值：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-4bde46c0dc514336b7e1e5e8f3cdc4b7.png" alt="image.png"></p>
<h2 id="EXISTS命令"><a href="#EXISTS命令" class="headerlink" title="EXISTS命令"></a>EXISTS命令</h2><p>EXISTS命令用来检测一个给定的key是否存在，如下(结果表示k1存在而k2不存在。)：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-3136bf16a03c43a5ba86280e81cf1c20.png" alt="image.png"></p>
<h2 id="TTL命令"><a href="#TTL命令" class="headerlink" title="TTL命令"></a>TTL命令</h2><p>TTL命令可以查看一个给定key的有效时间：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-e9acb5d771074650a6f011cc8269b554.png" alt="image.png"></p>
<p>-2表示key不存在或者已过期；-1表示key存在并且没有设置过期时间（永久有效）。</p>
<p>当然，我们可以通过下面的命令给key设置一个过期时间： </p>
<h2 id="EXPIRE命令"><a href="#EXPIRE命令" class="headerlink" title="EXPIRE命令"></a>EXPIRE命令</h2><p>EXPIRE命令可以给key设置有效期 (单位:秒)，在有效期过后，key会被销毁。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-5481beaf81ee44dea90dcab825c8724e.png" alt="image.png"></p>
<p>设置有效期30秒，TTL k1返回22表示这个key1的有效期还剩22秒。 </p>
<h2 id="PERSIST命令"><a href="#PERSIST命令" class="headerlink" title="PERSIST命令"></a>PERSIST命令</h2><p>PERSIST命令表示移除一个key的过期时间，这样该key就永远不会过期：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-021109a919064730baede9952711cf98.png" alt="image.png"></p>
<h2 id="PEXPIRE命令"><a href="#PEXPIRE命令" class="headerlink" title="PEXPIRE命令"></a>PEXPIRE命令</h2><p>PEXPIRE命令的功能和EXPIRE命令的功能基本一致，只不过这里设置的参数是毫秒：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-e3984803b63d47a8972b15fb50496679.png" alt="image.png"></p>
<h2 id="PTTL命令"><a href="#PTTL命令" class="headerlink" title="PTTL命令"></a>PTTL命令</h2><p>PTTL命令和TTL命令基本一致，只不过PTTL返回的是毫秒数：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-b5a39790f2a349e7a634a8cfa71ae8e7.png" alt="image.png"></p>
<h2 id="KEYS-命令"><a href="#KEYS-命令" class="headerlink" title="KEYS 命令"></a>KEYS 命令</h2><p>KEYS命令可以获取满足给定模式的所有key，比如：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-c476a541a62b45ca97063b41ee5827f1.png" alt="image.png"></p>
<p> KEYS <em>表示获取所有的KEY，</em>也可以是一个正则表达式。</p>
<p>参考：官方文档 <a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis字符串(STRING)中BIT相关命令</title>
    <url>/2019/12/27/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2(STRING)%E4%B8%ADBIT%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-Redis%E5%AD%97%E7%AC%A6%E4%B8%B2(STRING)%E4%B8%ADBIT%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>BIT相关的命令是指BITCOUNT/BITFIELD/BITOP/BITPOS/SETBIT/GETBIT 几个命令，灵活使用这几个命令，可以给我们的项目带来很多惊喜。</p>
<p>在学习这几个命令之前，我们得先了解下redis中字符串的存储方式，redis中的字符串都是以二进制的方式进行存储的，比如说我执行如下命令：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-9306fbf77d8f4361a501577692409057.png" alt="image.png"></p>
<p> a对应的ASCII码是97，转换为二进制数据是01100001，我们BIT相关命令都是对这个二进制数据进行操作。请继续往下看。</p>
<h2 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h2><p>GETBIT命令可以返回key对应的value在offset处的bit值，以上文提到的k1为例，a对应的二进制数据是01100001，所以当offset为0时，对应的bit值为0；offset为1时，对应的bit值为1；offset为2时，对应的bit值为1；offset为3时，对应的bit值为0，依此类推…，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-d82bac2cb72c4da28b05d589eed00c46.png" alt="image.png"></p>
<h2 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h2><p>SETBIT可以用来修改二进制数据，比如a对应的ASCII码为97，c对应的ASCII码为99，97转为二进制是01100001，99转为二进制是01100011，两个的差异在于第六位一个是0一个是1，通过SETBIT命令，我们可以将k1的第六位的0改为1（第六位是从0开始算），如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-f3fcc005d43a48238b221313a340fdde.png" alt="image.png"></p>
<p>此时，k1中存储的字符也就变为了c。SETBIT在执行时所返回的数字，表示该位上原本的bit值。 </p>
<h2 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h2><p>BITCOUNT可以用来统计这个二进制数据中1的个数，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-ab94a20c0bd949dd938f4fecc6a849c8.png" alt="image.png"></p>
<p>关于BITCOUNT，redis官网上有一个非常有意思的案例：<strong>用户上线次数统计</strong>。节选部分原文如下： </p>
<p>“举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。”</p>
<p>这种统计方式最大的好处就是节省空间并且运算速度快。每天占用一个bit，一年也就365个bit，10年也就10*365个bit，也就是456个字节，对于这么大的数据，bit的操作速度非常快。</p>
<h2 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h2><p>BITOP可以对一个或者多个二进制位串执行并(AND)、或(OR)、异或(XOR)以及非(NOT)运算，如下：a对应的ASCII码转为二进制是01100001，c对应的二进制位串是01100011。对这两个二进制位串分别执行AND\OR\XOR的结果如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-4c45effecae54e00a5f1623e0d8518a2.png" alt="image.png"></p>
<p>另外，BITOP也可以执行NOT运算，但是注意参数个数，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITOP not k3 k4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h2 id="BITPOS"><a href="#BITPOS" class="headerlink" title="BITPOS"></a>BITPOS</h2><p>BITPOS用来获取二进制位串中第一个1或者0的位置，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-c27e20055e4a40afbb4fc769d77059a3.png" alt="image.png"></p>
<p>也可以在后面设置一个范围，不过后面的范围是字节的范围，而不是二进制位串的范围。</p>
<p>往期相关文章：</p>
<ol>
<li><p><a href="https://blog.csdn.net/ourstronger/article/details/100590486">CentOS 7.x 安装Redis</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/ourstronger/article/details/103233838">Redis中的五种数据类型以及Key的相关命令简介</a></p>
</li>
<li><p><a href="https://blog.csdn.net/ourstronger/article/details/103236743">Redis字符串(STRING)的操作命令</a></p>
</li>
</ol>
<p>参考： 官方文档 <a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a> </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis字符串(STRING)的操作命令</title>
    <url>/2019/12/28/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2(STRING)%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-Redis%E5%AD%97%E7%AC%A6%E4%B8%B2(STRING)%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a>APPEND</h2><p>使用APPEND命令时，如果key已经存在，则会直接在value后追加值，如果key不存在，则会先创建一个value为空字符串的key，然后再追加：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-bccde81fdf9c4ec4808c4b7556367b30.png" alt="image.png"></p>
<h2 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a>DECR</h2><p>DECR命令可以实现对value的减1操作，如果key不存在，则key对应的初始值会被置为0，如果key的value不为数字，则会报错，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-c850ec84c6814e9994ea30f815c5b195.png" alt="image.png"></p>
<h2 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a>DECRBY</h2><p>DECRBY和DECR类似，不同的是DECRBY可以指定长度，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-8101d656c14840498b4bfb43646ab49c.png" alt="image.png"></p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>GET命令用来获取对应key的value，如果key不存在则返回nil，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-42692ed5f6ce49359d6b6bd276530fed.png" alt="image.png"></p>
<h2 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a>GETRANGE</h2><p>GETRANGE用来返回key所对应的value的子串(截取串子)，子串由start和end决定，从左往右计算，如果下标是负数，则从右往左计算，其中-1表示最后一个字符，-2是倒数第二个…，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-1b8a20e3b8c34b248e22a4ab66006869.png" alt="image.png"></p>
<h2 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h2><p>GETSET命令可以用来获取key所对应的value，并对key进行重置，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-1b459a2c119d483192b55d3d5d5a9a00.png" alt="image.png"></p>
<h2 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a>INCR</h2><p>INCR操作可以对指定key的value执行加1操作，如果指定的key不存在，那么在加1操作之前，会先将key的value设置为0，如果key的value不是数字，则会报错。如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-a1cceec8df7745e0ad2568d92fcf9dd4.png" alt="image.png"></p>
<h2 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a>INCRBY</h2><p>INCRBY和INCR功能类似，不同的是可以指定增长的步长，如下：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-db9edc2e661c4b4699fea141e54dcbd4.png" alt="image.png"></p>
<h2 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a>INCRBYFLOAT</h2><p>INCRBYFLOAT命令可以用来增长浮点数，如下：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-ebb2b24a942141a9ad481f2054811c92.png" alt="image.png"></p>
<h2 id="MGET与MSET"><a href="#MGET与MSET" class="headerlink" title="MGET与MSET"></a>MGET与MSET</h2><p>MGET与MSET分别用来批量设置值和批量获取值，如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-b49d547dc0d34dd2af3b9f4973c50020.png" alt="image.png"></p>
<h2 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h2><p>SETEX用来给key设置value，同时设置过期时间(单位：秒)，等效于先给key设置value，再给key设置过期时间，如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-3eea3ff405404454a5b81ea2cdd5dbf0.png" alt="image.png"></p>
<h2 id="PSETEX"><a href="#PSETEX" class="headerlink" title="PSETEX"></a>PSETEX</h2><p>PSETEX的作用和SETEX类似，不同的是，这里设置过期时间的单位是毫秒，如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-01d1711397414407981a8c1cd2b2ac2e.png" alt="image.png"></p>
<h2 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h2><p>SETNX是 SET if Not eXists的简写，SET命令在执行时，如果key已经存在，则新值会覆盖掉旧值，而对于SETNX命令，如果key已经存在，则不做任何操作，如果key不存在，则效果等同于SET命令。如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-f608aa2113e64293a253c7c721f9ab84.png" alt="image.png"></p>
<h2 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a>MSETNX</h2><p>MSETNX兼具了SETNX和MSET的特性，但是MSETNX在执行时，如果有一个key存在，则所有的都不会执行，如下：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-f606c4b4bee24930bca46b8a882c7e58.png" alt="image.png"></p>
<h2 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a>SETRANGE</h2><p>SETRANGE用来覆盖一个已经存在的key的value，如下：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-f05dd3a437c04e88a54a1d617b6412cd.png" alt="image.png"></p>
<p> 如果已经存在的key的value长度小于offset，则不足的地方用0补齐，如下：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-8759ad8698864043887798e8fcd30215.png" alt="image.png"></p>
<h2 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a>STRLEN</h2><p>STRLEN用来计算key的value的长度，如下：</p>
<p> <img src="https://www.itmengtao.cn/upload/2020/11/image-af62fb9ccc564e09a26635d31d0c4e27.png" alt="image.png"></p>
<p>相关文章：<a href="https://blog.csdn.net/ourstronger/article/details/100590486">CentOS 7.x 安装Redis</a><br>                  <a href="https://blog.csdn.net/ourstronger/article/details/103233838">Redis中的五种数据类型以及Key的相关命令简介</a></p>
<p>参考 ：官方文档 <a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a> </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RestTemplate 操作详细笔记</title>
    <url>/2020/06/27/RestTemplate%20%E6%93%8D%E4%BD%9C%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0-RestTemplate%20%E6%93%8D%E4%BD%9C%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="RestTemplate-介绍"><a href="#RestTemplate-介绍" class="headerlink" title="RestTemplate 介绍"></a>RestTemplate 介绍</h2><ul>
<li>spring3.0 开始支持</li>
<li>Http 请求工具</li>
<li>该工具与 springboot 或 springcloud 无关</li>
<li>提供常见的 REST 请求模版</li>
<li>例如支持 GET、PUT、POST、DELETE</li>
<li>通用请求方法 –&gt; exchange 和 execute</li>
<li>实现 RestOperations 接口</li>
<li>该接口定义了常见的 RESTful 操作<h3 id="1-GET-操作"><a href="#1-GET-操作" class="headerlink" title="1.GET 操作"></a>1.GET 操作</h3>首先在 provider 中定义一个 hello2 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span>+name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们在 consumer 去访问这个接囗，调用 RestTemplate 中 的 GET 请求。 可以看到，在 RestTemplate 中，关于 GET 请求，一共有两大类方法：</p>
<p>这两大类方法实际上是重载的，唯一不同的，就是返回值类型。 getForObject 返回的是一个对象，这个对象就是服务端返回的具体值。getForEntiey 返回的是一个 ResponseEntity，这个 ResponseEntity 中除了服务端返回的具体数据外，还保留了 Http 应头的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = restTemplate.getForObject(<span class="string">&quot;http://provider/hello2?name=&#123;1&#125;&quot;</span>,String.class,<span class="string">&quot;javaone&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">    ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">&quot;http://provider/hello2&quot;</span>, String.class, <span class="string">&quot;javaone&quot;</span>);</span><br><span class="line">    String body = responseEntity.getBody();</span><br><span class="line">    System.out.println(<span class="string">&quot;body:&quot;</span>+body);</span><br><span class="line">    HttpStatus statusCode = responseEntity.getStatusCode();</span><br><span class="line">    System.out.println(<span class="string">&quot;HttpStatus:&quot;</span>+statusCode);</span><br><span class="line">    <span class="keyword">int</span> statusCodeValue = responseEntity.getStatusCodeValue();</span><br><span class="line">    System.out.println(<span class="string">&quot;statusCodeValue:&quot;</span>+statusCodeValue);</span><br><span class="line">    HttpHeaders headers = responseEntity.getHeaders();</span><br><span class="line">    Set&lt;String&gt; keySet = headers.keySet();</span><br><span class="line">    System.out.println(<span class="string">&quot;---------headers--------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : keySet) &#123;</span><br><span class="line">        System.out.println(s+<span class="string">&quot;:&quot;</span>+headers.get(s)+<span class="string">&quot;///&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里大家可以看到，getForObject 直接拿到了服务的返回值，getForEntity 不仅仅拿到服务的返回值， 还拿到 http 应的状态码。然后，后动 Eureka Server、provider 以及 consumer，访问 consumer 中的 hello4 接囗，既可以看到请求结果。</p>
<p>看清楚两者的区别之舌，接下来看下两个各自的重载方法，getForObject 和 getForEntity 分别有三个重载方法，两者的三个重载方法基本都是一致的。所以，这里，我们主要看其中一种。三个重载方法， 其实代表了三种不同的传参方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello5&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = restTemplate.getForObject(<span class="string">&quot;http://provider/hello2?name=&#123;1&#125;&quot;</span>,String.class,<span class="string">&quot;javatwo&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span>+s1);</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        s1 = restTemplate.getForObject(<span class="string">&quot;http://provider/hello2?name=&#123;name&#125;&quot;</span>, String.class,map);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span>+s1);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String url = <span class="string">&quot;http://provider/hello2?name=&quot;</span>+ URLEncoder.encode(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            URI uri = URI.create(url);</span><br><span class="line">            s1 = restTemplate.getForObject(uri, String.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;3:&quot;</span>+s1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<ol>
<li>getForObject 和 getForEntity 返回值区别：</li>
</ol>
<ul>
<li>getForObject 返回一个对象 (服务返回的具体值)</li>
<li>getForEntity 不仅返回具体数据 还可以返回状态码 头信息…</li>
</ul>
<ol start="2">
<li>getForObject 和 getForEntity 三种重载方式的类似</li>
</ol>
<ul>
<li>Object… –&gt; 占位符 (?xxx={1}, xx.class, “xxxxx”)</li>
<li>Map&lt;String, ?&gt; –&gt; 占位符为自定义 key (name) 需要提前声明 map (?xxx={key}, xx.class, 返回的 map)</li>
<li>URI –&gt; 字符串中包含中文的需要转码才能创建为 URI 在被调用</li>
</ul>
<h3 id="2-POST-操作"><a href="#2-POST-操作" class="headerlink" title="2.POST 操作"></a>2.POST 操作</h3><h4 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h4><p>因为 post 请求可能是 k/v 或是 json 形式，需要提供 2 种接口，传参对象需要创建一个 model， 为了以后方便使用直接新建一个普通的 maven 项目作为 commons 模块管理。</p>
<p>创建一个 User 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 provider 和 consumer 分别引用 commons 模块依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-provider-提供-2-个接口"><a href="#2-2-provider-提供-2-个接口" class="headerlink" title="2.2 provider 提供 2 个接口"></a>2.2 provider 提供 2 个接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key/value形式传递</span></span><br><span class="line"> <span class="meta">@PostMapping(&quot;/user1&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> User <span class="title">addUser1</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> user;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//json传递</span></span><br><span class="line"> <span class="meta">@PostMapping(&quot;/user2&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> User <span class="title">addUser2</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> user;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们在 consumer 中调这两个 POST 接囗。</p>
<p>这里的 post 和前面的 get 很像，只是多出来了三个方法，就是 postForLocation，另外，两个 postForObject 和 postForEntiy 和前面 get 基不一致，所以这里我们主要来看 postForObject, 看完之后，我们再来看这个额外的 postForLocation。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello6&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;javajava&quot;</span>);</span><br><span class="line">    map.add(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    map.add(<span class="string">&quot;id&quot;</span>,<span class="number">666</span>);</span><br><span class="line">    User user = restTemplate.postForObject(<span class="string">&quot;http://provider/user1&quot;</span>, map, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;1:&quot;</span>+user);</span><br><span class="line">    user.setId(<span class="number">888</span>);</span><br><span class="line">    user = restTemplate.postForObject(<span class="string">&quot;http://provider/user2&quot;</span>, user, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;2:&quot;</span>+user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>post 参数到底是 k/v 形式还是 json 形式，主要看第二个参数，如果第二个参数是 MultiValueMap，则参数是以 k/v 形来传递的。 如果是一个普通对象，则参数是以的 son 形式 传递。</p>
<p>最后再看看一下 postForLocation。有的时候，当执行完一个 post 请求之后，立马要进行重定向， 一个非常常见的场景就是注册，注册是一个 post 请求，注册完成之后，立马重定向到登录页面去登录。对于这种场景，我们就可以便用 postForLocation。</p>
<p>首先我们在 provider 上提供一个用户注册接囗：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:http://provider/loginPage?username=&quot;</span>+user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/loginPage&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">loginPage</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;loginPage:&quot;</span>+username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>这里的 post 接口，响应一定是 302，否则 postForLocaton 无效。<br>重定向的地址，一定要写成绝对路径，不要写成相对路径，否则在 consumer 中调用时会出问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello7&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;javajava&quot;</span>);</span><br><span class="line">    map.add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    map.add(<span class="string">&quot;id&quot;</span>, <span class="number">666</span>);</span><br><span class="line">    <span class="comment">//这就是postForLocation，调用该方法返回的是一个Uri,Uri就是重定向的地址（里面包含重定向的参数），拿到Uri之后，就可以直接发送新的请求了</span></span><br><span class="line">    URI uri = restTemplate.postForLocation(<span class="string">&quot;http://provider/register&quot;</span>, map);</span><br><span class="line">    String s = restTemplate.getForObject(uri, String.class);</span><br><span class="line">    System.out.println(s);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-PUT"><a href="#3-PUT" class="headerlink" title="3.PUT"></a>3.PUT</h3><p> 首先在 provider 提供一个 put 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/user11&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser1</span><span class="params">(User user1)</span></span>&#123; <span class="comment">//k/v形式</span></span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@PutMapping(&quot;/user12&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser2</span><span class="params">(<span class="meta">@RequestBody</span> User user2)</span></span>&#123; <span class="comment">//json形式</span></span><br><span class="line">    System.out.println(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 consumer 中调用该接口，和上面 post 类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello8&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;javajava&quot;</span>);</span><br><span class="line">    map.add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    map.add(<span class="string">&quot;id&quot;</span>, <span class="number">666</span>);</span><br><span class="line">    restTemplate.put(<span class="string">&quot;http://provider/user11&quot;</span>,map);</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">98</span>);</span><br><span class="line">    user.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    restTemplate.put(<span class="string">&quot;http://provider/user12&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-DELETE"><a href="#4-DELETE" class="headerlink" title="4.DELETE"></a>4.DELETE</h3><p> 首先在 provider 提供一个 delete 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/user13&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser1</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/user14/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 consumer 中调用这两个删除接口 (delete 中参数的传递，也支持 map，这块实际上和 get 是一样的)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello9&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restTemplate.delete(<span class="string">&quot;http://provider/user13?id=&#123;1&#125;&quot;</span>,<span class="number">99</span>);</span><br><span class="line">    restTemplate.delete(<span class="string">&quot;http://provider/user14/&#123;1&#125;&quot;</span>,<span class="number">99</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 示例代码地址：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot + RabbitMQ 简单案例 (exchange的四种类型)</title>
    <url>/2019/09/08/Spring%20Boot%20+%20RabbitMQ%20%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%20(exchange%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B)-Spring%20Boot%20+%20RabbitMQ%20%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%20(exchange%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B)/</url>
    <content><![CDATA[<p>项目已上传至 <a href="https://github.com/astronger/Springboot-rabbitmq">GitHub</a>！</p>
<p>首先 <a href="https://blog.csdn.net/ourstronger/article/details/100764478">Docker一键安装RabbitMQ</a>，然后启动项目，在测试类依次测试，rabbitmq管理页面和控制台均能看到测试结果。</p>
]]></content>
      <categories>
        <category>Docker | RabbitMQ</category>
      </categories>
      <tags>
        <tag>Docker | RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot + security 动态权限配置简单案例</title>
    <url>/2019/06/20/Spring%20Boot%20+%20security%20%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B-Spring%20Boot%20+%20security%20%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>项目已上传至 ：<a href="https://github.com/astronger/securitydy">https://github.com/astronger/securitydy</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot ——devtools 热部署的几种方式（详细）</title>
    <url>/2019/06/10/Spring%20Boot%20%E2%80%94%E2%80%94devtools%20%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89-Spring%20Boot%20%E2%80%94%E2%80%94devtools%20%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89/</url>
    <content><![CDATA[<h2 id="（一）方法一"><a href="#（一）方法一" class="headerlink" title="（一）方法一"></a>（一）方法一</h2><p>添加DevTools依赖：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-fd89c63e16a54b6c8e5763c721fd1d26.png" alt="image.png"></p>
<p>pom依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">              <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span><span class="comment">&lt;!-- optional=true,依赖不会传递，该项目依赖devtools；之后依赖myboot项目的项目如果想要使用devtools，需要重新引入 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>当配置了 devtools 后，我们在classpath修改任何文件项目都将会自动重启。</strong></p>
<p>当我们再次启动项目的时候，使用的加载器就变为了 restartedMain 了，说明热部署已经成功。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-ff6b876d68e843e29cd5204ec7b96aab.png" alt="image.png"></p>
<p>当然 IDEA默认是不会去帮你自动编译的，需要打开Settings，选择Compiler，开启自动编译。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-70c8f8d815ed41eca7bbd4d7933b81e2.png" alt="image.png"></p>
<p>然后Ctrl+Shift+Alt+/，选择Registry</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-b610c41ea42146c4bc95d34dfe460fc6.png" alt="image.png"></p>
<p>compiler.automake.allow.when.app.running后面的勾也需要打上。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-fa35564f27c1437db7e5b41350bfa4ce.png" alt="image.png"></p>
<p>至此，IDEA中SpringBoot集成DevTools实现热部署也实现了。DevTools会监听classpath下的文件变动，并且会在保存文件时立即重启应用。但是这样实时跟进修改的会影响电脑性能，意义也不大，除非你的电脑配置高。</p>
<h2 id="（二）方法二"><a href="#（二）方法二" class="headerlink" title="（二）方法二"></a>（二）方法二</h2><p>还有一种方式可以跟进热部署，我们可以在application.properties中配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.devtools.restart.trigger-file=.trigger-file  <span class="comment">//.trigger-file随便起的名字</span></span><br></pre></td></tr></table></figure>
<p>在resources文件夹新建 <strong>.trigger-file</strong> 文件，然后每次当你想重新启动的时候，就去改动一下.trigger-file文件内容即可（内容可随意修改），修改完后项目就会自动重启，<strong>否则</strong>无论修改多少文件都不会重启，效率比较高点。</p>
<h2 id="（三）全局配置"><a href="#（三）全局配置" class="headerlink" title="（三）全局配置"></a>（三）全局配置</h2><p>如果你的项目中有很多个spring boot模块，特别是做微服务的话，那么此时可以进行全局配置来控制自动重启的问题。如何解决呢？</p>
<p>先在系统用户目录下创建文件，命名为：**.spring-boot-devtools.properties**</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-f41401015b68448892380fd0c088984b.png" alt="image.png"></p>
<p>打开文件写入: spring.devtools.restart.trigger-file=.trigger-file </p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-74d3d15e5b7c4e9d999e17b7fd0c5dfd.png" alt="image.png"></p>
<p>和之前一样，resources文件夹下创建 .trigger-file文件，此处的.trigger-file要和刚才创建的文件内容一样，均使用.trigger-file</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-3a9d016d961544c881cb8a53366f343b.png" alt="image.png"></p>
<p>然后就可以了，重启项目，修改代码内容后在.trigger-file文件内输入内容后项目就会自动重启，原理和上面一样。</p>
<p><em><strong>这个全局的配置对于当前电脑上任何使用devtools模块的spring boot项目都有效。</strong></em></p>
<h2 id="（四）禁用热部署（禁用自动重启）"><a href="#（四）禁用热部署（禁用自动重启）" class="headerlink" title="（四）禁用热部署（禁用自动重启）"></a>（四）禁用热部署（禁用自动重启）</h2><p>如果使用过程中不想项目自动重启，并且还配置了devtools依赖不想删掉，怎么办呢？</p>
<p>只需在application.properties中添加一行配置即可，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-69b12b1c39e44683936f1bfcf19f0930.png" alt="image.png"></p>
<p>或者修改启动类的配置，如下图，和上面的原理一样，两种方式都行：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-cb9b83ea275f40a9867b69dd9fa78646.png" alt="image.png"></p>
<p>配置完后，重新启动项目，修改文件后，项目就不会自动重启了。</p>
<h3 id="另外："><a href="#另外：" class="headerlink" title="另外："></a>另外：</h3><p>（1）某些资源在更改时不一定需要触发重新启动。例如, Thymeleaf 模板可以就地进行编辑。默认情况下更改资源路径包括了：/META-INF/maven, /META-INF/resources ,/resources ,/static ,/public 或者 /templates 不会触发重新启动, 但会触发实时重新加载。</p>
<p>如果逆向排除这些路径，可以使用如下配置，<strong>也就是说以下的文件目录如果有改动将会触发重启：</strong></p>
<p>spring.devtools.restart.exclude=classpath:/static/<strong>,public/</strong></p>
<p>　　（2）如果要保留这些默认值并添加其他排除项, 请使用 spring.devtools.restart.additional-exclude 属性代替。</p>
<p>　　（3）通过 System.setProperty(“spring.devtools.restart.enabled”, “false”); 方法，可以在SpringApplication.run()方法运行天使用关闭 devtools。</p>
<p>注意点：devtools 由于是双类加载机制，再结合了通用Mapper后可能会出现 java.lang.ClassCastException 异常(例如：说class x.x.A cannot be cast to x.x.A。)。</p>
<p>　　<strong>解决方案就如下：</strong></p>
<p>　　在 src/main/resources 中创建 META-INF 目录，在此目录下添加 spring-devtools.properties 配置，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">　　restart.include.mapper=/mapper-[\\w-\\.]+jar</span><br><span class="line">　　restart.include.pagehelper=/pagehelper-[\\w-\\.]+jar</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot ——session 共享， Nginx（负载均衡）</title>
    <url>/2019/06/04/Spring%20Boot%20%E2%80%94%E2%80%94session%20%E5%85%B1%E4%BA%AB%EF%BC%8C%20Nginx%EF%BC%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%89-Spring%20Boot%20%E2%80%94%E2%80%94session%20%E5%85%B1%E4%BA%AB%EF%BC%8C%20Nginx%EF%BC%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%89/</url>
    <content><![CDATA[<p>在传统的单服务架构中，一般来说，只有一个服务器，那么不存在 Session 共享问题，但是在分布式/集群项目中，Session 共享则是一个必须面对的问题，先看一个简单的架构图：<br><img src="https://www.itmengtao.cn/upload/2020/10/image-5aa20968946442b6b81b7ddf171ff05b.png" alt="image.png"></p>
<p>在这样的架构中，会出现一些单服务中不存在的问题，例如客户端发起一个请求，这个请求到达 Nginx 上之后，被 Nginx 转发到 Tomcat A 上，然后在 Tomcat A 上往 session 中保存了一份数据，下次又来一个请求，这个请求被转发到 Tomcat B 上，此时再去 Session 中获取数据，发现没有之前的数据。对于这一类问题的解决，思路很简单，就是将各个服务之间需要共享的数据，保存到一个公共的地方（主流方案就是 Redis）：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-d21bcc5ba00d43c18be6451085809c95.png" alt="image.png"></p>
<p>当所有 Tomcat 需要往 Session 中写数据时，都往 Redis 中写，当所有 Tomcat 需要读数据时，都从 Redis 中读。这样，不同的服务就可以使用相同的 Session 数据了。</p>
<p>这样的方案，可以由开发者手动实现，即手动往 Redis 中存储数据，手动从 Redis 中读取数据，相当于使用一些 Redis 客户端工具来实现这样的功能，毫无疑问，手动实现工作量还是蛮大的。</p>
<p>一个简化的方案就是使用 Spring Session 来实现这一功能，Spring Session 就是使用 Spring 中的代理过滤器，将所有的 Session 操作拦截下来，自动的将数据 同步到 Redis 中，或者自动的从 Redis 中读取数据。</p>
<p>对于开发者来说，所有关于 Session 同步的操作都是透明的，开发者使用 Spring Session，一旦配置完成后，具体的用法就像使用一个普通的 Session 一样。</p>
<h3 id="1-、创建工程"><a href="#1-、创建工程" class="headerlink" title="1 、创建工程"></a>1 、创建工程</h3><p>  创建一个 Spring Boot 工程，引入 Web、Spring Session 以及 Redis:</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-89615856f4c24aab95d7657277b9ae7f.png" alt="image.png"></p>
<p>pom.xml 文件如下，此处要注意添加 Spring Security 依赖，具体上一文已经说明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、配置-Redis"><a href="#2、配置-Redis" class="headerlink" title="2、配置 Redis"></a>2、配置 Redis</h3><p>在application.properties文件中配置Redis 的基本信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.redis.host=192.168.1.132</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=123456</span><br><span class="line">spring.redis.database=0</span><br><span class="line"> </span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure>
<h3 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h3><p>配置完成后 ，就可以使用 Spring Session 了，其实就是使用普通的 HttpSession ，其他的 Session 同步到 Redis 等操作，框架已经自动帮你完成了，举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    Integer port;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ni hao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(port);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String)session.getAttribute(<span class="string">&quot;name&quot;</span>))+port;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到一会 Spring Boot 将以集群的方式启动 ，为了获取每一个请求到底是哪一个 Spring Boot 提供的服务，需要在每次请求时返回当前服务的端口号，因此这里注入了 server.port 。 </p>
<p>接下来 ，项目打包：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-e84dfb008c5e4049984b041781575c24.png" alt="image.png"></p>
<p>打包之后，进入target 目录，启动项目的两个实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">java -jar sessionexample-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line">java -jar sessionexample-0.0.1-SNAPSHOT.jar --server.port=8081</span><br></pre></td></tr></table></figure>
<p>启动成功后，先访问 localhost:8080/set 向 8080 这个服务的 Session 中保存一个变量，访问完成后，数据就已经自动同步到 Redis 中 了 ：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-2fc8e6d2d8d343c38825ebda7ac458bb.png" alt="image.png"></p>
<p>然后，再调用 localhost:8081/get 接口，就可以获取到 8080 服务的 session 中的数据：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-7aa148a6f2d74e9883327d05027538d7.png" alt="image.png"></p>
<p>此时关于 session 共享的配置就已经全部完成了，session 共享的效果我们已经看到了，但是每次访问都是我自己手动切换服务实例，因此，接下来我们来引入 Nginx ，实现服务实例自动切换。</p>
<h3 id="4、引入-Nginx（负载均衡）"><a href="#4、引入-Nginx（负载均衡）" class="headerlink" title="4、引入 Nginx（负载均衡）"></a>4、引入 Nginx（负载均衡）</h3><p>进入 Nginx 的安装目录的 conf 目录下（默认是在 /usr/local/nginx/conf），编辑 nginx.conf 文件:</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-36f0ffeb4b274681adc9bd72acf2cd93.png" alt="image.png"></p>
<p>在这段配置中：</p>
<ol>
<li>upstream 表示配置上游服务器，里边配置的是一个个的单独服务。</li>
<li>taoge 表示服务器集群的名字，这个可以随意取名字。</li>
<li>weight 表示服务的权重，意味者将有多少比例的请求从 Nginx 上转发到该服务上。</li>
<li>location 中的 proxy_pass 表示请求转发的地址，/ 表示拦截到所有的请求，转发到刚才配置好的服务集群中。</li>
<li>proxy_redirect 表示设置当发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址，我们需要将之修改使之成为 Nginx 的地址）。</li>
</ol>
<p>配置完成后，将本地的 Spring Boot 打包好的 jar 上传到 Linux ，然后在 Linux 上分别启动两个 Spring Boot 实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080 &amp;</span><br><span class="line">nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081 &amp;</span><br></pre></td></tr></table></figure>
<p>配置完成后，重启 Nginx：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
<p> Nginx 启动成功后，我们首先手动清除 Redis 上的数据，然后访问 192.168.1.132/set 表示向 session 中保存数据，这个请求首先会到达 Nginx 上，再由 Nginx 转发给某一个 Spring Boot 实例：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-b3f455cda8a346f29dae3d8f9868f63a.png" alt="image.png"></p>
<p>上图表示端口为 8081 的 Spring Boot 处理了这个 /set 请求，再访问 /get 请求：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-48a6dff2f182494c822ba15e7ac05159.png" alt="image.png"></p>
<p>/get 请求是被端口为 8080 的服务所处理的。</p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>在 SSM 架构中，Spring Session 的使用要配置三个地方 ，一个是 web.xml 配置代理过滤器，然后在 Spring 容器中配置 Redis，最后再配置 Spring Session，步骤还是有些繁琐的，而 Spring Boot 中直接帮我们省去了这些繁琐的步骤！不用再去配置 Spring Session，引入了 Spring Session 的依赖就行！</p>
]]></content>
      <categories>
        <category>Spring Boot | Nginx</category>
      </categories>
      <tags>
        <tag>Spring Boot | Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 入门—— parent</title>
    <url>/2019/04/06/Spring%20Boot%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%20parent-Spring%20Boot%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%20parent/</url>
    <content><![CDATA[<p>创建好一个Spring Boot项目后，会看到pom文件中下面这个依赖。这里的含义不仅仅是依赖的版本号定义在 parent里。还有其它的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       &lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">2.1</span><span class="number">.6</span>.RELEASE&lt;/version&gt;</span><br><span class="line">	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>

<p>基本功能<br>当我们创建一个 Spring Boot 工程时，可以继承自一个 spring-boot-starter-parent ， parent 的基本功能有哪些？</p>
<ol>
<li>定义了 Java 编译版本为 1.8 。</li>
<li>使用 UTF-8 格式编码。</li>
<li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li>
<li>执行打包操作的配置。</li>
<li>自动化的资源过滤。</li>
<li>自动化的插件配置。</li>
<li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li>
</ol>
<p><strong>请注意，由于application.properties和application.yml文件接受Spring样式占位符 $ {…} ，因此 Maven 过滤更改为使用 @ .. @ 占位符，当然开发者可以通过设置名为 resource.delimiter 的Maven 属性来覆盖 @ .. @ 占位符。</strong></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>当我们创建一个 Spring Boot 项目后，我们可以在本地 Maven 仓库中看到看到这个具体的 parent 文件，以 2.1.4 这个版本为例，这里的路径是 C:\Users\sang.m2\repository\org\springframework\boot\spring-boot-starter-parent\2.1.4.RELEASE\spring-boot-starter-parent-2.1.4.RELEASE.pom ,<br>打开这个文件，快速阅读文件源码，基本上就可以证实我们前面说的功能，如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-3aad18b8a3d343399b12fd5b33bb22c3.png" alt="image.png"></p>
<p>我们可以看到，它继承自 spring-boot-dependencies ，这里保存了基本的依赖信息，另外我们也可以看到项目的编码格式，JDK 的版本等信息，当然也有我们前面提到的数据过滤信息。最后，我们再根据它的 parent 中指定的 spring-boot-dependencies 位置，来看看 spring-boot-dependencies 中的定义：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-365536e0b2ce479bb0254ba0d975ad9b.png" alt="image.png"></p>
<p>我们看到了版本的定义以及 dependencyManagement 节点，明白了为啥 Spring Boot 项目中部分依赖不需要写版本号了。</p>
<h2 id="不用-parent"><a href="#不用-parent" class="headerlink" title="不用 parent"></a>不用 parent</h2><p>但是并非所有的公司都需要这个 parent ，有的时候，公司里边会有自己定义的 parent ，我们的 Spring Boot 项目要继承自公司内部的 parent ，这个时候该怎么办呢？</p>
<p>一个简单的办法就是我们自行定义 dependencyManagement 节点，然后在里边定义好版本号，再接下来在引用依赖时也就不用写版本号了，像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;<span class="number">2.1</span><span class="number">.4</span>.RELEASE&lt;/version&gt;</span><br><span class="line">			&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">			&lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
<p>这样写之后，依赖的版本号问题虽然解决了，但是关于打包的插件、编译的 JDK 版本、文件的编码格式等等这些配置，在没有 parent 的时候，这些统统要自己去配置。</p>
<p>摘自：<a href="http://springboot.javaboy.org/2019/0413/spring-boot-parent">http://springboot.javaboy.org/2019/0413/spring-boot-parent</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 多文件上传亲测</title>
    <url>/2020/05/27/Spring%20Boot%20%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BA%B2%E6%B5%8B-Spring%20Boot%20%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BA%B2%E6%B5%8B/</url>
    <content><![CDATA[<p>话不多说，直接上代码：</p>
<h3 id="1、HTML"><a href="#1、HTML" class="headerlink" title="1、HTML"></a>1、HTML</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label class=&quot;col-sm-3 control-label is-required&quot;&gt;多文件上传：&lt;/label&gt;</span><br><span class="line">        &lt;div class=&quot;col-sm-8&quot;&gt;</span><br><span class="line">           &lt;input type=&quot;file&quot; name=&quot;md&quot; id=&quot;article_md&quot; multiple=&quot;multiple&quot; required&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2、JS"><a href="#2、JS" class="headerlink" title="2、JS"></a>2、JS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 上传多文件 */</span><br><span class="line"> function submitHandler() &#123;</span><br><span class="line">     var files = $(&quot;#article_md&quot;)[0].files;</span><br><span class="line">     var formData = new FormData();</span><br><span class="line">     for (let file of files) &#123;</span><br><span class="line">         //将文件属性放入formdata里面，不能直接使用 formData.append(&quot;files&quot;,files）</span><br><span class="line">         formData.append(&quot;files&quot;,file,file.name);</span><br><span class="line">     &#125;</span><br><span class="line">     $.ajax(&#123;</span><br><span class="line">         url: prefix + &quot;/upload&quot;,</span><br><span class="line">         type: &#x27;post&#x27;,</span><br><span class="line">         async: false,</span><br><span class="line">         data: formData,</span><br><span class="line">         processData: false,</span><br><span class="line">         contentType: false,</span><br><span class="line">         success: function(result) &#123;</span><br><span class="line">             $.operate.successCallback(result);</span><br><span class="line">         &#125;,</span><br><span class="line">     &#125;)</span><br><span class="line"> </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p> 3、Java后台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult <span class="title">addFile</span><span class="params">(<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(MultipartFile fileData : files) &#123;</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            sysBusinessService.doUploadReturnContract(fileData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.success(<span class="string">&quot;上传成功！&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot—— 整合Redis增删改查（极简）</title>
    <url>/2019/05/30/Spring%20Boot%E2%80%94%E2%80%94%20%E6%95%B4%E5%90%88Redis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89-Spring%20Boot%E2%80%94%E2%80%94%20%E6%95%B4%E5%90%88Redis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89/</url>
    <content><![CDATA[<p>在传统的 SSM 中，需要开发者自己来配置 Spring Data Redis ，这个配置比较繁琐，主要配置 3 个东西：连接池、连接器信息以及 key 和 value 的序列化方案。</p>
<p>在 Spring Boot 中，经过Spring Boot的整合封装与自动化配置，在Spring Boot中整合Redis已经变得非常容易了，开发者只需要引入Spring Data Redis依赖，然后简单配下redis的基本信息，系统就会提供一个RedisTemplate供开发者使用。默认集成的 Redis 就是 Spring Data Redis，默认底层的连接池使用了 lettuce ，开发者可以自行修改为自己的熟悉的，例如 Jedis，只需修改依赖即可。</p>
<p>在Spring Boot 2.1.5之后包括2.1.5，远程访问Redis必须引入Spring security。</p>
<p>创建工程<br>1、首先去redis根目录打开Redis，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-4.0.6]# redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p>2、接着输入密码，并清空：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-4.0.6]# redis-cli -a 123456 //输入密码</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG  </span><br><span class="line">127.0.0.1:6379&gt; keys *      </span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; FLUSHALL   //清空</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; KEYS *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>
<p>3、创建工程，引入 Redis 依赖：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-a3bfe4de3c634e10a6e42a566a72aefb.png" alt="image.png"></p>
<p> 最终完整的 pom.xml 依赖如下，默认底层的连接池使用了 lettuce：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      &lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>配置 Redis 信息<br>在application.properties文件中配置Redis 的基本信息和连接池信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.redis.host=192.168.1.132</span><br><span class="line">spring.redis.database=0</span><br><span class="line">spring.redis.password=123456</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br><span class="line"> </span><br><span class="line">spring.redis.lettuce.pool.min-idle=5</span><br><span class="line">spring.redis.lettuce.pool.max-idle=10</span><br><span class="line">spring.redis.lettuce.pool.max-active=8</span><br><span class="line">spring.redis.lettuce.pool.max-wait=1ms</span><br><span class="line">spring.redis.lettuce.shutdown-timeout=100ms</span><br></pre></td></tr></table></figure>
<p>自动配置<br>当开发者在项目中引入了 Spring Data Redis ，并且配置了 Redis 的基本信息，此时，自动化配置就会生效。</p>
<p>我们从 Spring Boot 中 Redis 的自动化配置类中就可以看出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        RedisTemplate template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先标记这个是一个配置类，同时该配置在 RedisOperations 存在的情况下才会生效(即项目中引入了 Spring Data Redis)<br>然后导入在 application.properties 中配置的属性<br>然后再导入连接池信息（如果存在的话）<br>最后，提供了两个 Bean ，RedisTemplate 和 StringRedisTemplate ，其中 StringRedisTemplate 是 RedisTemplate 的子类，两个的方法基本一致，不同之处主要体现在操作的数据类型不同，RedisTemplate 中的两个泛型都是 Object ，意味者存储的 key 和 value 都可以是一个对象，而 StringRedisTemplate 的 两个泛型都是 String ，意味者 StringRedisTemplate 的 key 和 value 都只能是字符串。如果开发者没有提供相关的 Bean ，这两个配置就会生效，否则不会生效。<br>测试使用<br> 创建测试Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//注入</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        ops.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        System.out.println(ops.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后启动项目，由于项目引入了Spring security， 所有接口已经被保护起来了，此时访问 localhost:8080/set 接口，会跳转至一个登录窗口，如下图：</p>
<p>这里的用户名默认是user，密码是是此时控制台打印的如下图，粘贴过来即可：</p>
<p>登陆成功后，我们来看一下Redis，如下：</p>
<p>然后继续访问localhost:8080/get 接口，控制台会打印出get到的值，如下：</p>
<p>好了，现在测试OK，试一下CRUD.</p>
<p>增删改查<br>1.首先编写Redis操作工具类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.redis;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis操作工具类</span></span><br><span class="line"><span class="comment"> * 基于RedisTemplate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 读取缓存</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 写入缓存</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, String value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			redisTemplate.opsForValue().set(key, value);</span><br><span class="line">			result = <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 更新缓存</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">final</span> String key, String value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">			result = <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除缓存</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			redisTemplate.delete(key);</span><br><span class="line">			result = <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.然后就可以直接在service中通过RedisTemplate操作redis，使用redis进行缓存数据库查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Autowired</span>   <span class="comment">//注入刚才的工具类</span></span><br><span class="line"> RedisUtils redisUtils;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getAllMenus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 从redis缓存中提取数据</span></span><br><span class="line">        String allMenus = redisUtils.get(<span class="string">&quot;AllMenus&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果没有，则从数据库中查询并放入缓存中</span></span><br><span class="line">        <span class="keyword">if</span>(allMenus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            redisUtils.set(<span class="string">&quot;AllMenus&quot;</span>, String.valueOf(menuMapper.getAllMenus()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getAllMenus();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> article</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Article article)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 删除redis中的缓存</span></span><br><span class="line">	redisUtils.delete(<span class="string">&quot;article_&quot;</span> + article.getId());</span><br><span class="line">	<span class="comment">// 修改操作</span></span><br><span class="line">	articleMapper.save(article);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 删除redis缓存数据</span></span><br><span class="line">	redisUtils.delete(<span class="string">&quot;article_&quot;</span> + id);</span><br><span class="line">	<span class="comment">// 删除操作</span></span><br><span class="line">	articleMapper.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完了，就这么简单，快去试试吧！</p>
<p>另外，还可以通过Spring Cache的形式来操作Redis，具体请移步至：Spring Boot中，Spring Cache + Redis</p>
]]></content>
      <categories>
        <category>Spring Boot | Redis</category>
      </categories>
      <tags>
        <tag>Spring Boot | Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——Banner自定义配置</title>
    <url>/2019/04/08/Spring%20Boot%E2%80%94%E2%80%94Banner%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE-Spring%20Boot%E2%80%94%E2%80%94Banner%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>我们在启动 SpringBoot 时，控制台会打印 SpringBoot Logo 以及版本信息；如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-153ebcfbe4ee4932a4e53f5c9286640f.png" alt="image.png"></p>
<p>这个SpringBoot Logo其实是可以自定义的，默认是就是上图那样，如果大家想 ZB，那就可以去<a href="%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99">这个网站</a>只做自己想要的。</p>
<p>我简单举例：<br><img src="https://www.itmengtao.cn/upload/2020/8/image-fc62e6ab55834b30aef0da2f45b300ed.png" alt="image.png"></p>
<p>生成效果图之后，点击Select &amp; Copy</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-3c9a05206d0f4b179cdf145465591257.png" alt="image.png"></p>
<p>Copy 完成后，在Spring Boot项目的resources 文件夹下创建 banner.txt 文件，将刚才复制的粘进去就OK，然后重启项目就可以看到你的作品了。快去试试吧。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——LiveReload 实现静态文件的热部署</title>
    <url>/2019/06/20/Spring%20Boot%E2%80%94%E2%80%94LiveReload%20%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2-Spring%20Boot%E2%80%94%E2%80%94LiveReload%20%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>利用 LiveReload 可以实现静态文件的热部署，LiveReload 可以在资源发生变化时自动触发浏览器更新，LiveReload 支持 Chrome、Firefox 以及 Safari 。以 Chrome 为例，在 Chrome 应用商店搜索 LiveReload ，结果如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-93b5de85f02e4f518e24e4deb7fdc15c.png" alt="image.png"></p>
<p>添加成功后，在 Chrome 右上角有一个 LiveReload 图标，如下：<br><img src="https://www.itmengtao.cn/upload/2020/10/image-929b577077b74f9ba950f1e847e05d74.png" alt="image.png"></p>
<p>打开 LiveReload 之后，我们启动一个加了 devtools 依赖的 Spring Boot 项目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;optional&gt;<span class="keyword">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>点击浏览器右上角的 LiveReload 按钮，打开 LiveReload 功能。此时<strong>对于谷歌浏览器来说，只是对当前打开的标签页有效，新的标签页无效。</strong></p>
<p>此时随便在 resources/static 目录下添加一个静态 html 页面，然后启动 Spring Boot 项目，在<strong>打开了 LiveReload 的选项卡中访问 html 页面</strong>。访问成功后，我们再去手动修改 html 页面代码，修改成功后，回到浏览器，不用做任何操作，就会发现浏览器自动刷新了，页面已经更新了。整个过程中，Spring Boot 项目不用重启。</p>
<p>如果开发者安装并且启动了 LiveReload 插件，同时也添加了 devtools 依赖，但是却并不想当静态页面发生变化时浏览器自动刷新，那么可以在 application.properties 中添加如下代码进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.devtools.livereload.enabled=false</span><br></pre></td></tr></table></figure>
<p>建议开发者使用 LiveReload 策略而不是项目重启策略来实现静态资源的动态加载，因为项目重启所耗费时间一般来说要超过使用LiveReload 所耗费的时间。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——Profile</title>
    <url>/2019/04/18/Spring%20Boot%E2%80%94%E2%80%94Profile-Spring%20Boot%E2%80%94%E2%80%94Profile/</url>
    <content><![CDATA[<p>Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速的切换环境。环境比如平常的开发环境、测试环境、生产环境等。<br>默认使用<strong>application.properties</strong>的配置 ，我们可以配置多个profile文件对不同的环境进行切换，</p>
<p>格式为：<strong>application-{profile}.properties/yml。</strong></p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-ae65314c51af43b7898b7d5d9dd268ff.png" alt="image.png"></p>
<p>然后在主配置文件<strong>application.properties</strong>中激活就OK了，可根据实际情况切换。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-6bd7e78e80c14a38bafe3f1dfa1ee76a.png" alt="image.png"></p>
<h2 id="yml多文档快方式"><a href="#yml多文档快方式" class="headerlink" title="yml多文档快方式"></a>yml多文档快方式</h2><p>  通过<strong>activeb</strong>方式激活 ，如图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-0cdd35fa76cd493f86380d69652516d4.png" alt="image.png"></p>
<p><strong>激活指定的profile即可</strong>。</p>
<h2 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h2><p>在idea中指定测试的时候，传入命令行参数   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–spring.profiles.active=dev</span><br></pre></td></tr></table></figure>

<p><img src="https://www.itmengtao.cn/upload/2020/8/image-9de9bc88e06a43a186475818c132b327.png" alt="image.png"></p>
<h2 id="用命令行执行"><a href="#用命令行执行" class="headerlink" title="用命令行执行"></a>用命令行执行</h2><p>  打包完成，指定配置文件运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——YAML快速入门</title>
    <url>/2019/09/22/Spring%20Boot%E2%80%94%E2%80%94YAML%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-Spring%20Boot%E2%80%94%E2%80%94YAML%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>在Springboot中，推荐使用properties或者YAML文件来完成配置，但是对于较复杂的数据结构来说，YAML又远远优于properties。本文就快速介绍YAML的常见语法格式。</p>
<p>先来看一个Springboot中的properties文件和对应YAML文件的对比：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#properties格式:</span><br><span class="line"> </span><br><span class="line">environments.dev.url=http://dev.bar.com</span><br><span class="line">environments.dev.name=Developer Setup</span><br><span class="line">environments.prod.url=http://foo.bar.com</span><br><span class="line">environments.prod.name=My Cool App</span><br><span class="line">my.servers[0]=dev.bar.com</span><br><span class="line">my.servers[1]=foo.bar.com</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#YAML格式</span><br><span class="line">environments:</span><br><span class="line">    dev:</span><br><span class="line">        url: http://dev.bar.com</span><br><span class="line">        name: Developer Setup</span><br><span class="line">    prod:</span><br><span class="line">        url: http://foo.bar.com</span><br><span class="line">        name: My Cool App</span><br><span class="line">my:</span><br><span class="line">    servers:</span><br><span class="line">        - dev.bar.com</span><br><span class="line">        - foo.bar.com</span><br></pre></td></tr></table></figure>

<p>可以直观的看到，YAML使用冒号加缩进的方式代表层级（属性）关系，使用短横杠(-)代表数组元素，在处理层级关系的时候，YAML格式文件就简单很多。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>下面立刻展示YAML最基本，最常用的一些使用格式：<br>首先YAML中允许表示三种格式，分别是<strong>常量值，对象和数组</strong><br>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#即表示url属性值；</span><br><span class="line">url: http://www.wolfcode.cn </span><br><span class="line">#即表示server.host属性的值；</span><br><span class="line">server:</span><br><span class="line">    host: http://www.wolfcode.cn </span><br><span class="line">#数组，即表示server为[a,b,c]</span><br><span class="line">server:</span><br><span class="line">    - 120.168.117.21</span><br><span class="line">    - 120.168.117.22</span><br><span class="line">    - 120.168.117.23</span><br><span class="line">#常量</span><br><span class="line">pi: 3.14   #定义一个数值3.14</span><br><span class="line">hasChild: true  #定义一个boolean值</span><br><span class="line">name: &#x27;你好YAML&#x27;   #定义一个字符串</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<p>和properties相同，使用#作为注释，YAML中只有行注释。</p>
<p>基本<strong>格式</strong>要求</p>
<ol>
<li>YAML大小写敏感；</li>
<li>使用缩进代表层级关系；</li>
<li>缩进只能使用空格，不能使用TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格）</li>
</ol>
<p><strong>对象</strong>:</p>
<p>使用冒号代表，格式为key: value。冒号后面要加一个空格：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">key: value</span><br></pre></td></tr></table></figure>
<p>可以使用缩进表示层级关系；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">key: </span><br><span class="line">    child-key: value</span><br><span class="line">    child-key2: value2</span><br></pre></td></tr></table></figure>
<p>YAML中还支持流式(flow)语法表示对象，比如上面例子可以写为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">key: &#123;child-key: value, child-key2: value2&#125;</span><br></pre></td></tr></table></figure>
<p>较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的key，配合一个冒号加一个空格代表一个value：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">?  </span><br><span class="line">    - complexkey1</span><br><span class="line">    - complexkey2</span><br><span class="line">:</span><br><span class="line">    - complexvalue1</span><br><span class="line">    - complexvalue2</span><br></pre></td></tr></table></figure>

<p>意思即对象的属性是一个数组[complexkey1,complexkey2]，对应的值也是一个数组[complexvalue1,complexvalue2]</p>
<p><strong>数组</strong>：</p>
<p>使用一个短横线加一个空格代表一个数组项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">hobby:</span><br><span class="line">    - Java</span><br><span class="line">    - LOL</span><br></pre></td></tr></table></figure>

<p>当然也可以有这样的写法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line">    - Java</span><br><span class="line">    - LOL</span><br></pre></td></tr></table></figure>

<p>可以简单理解为：[[Java,LOL]]<br>一个相对复杂的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">companies:</span><br><span class="line">    -</span><br><span class="line">        id: 1</span><br><span class="line">        name: company1</span><br><span class="line">        price: 200W</span><br><span class="line">    -</span><br><span class="line">        id: 2</span><br><span class="line">        name: company2</span><br><span class="line">        price: 500W</span><br></pre></td></tr></table></figure>
<p>意思是companies属性是一个数组，每一个数组元素又是由id,name,price三个属性构成；<br>数组也可以使用流式(flow)的方式表示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">companies: [&#123;id: 1,name: company1,price: 200W&#125;,&#123;id: 2,name: company2,price: 500W&#125;]</span><br></pre></td></tr></table></figure>
<p><strong>常量</strong>：</p>
<p>YAML中提供了多种常量结构，包括：整数，浮点数，字符串，NULL，日期，布尔，时间。下面使用一个例子来快速了解常量的基本使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">boolean: </span><br><span class="line">    - TRUE  #true,True都可以</span><br><span class="line">    - FALSE  #false，False都可以</span><br><span class="line">float:</span><br><span class="line">    - 3.14</span><br><span class="line">    - 6.8523015e+5  #可以使用科学计数法</span><br><span class="line">int:</span><br><span class="line">    - 123</span><br><span class="line">    - 0b1010_0111_0100_1010_1110    #二进制表示</span><br><span class="line">null:</span><br><span class="line">    nodeName: &#x27;node&#x27;</span><br><span class="line">    parent: ~  #使用~表示null</span><br><span class="line">string:</span><br><span class="line">    - 哈哈</span><br><span class="line">    - &#x27;Hello world&#x27;  #可以使用双引号或者单引号包裹特殊字符</span><br><span class="line">    - newline</span><br><span class="line">      newline2    #字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="line">date:</span><br><span class="line">    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="line">datetime: </span><br><span class="line">    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br></pre></td></tr></table></figure>

<p><strong>一些特殊符号</strong>：</p>
<p>YAML中提供了很多特殊符号，在这里简单介绍常用的一些：<br>1，— YAML可以在同一个文件中，使用—表示一个文档的开始；比如Springboot中profile的定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    address: 192.168.1.100</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">    profiles: development</span><br><span class="line">    server:</span><br><span class="line">        address: 127.0.0.1</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">    profiles: production</span><br><span class="line">    server:</span><br><span class="line">        address: 192.168.1.120</span><br></pre></td></tr></table></figure>
<p>代表定义了两个profile，一个是development，一个production；也常常使用—来分割不同的内容，比如记录日志：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">Time: 2018-02-17T15:02:31+08:00</span><br><span class="line">User: ed</span><br><span class="line">Warning:</span><br><span class="line">     This is an error message for the log file</span><br><span class="line">---</span><br><span class="line">Time: 2018-02-17T15:05:21+08:00</span><br><span class="line">User: ed</span><br><span class="line">Warning:</span><br><span class="line">    A slightly different error message.</span><br></pre></td></tr></table></figure>
<p>和—配合使用，在一个配置文件中代表一个文件的结束：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">time: 20:03:20</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: strike (miss)</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">time: 20:03:47</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: grand slam</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>相当于在一个yaml文件中连续写了两个yaml配置项。</p>
<p>!! YAML中使用!!做类型强行转换：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">string:</span><br><span class="line">    - !!str 54321</span><br><span class="line">    - !!str true</span><br></pre></td></tr></table></figure>

<p>相当于把数字和布尔类型强转为字符串。当然允许转型的类型很多，比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">--- !!set</span><br><span class="line">- Mark McGwire: 65</span><br><span class="line">- Sammy Sosa: 63</span><br><span class="line">- Sammy Sosa: 63</span><br><span class="line">- Ken Griffy: 58</span><br></pre></td></tr></table></figure>

<p>将数组解析为set，简单理解，转化的内容就是：[{Ken Griffy=58}, {Mark McGwire=65}, {Sammy Sosa=63}]，重复的Sammy Sosa去掉；</p>
<blockquote>
<p>在字符串中折叠换行，| 保留换行符，这两个符号是YAML中字符串经常使用的符号，比如：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">accomplishment: &gt;</span><br><span class="line"> Mark set a major league</span><br><span class="line"> home run record in 1998.</span><br><span class="line">stats: |</span><br><span class="line"> 65 Home Runs</span><br><span class="line"> 0.278 Batting Average</span><br></pre></td></tr></table></figure>
<p>那么结果是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">stats=65 Home Runs</span><br><span class="line"> 0.278 Batting Average,</span><br></pre></td></tr></table></figure>
<p>即| 符号保留了换行符，而accomplishment的结果为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">accomplishment=Mark set a major league home run record in 1998.</span><br></pre></td></tr></table></figure>
<p>即将换行符转化成了空格；要注意一点的是，每行的文本前一定要有一个空格。<br>|符号常见用于在YAML中配置HTML片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">phraseTemplate: |</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span></span><br><span class="line">    some template $&#123;msg&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>5，引用。重复的内容在YAML中可以使用&amp;来完成锚点定义，使用*来完成锚点引用，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">hr:</span><br><span class="line">- Mark McGwire</span><br><span class="line">- &amp;SS Sammy Sosa</span><br><span class="line">rbi:</span><br><span class="line">- *SS </span><br><span class="line">- Ken Griffey</span><br></pre></td></tr></table></figure>

<p>可以看到，在hr中，使用&amp;SS为Sammy Sosa设置了一个锚点（引用），名称为SS，在rbi中，使用*SS完成了锚点使用，那么结果为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;rbi=[Sammy Sosa, Ken Griffey], hr=[Mark McGwire, Sammy Sosa]&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以这样定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SS: &amp;SS Sammy Sosa</span><br><span class="line">hr:</span><br><span class="line"> - Mark McGwire</span><br><span class="line"> - *SS</span><br><span class="line">rbi:</span><br><span class="line"> - *SS </span><br><span class="line"> - Ken Griffey</span><br></pre></td></tr></table></figure>

<p>注意，不能独立的定义锚点，比如不能直接这样写： &amp;SS Sammy Sosa；另外，锚点能够定义更复杂的内容，比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">default: &amp;default</span><br><span class="line">    - Mark McGwire</span><br><span class="line">    - Sammy Sosa</span><br><span class="line">hr: *default</span><br></pre></td></tr></table></figure>
<p>那么hr相当于引用了default的数组，注意，hr: *default要写在同一行。</p>
<p>参考：</p>
<p>JS-YAML在线示例：<a href="http://nodeca.github.io/js-yaml/">http://nodeca.github.io/js-yaml/</a></p>
<p><a href="https://www.jianshu.com/p/97222440cd08">https://www.jianshu.com/p/97222440cd08</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——实现定时任务的两种方式</title>
    <url>/2019/09/12/Spring%20Boot%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-Spring%20Boot%20%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、-Scheduled"><a href="#一、-Scheduled" class="headerlink" title="一、@Scheduled"></a>一、@Scheduled</h2><p>使用 @Scheduled 非常容易，直接创建一个 Spring Boot 项目，并且添加 web 依赖 spring-boot-starter-web，项目创建成功后，在启动类添加 @EnableScheduling 注解，开启定时任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ScheduleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来配置定时任务，新建一个service测试，详细含义已经写在注释里： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 @Scheduled 注解开启一个定时任务，所有时间单位都是毫秒。</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 2000)</span><span class="comment">//前面的任务结束时间和后面任务的开始时间之间间隔2s</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedDelay</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//     System.out.println(&quot;fixedDelay&gt;&gt;&quot;+new Date());//每隔2s打印一次</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 2000)</span><span class="comment">//两次定时任务&quot;开始&quot;的时间间隔为2s (新的任务执行时，不管旧的任务有没有结束)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedRate</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//      System.out.println(&quot;fixedRate&gt;&gt;&quot;+new Date());</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 2000,fixedDelay = 2000)</span><span class="comment">// 表示首次任务启动的延迟时间。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialDelay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;initialDelay&gt;&gt;&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这是一个基本用法，除了这几个基本属性之外，@Scheduled 注解也支持 cron 表达式，使用 cron 表达式，可以非常丰富的描述定时任务的时间。cron 表达式格式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[秒] [分] [小时] [日] [月] [周] [年]</span><br></pre></td></tr></table></figure>
<p>具体取值如下，（**月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ?**）<br><img src="https://www.itmengtao.cn/upload/2020/11/image-dbf091963f5540ddb72250cc366215ab.png" alt="image.png"></p>
<h3 id="通配符含义："><a href="#通配符含义：" class="headerlink" title="通配符含义："></a>通配符含义：</h3><ul>
<li><p>? 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ?</p>
</li>
<li><p>*表示所有值，例如:在秒的字段上设置 *,表示每一秒都会触发</p>
</li>
<li><p>, 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</p>
</li>
<li><p>-表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发</p>
</li>
<li><p>/用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)</p>
</li>
<li><p>#序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了)</p>
</li>
<li><p>周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同</p>
</li>
<li><p>L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五”</p>
</li>
<li><p>W 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)</p>
</li>
<li><p>L 和 W 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )</p>
</li>
</ul>
<p>例如，在 @Scheduled 注解中来一个简单的 cron 表达式，在11时内每隔5秒触发一次，如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron =&quot;0/5 * 11 * * ?&quot;)</span> <span class="comment">//表示在11时内每个5秒发送一次</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cron</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面介绍的是使用 @Scheduled 注解的方式来实现定时任务，接下来我们再来看看如何使用 Quartz 实现定时任务。 </p>
<h2 id="二、Quartz"><a href="#二、Quartz" class="headerlink" title="二、Quartz"></a>二、Quartz</h2><p>一般在项目中，除非定时任务涉及到的业务实在是太简单，使用 @Scheduled 注解来解决定时任务，否则大部分情况可能都是使用 Quartz 来做定时任务。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-ea7003c13c4248e8b3865e233eb5ebcb.png" alt="image.png"></p>
<p>项目创建完成后，需要添加开启定时任务的注解： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(QuartzApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Quartz 在使用过程中，有两个概念，一个是<strong>JobDetail</strong>（要做的事情），另一个是<strong>触发器</strong>（什么时候做），要定义 JobDetail，需要先定义 Job，Job 的定义有两种方式： </p>
<h3 id="第一种方式，直接定义一个Bean："><a href="#第一种方式，直接定义一个Bean：" class="headerlink" title="第一种方式，直接定义一个Bean："></a>第一种方式，直接定义一个Bean：</h3><p>首先将这个 Job 注册到 Spring 容器中。<br>这种定义方式有一个缺陷，就是<strong>无法传参</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//(注册到spring容器中，不支持传参数)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstJob</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first job :&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种定义方式，则是继承-QuartzJobBean-并实现默认的方法，支持传参："><a href="#第二种定义方式，则是继承-QuartzJobBean-并实现默认的方法，支持传参：" class="headerlink" title="第二种定义方式，则是继承 QuartzJobBean 并实现默认的方法，支持传参："></a>第二种定义方式，则是继承 QuartzJobBean 并实现默认的方法，支持传参：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySecondJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务启动时，executeInternal方法将会被执行。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second job :&quot;</span>+name+<span class="string">&quot;:&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Job 有了之后，接下来创建类，配置 JobDetail 和 Trigger 触发器，<strong>JobDetail</strong> 的配置有两种方式：MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean 。如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *MethodInvokingJobDetailFactoryBean配置目标Bean的类名和目标方法的名字，这种方式不支持传参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MethodInvokingJobDetailFactoryBean <span class="title">methodInvokingJobDetailFactoryBean</span><span class="params">()</span></span>&#123; </span><br><span class="line">        MethodInvokingJobDetailFactoryBean bean = <span class="keyword">new</span> MethodInvokingJobDetailFactoryBean();</span><br><span class="line">        bean.setTargetBeanName(<span class="string">&quot;myFirstJob&quot;</span>);</span><br><span class="line">        bean.setTargetMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *JobDetailFactoryBean配置JobDetail，继承自QuartzJobBean ，这种方式支持传参，将参数封装在 JobDataMap中进行传递。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">JobDetailFactoryBean <span class="title">jobDetailFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JobDetailFactoryBean bean = <span class="keyword">new</span> JobDetailFactoryBean();</span><br><span class="line">        JobDataMap map = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;javahello&quot;</span>);<span class="comment">//配置secondjob中的name</span></span><br><span class="line">        bean.setJobDataMap(map);</span><br><span class="line">        bean.setJobClass(MySecondJob.class);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置触发器SimpleTrigger用法</span></span><br><span class="line"><span class="comment">     * 有点类似于前面说的 <span class="doctag">@Scheduled</span> 的基本用法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SimpleTriggerFactoryBean <span class="title">simpleTriggerFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleTriggerFactoryBean bean = <span class="keyword">new</span> SimpleTriggerFactoryBean();</span><br><span class="line">        bean.setJobDetail(methodInvokingJobDetailFactoryBean().getObject());<span class="comment">//绑定第一种方式methodInvokingJobDetailFactoryBean</span></span><br><span class="line">        bean.setStartTime(<span class="keyword">new</span> Date());</span><br><span class="line">        bean.setRepeatInterval(<span class="number">2000</span>); <span class="comment">//重复的时间间隔</span></span><br><span class="line">        bean.setRepeatCount(<span class="number">4</span>); <span class="comment">//重复次数</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置触发器CronTrigger用法</span></span><br><span class="line"><span class="comment">     * 有点类似于 <span class="doctag">@Scheduled</span> 中 cron 表达式的用法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">CronTriggerFactoryBean <span class="title">cronTriggerFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CronTriggerFactoryBean bean = <span class="keyword">new</span> CronTriggerFactoryBean();</span><br><span class="line">        bean.setJobDetail(jobDetailFactoryBean().getObject());</span><br><span class="line">        bean.setCronExpression(<span class="string">&quot;* * * * * ?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动定时任务（注入上面两个Trigger）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SchedulerFactoryBean <span class="title">schedulerFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SchedulerFactoryBean bean = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line">        bean.setTriggers(simpleTriggerFactoryBean().getObject(),cronTriggerFactoryBean().getObject());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后启动项目，控制台就可以看到 定时任务的执行了。</p>
<p>代码已上传至：<a href="https://github.com/astronger/Spring-Boot-Quartz">https://github.com/astronger/Spring-Boot-Quartz</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——容器相关配置</title>
    <url>/2019/04/12/Spring%20Boot%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-Spring%20Boot%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>如下图，SpringBoot默认使用Tomcat作为嵌入式的Servlet容器。 <strong>我们也可以在配置文件中进行一些配置</strong>。<br><img src="https://www.itmengtao.cn/upload/2020/8/image-ef2e1f0338a341b2bb123b708a8a94ce.png" alt="image.png"></p>
<p><strong>在配置文件中进行简单的配置</strong>：<br><img src="https://www.itmengtao.cn/upload/2020/8/image-13aa93fd907546b5b71f4afe23cb10e6.png" alt="image.png"></p>
<p><strong>SpringBoot默认使用的是Tomcat，如果要切换其他容器，则只需要在pom文件中去掉Tomcat依赖，添加其他依赖即可</strong>。      </p>
<p><strong>如将Tomcat换成Jetty，如下图，添加修改依赖即可</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入web模块 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt; &lt;!-- 去掉tomcat --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!--引入其它的jetty容器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>SpringBoot默认还支持Jetty和Undertow容器，Undertow是一个高性能非阻塞的Servlet容器，并发性能很好，但是不支持JSP。Jetty更适合开发一些长连接Web应用，如Web聊天</strong>。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——整合 Shiro</title>
    <url>/2019/06/28/Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88%20Shiro-Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88%20Shiro/</url>
    <content><![CDATA[<p>在 Spring Boot 中做权限管理，一般来说，主流的方案是 Spring Security ，但是，仅仅从技术角度来说，也可以使用 Shiro。</p>
<p>一般来说，Spring Security 和 Shiro 的比较如下：</p>
<ul>
<li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li>
<li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li>
<li>Spring Security 功能强大；Shiro 功能简单</li>
</ul>
<p>虽然 Shiro 功能简单，但是也能满足大部分的业务场景。所以在传统的 SSM 项目中，一般来说，可以整合 Shiro。</p>
<p>在 Spring Boot 中，由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，当然也提供了 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。</p>
<p>在 Spring Boot 中整合 Shiro ，有两种不同的方案：</p>
<ol>
<li>将 SSM 整合 Shiro 的配置用 Java 重写一遍。</li>
<li>第二种就是使用 Shiro 官方提供的一个 Starter 来配置，但是，这个 Starter 并没有简化多少配置。</li>
</ol>
<h2 id="原生的整合"><a href="#原生的整合" class="headerlink" title="原生的整合"></a>原生的整合</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建一个 Spring Boot 项目，只需要添加 Web 依赖即可：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-7346690135b64ceca9543ae448105b0e.png" alt="image.png"></p>
<p>项目创建成功后，加入 Shiro 相关的依赖，完整的 pom.xml 文件中的依赖如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.4</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.4</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建-Realm"><a href="#创建-Realm" class="headerlink" title="创建 Realm"></a>创建 Realm</h3><p>接下来我们来自定义核心组件 Realm：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = (String) token.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;javaboy&quot;</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(<span class="string">&quot;账户不存在!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, <span class="string">&quot;123&quot;</span>, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Realm 中实现简单的认证操作即可，不做授权，授权的具体写法和 SSM 中的 Shiro 一样，不赘述。这里的认证表示用户名必须是 javaboy ，用户密码必须是 123 ，满足这样的条件，就能登录成功！</p>
<h3 id="配置-Shiro"><a href="#配置-Shiro" class="headerlink" title="配置 Shiro"></a>配置 Shiro</h3><p>接下来进行 Shiro 的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MyRealm <span class="title">myRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRealm();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        manager.setRealm(myRealm());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean bean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        bean.setSecurityManager(securityManager());</span><br><span class="line">        bean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        bean.setSuccessUrl(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">        bean.setUnauthorizedUrl(<span class="string">&quot;/unauthorizedurl&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;/doLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        bean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里进行 Shiro 的配置主要配置 3 个 Bean ：</p>
<ol>
<li>首先需要提供一个 Realm 的实例。</li>
<li>需要配置一个 SecurityManager，在 SecurityManager 中配置 Realm。</li>
<li>配置一个 ShiroFilterFactoryBean ，在 ShiroFilterFactoryBean 中指定路径拦截规则等。</li>
<li>配置登录和测试接口。<br>其中，ShiroFilterFactoryBean 的配置稍微多一些，配置含义如下：</li>
</ol>
<ul>
<li>setSecurityManager 表示指定 SecurityManager。</li>
<li>setLoginUrl 表示指定登录页面。</li>
<li>setSuccessUrl 表示指定登录成功页面。</li>
<li>接下来的 Map 中配置了路径拦截规则，注意，要有序。</li>
</ul>
<p>这些东西都配置完成后，接下来配置登录 Controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/doLogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLogin</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(<span class="keyword">new</span> UsernamePasswordToken(username, password));</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;please login!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试时，首先访问 /hello 接口，由于未登录，所以会自动跳转到 /login 接口：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-95add594f6e344279b047c4a6662a5b3.png" alt="image.png"></p>
<p>然后调用 /doLogin 接口完成登录：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-aad40ec8ae1a49c692d1470b15d28249.png" alt="image.png"></p>
<p>再次访问 /hello 接口，就可以成功访问了：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-73e3046b0fa2423f92decbe8f132f222.png" alt="image.png"></p>
<h2 id="使用-Shiro-Starter"><a href="#使用-Shiro-Starter" class="headerlink" title="使用 Shiro Starter"></a>使用 Shiro Starter</h2><p>上面这种配置方式实际上相当于把 SSM 中的 XML 配置拿到 Spring Boot 中用 Java 代码重新写了一遍，除了这种方式之外，我们也可以直接使用 Shiro 官方提供的 Starter 。</p>
<h3 id="创建工程，和上面的一样"><a href="#创建工程，和上面的一样" class="headerlink" title="创建工程，和上面的一样"></a>创建工程，和上面的一样</h3><p>创建成功后，添加 shiro-spring-boot-web-starter ，这个依赖可以代替之前的 shiro-web 和 shiro-spring 两个依赖，pom.xml 文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.4</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建-Realm-1"><a href="#创建-Realm-1" class="headerlink" title="创建 Realm"></a>创建 Realm</h3><p>这里的 Realm 和前面的一样，我就不再赘述。</p>
<h3 id="配置-Shiro-基本信息"><a href="#配置-Shiro-基本信息" class="headerlink" title="配置 Shiro 基本信息"></a>配置 Shiro 基本信息</h3><p>接下来在 application.properties 中配置 Shiro 的基本信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shiro.sessionManager.sessionIdCookieEnabled=<span class="keyword">true</span></span><br><span class="line">shiro.sessionManager.sessionIdUrlRewritingEnabled=<span class="keyword">true</span></span><br><span class="line">shiro.unauthorizedUrl=/unauthorizedurl</span><br><span class="line">shiro.web.enabled=<span class="keyword">true</span></span><br><span class="line">shiro.successUrl=/index</span><br><span class="line">shiro.loginUrl=/login</span><br></pre></td></tr></table></figure>
<p>配置解释：</p>
<ol>
<li>第一行表示是否允许将sessionId 放到 cookie 中</li>
<li>第二行表示是否允许将 sessionId 放到 Url 地址拦中</li>
<li>第三行表示访问未获授权的页面时，默认的跳转路径</li>
<li>第四行表示开启 shiro</li>
<li>第五行表示登录成功的跳转页面</li>
<li>第六行表示登录页面<h3 id="配置-ShiroConfig"><a href="#配置-ShiroConfig" class="headerlink" title="配置 ShiroConfig"></a>配置 ShiroConfig</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MyRealm <span class="title">myRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRealm();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        manager.setRealm(myRealm());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ShiroFilterChainDefinition <span class="title">shiroFilterChainDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultShiroFilterChainDefinition definition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/doLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的配置和前面的比较像，但是不再需要 ShiroFilterFactoryBean 实例了，替代它的是 ShiroFilterChainDefinition ，在这里定义 Shiro 的路径匹配规则即可。</li>
</ol>
<p>这里定义完之后，接下来的登录接口定义以及测试方法都和前面的一致，我就不再赘述了。大家可以参考上文。</p>
<p>参考：<a href="http://springboot.javaboy.org/2019/0611/springboot-shiro">http://springboot.javaboy.org/2019/0611/springboot-shiro</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——整合MyBatis多数据源（极简）</title>
    <url>/2019/05/19/Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89-Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%88%E6%9E%81%E7%AE%80%EF%BC%89/</url>
    <content><![CDATA[<p>1、工程创建<br>  创建一个基本的Spring Boot工程，添加Web依赖，MyBatis依赖以及MySQL驱动依赖，如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-5afaba5195bf41198dacae242da52dd3.png" alt="image.png"></p>
<p>创建成功后，添加Druid依赖，并且锁定MySQL驱动版本，完整的依赖如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     &lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;<span class="number">1.1</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">		&lt;version&gt;<span class="number">5.1</span><span class="number">.27</span>&lt;/version&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>2、多数据源配置<br>这里首先在application.properties中配置数据库基本信息，然后提供两个DataSource即可，直接上代码。</p>
<p>application.properties中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.one.url=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">spring.datasource.one.username=root</span><br><span class="line">spring.datasource.one.password=root</span><br><span class="line">spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"> </span><br><span class="line">spring.datasource.two.url=jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">spring.datasource.two.username=root</span><br><span class="line">spring.datasource.two.password=root</span><br><span class="line">spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure>

<p>再提供两个DataSource配置，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span></span><br><span class="line">    <span class="function">DataSource <span class="title">dsOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span></span><br><span class="line">    <span class="function">DataSource <span class="title">dsTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、MyBatis配置<br> MyBatis的配置，不同于JdbcTemplate，MyBatis的配置要稍微麻烦一些，因为要提供两个Bean，因此这里两个数据源我将在两个类中分开来配置，首先来看第一个数据源的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;org.sang.mybatis.mapper1&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory1&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfigOne</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dsOne&quot;)</span></span><br><span class="line">    DataSource dsOne;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">sqlSessionFactory1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            bean.setDataSource(dsOne);</span><br><span class="line">            sessionFactory = bean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">sqlSessionTemplate1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyBatisConfigOne类，首先指明该类是一个配置类，配置类中要扫描的包是org.sang.mybatis.mapper1，即该包下的Mapper接口将操作dsOne中的数据，对应的SqlSessionFactory和SqlSessionTemplate分别是sqlSessionFactory1和sqlSessionTemplate1，在MyBatisConfigOne内部，分别提供SqlSessionFactory和SqlSessionTemplate即可，SqlSessionFactory根据dsOne创建，然后再根据创建好的SqlSessionFactory创建一个SqlSessionTemplate。</p>
<p>这里配置完成后，依据这个配置，再来配置第二个数据源即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;org.sang.mybatis.mapper2&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory2&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfigTwo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dsTwo&quot;)</span></span><br><span class="line">    DataSource dsTwo;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">sqlSessionFactory2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            bean.setDataSource(dsTwo);</span><br><span class="line">            sessionFactory = bean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">sqlSessionTemplate2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、mapper创建<br>  mapper1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapperOne</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的XML文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.sang.mybatis.mapper1.UserMapperOne&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mapper2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的XML文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.sang.mybatis.mapper2.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后单元测试，运行测试类：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserMapperOne UserMapperOne;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserMapper userMapper;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;User&gt; allUser = UserMapperOne.getAllUser();</span><br><span class="line">	System.out.println(allUser);</span><br><span class="line">	List&lt;User&gt; allUser2 = userMapper.getAllUser();</span><br><span class="line">	System.out.println(allUser2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot | java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——整合MyBatis简单教程</title>
    <url>/2019/05/13/Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88MyBatis%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B-Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88MyBatis%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>        MyBatis比较方便，而且公司采用MyBatis做数据持久化的比较多，在Spring+SpringMVC中整合MyBatis步骤还是有点复杂的，要配置多个Bean，Spring Boot中对此做了进一步的简化，使MyBatis基本上可以做到开箱即用，本文就来看看在Spring Boot中MyBatis要如何使用。</p>
<p>   <strong>1、工程创建</strong><br>       创建一个基本的Spring Boot工程，添加Web依赖，MyBatis依赖以及MySQL驱动依赖，如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/9/image-b71e4a066ab149d48f9c33349ddf9774.png" alt="image.png">
      </p>
<p>     创建成功后，添加Druid依赖，并且锁定MySQL驱动版本，完整的依赖如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     &lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;<span class="number">1.1</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">		&lt;version&gt;<span class="number">5.1</span><span class="number">.27</span>&lt;/version&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>2、基本用法</strong><br>      首先也是在application.properties中配置数据库的基本信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.one.username=root</span><br><span class="line">spring.datasource.one.password=<span class="number">123456</span></span><br><span class="line">spring.datasource.one.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/test</span></span><br></pre></td></tr></table></figure>
<p>接下来创建Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.test.bean;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  创建Mapper，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.test.mapper;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.test.bean.User;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   创建UserMapper.xml文件（数据库名为test,表名为user,添加bean的字段即可，此处省略创建数据库），如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.test.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.javaboy.bean.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>   将UserMapper.xml文件放在mapper文件夹下，如图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/9/image-70214e30673340ff95c20f2f9ab93bab.png" alt="image.png">     </p>
<p>放在这里的UserMapper.xml会被自动扫描到，但是有另外一个Maven带来的问题，就是java目录下的xml资源在项目打包时会被忽略掉，所以，如果UserMapper.xml放在包下，需要在pom.xml文件中再添加如下配置，避免打包时java目录下的XML文件被自动忽略掉：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>     当然，UserMapper.xml也可以直接放在resources目录下，这样就不用担心打包时被忽略了，但是放在resources目录下，又不能自动被扫描到，需要添加额外配置。例如我在resources目录下创建mapper目录用来放mapper文件，如下：<br><img src="https://www.itmengtao.cn/upload/2020/9/image-55cc6cf6a51b457f83a20e365cc7de61.png" alt="image.png">
           </p>
<p>  此时在application.properties中告诉mybatis去哪里扫描mapper：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis.mapper-locations=classpath:mapper/*.xml</span><br></pre></td></tr></table></figure>
<p>  如此配置之后，mapper就可以正常使用了。注意第二种方式不需要在pom.xml文件中配置文件过滤。</p>
<p>  接下来创建单元测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.test.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.test.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	UserMapper userMapper;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;User&gt; allUser = userMapper.getAllUser();</span><br><span class="line">		System.out.println(allUser);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   运行测试类，我们可以看到控制台打印出了User信息，至此，测试成功。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/9/image-cc3c1e89a1bb4bba8d9d4762dfbf47c8.png" alt="image.png"></p>
<p>   </p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——整合Spring Security</title>
    <url>/2019/06/30/Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Spring%20Security-Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Spring%20Security/</url>
    <content><![CDATA[<p>Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p>
<p>相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p>
<p>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以<strong>零配置</strong>使用 Spring Security。</p>
<p>因此，一般来说，常见的安全管理技术栈的组合是这样的：</p>
<ul>
<li>SSM + Shiro</li>
<li>Spring Boot/Spring Cloud + Spring Security</li>
</ul>
<p><strong>注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。</strong></p>
<p>我们来看下具体使用。</p>
<h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><p>在 Spring Boot 中使用 Spring Security 非常容易，引入依赖即可：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-a0b3b4cdea7a4ffe9a6034d4c77a335f.png" alt="image.png"></p>
<p>pom.xml 中的 Spring Security 依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>只要加入依赖，项目的所有接口都会被自动保护起来。</p>
<h2 id="2-初次体验"><a href="#2-初次体验" class="headerlink" title="2.初次体验"></a>2.初次体验</h2><p>我们创建一个 HelloController:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问 /hello ，需要登录之后才能访问。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-c21eaca26fae40cb8567479d2cc7dbd3.png" alt="image.png"></p>
<p>当用户从浏览器发送请求访问 /hello 接口时，服务端会返回 302 响应码，让客户端重定向到 /login 页面，用户在 /login 页面登录，登陆成功之后，就会自动跳转到 /hello 接口。</p>
<p>另外，也可以使用 POSTMAN 来发送请求，使用 POSTMAN 发送请求时，可以将用户信息放在请求头中（这样可以避免重定向到登录页面）：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-77aa42c204df45b593838b4a0a66b18b.png" alt="image.png"></p>
<p>通过以上两种不同的登录方式，可以看出，Spring Security 支持两种不同的认证方式：</p>
<ul>
<li>可以通过 form 表单来认证</li>
<li>可以通过 HttpBasic 来认证<h2 id="3-用户名配置"><a href="#3-用户名配置" class="headerlink" title="3.用户名配置"></a>3.用户名配置</h2>默认情况下，登录的用户名是 user ，密码则是项目启动时随机生成的字符串，可以从启动的控制台日志中看到默认密码：</li>
</ul>
<p> <img src="https://www.itmengtao.cn/upload/2020/10/image-16649432d8ac48938357065afdd97468.png" alt="image.png"></p>
<p>这个随机生成的密码，每次启动时都会变。对登录的用户名/密码进行配置，有三种不同的方式：</p>
<ol>
<li>在 application.properties 中进行配置</li>
<li>通过 Java 代码配置在内存中</li>
<li>通过 Java 从数据库中加载<br>前两种比较简单，第三种代码量略大，本文就先来看看前两种。</li>
</ol>
<h3 id="3-1-配置文件配置用户名-密码"><a href="#3-1-配置文件配置用户名-密码" class="headerlink" title="3.1 配置文件配置用户名/密码"></a>3.1 配置文件配置用户名/密码</h3><p>可以直接在 application.properties 文件中配置用户的基本信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=<span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，重启项目，就可以使用这里配置的用户名/密码登录了。</p>
<h3 id="3-2-Java-配置用户名-密码"><a href="#3-2-Java-配置用户名-密码" class="headerlink" title="3.2 Java 配置用户名/密码"></a>3.2 Java 配置用户名/密码</h3><p>也可以在 Java 代码中配置用户名密码，首先需要我们创建一个 Spring Security 的配置类，集成自 WebSecurityConfigurerAdapter 类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//下面这两行配置表示在内存中配置了两个用户</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">&quot;javaboy&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;$2a$10$OR3VSksVAmCzc.7WeaRPR.t0wyCsIj24k0Bne8iKWV1o.V9wsP8Xe&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;lisi&quot;</span>).roles(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;$2a$10$p1H8iWa8I4.CA.7Z8bwLjes91ZpY.rYREGHQEInNtAp4NzL6PLKxi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在 configure 方法中配置了两个用户，用户的密码都是加密之后的字符串(明文是 123)，从 Spring5 开始，强制要求密码要加密，如果非不想加密，可以使用一个过期的 PasswordEncoder 的实例 NoOpPasswordEncoder，但是不建议这么做，毕竟不安全。</p>
<p>Spring Security 中提供了 BCryptPasswordEncoder 密码编码工具，可以非常方便的实现密码的加密加盐，相同明文加密出来的结果总是不同，这样就不需要用户去额外保存盐的字段了，这一点比 Shiro 要方便很多。</p>
<h2 id="4-登录配置"><a href="#4-登录配置" class="headerlink" title="4.登录配置"></a>4.登录配置</h2><p>对于登录接口，登录成功后的响应，登录失败后的响应，我们都可以在 WebSecurityConfigurerAdapter 的实现类中进行配置。例如下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    VerifyCodeFilter verifyCodeFilter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http</span><br><span class="line">        .authorizeRequests()<span class="comment">//开启登录配置</span></span><br><span class="line">        .antMatchers(<span class="string">&quot;/hello&quot;</span>).hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//表示访问 /hello 这个接口，需要具备 admin 这个角色</span></span><br><span class="line">        .anyRequest().authenticated()<span class="comment">//表示剩余的其他接口，登录之后就能访问</span></span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        <span class="comment">//定义登录页面，未登录时，访问一个需要登录之后才能访问的接口，会自动跳转到该页面</span></span><br><span class="line">        .loginPage(<span class="string">&quot;/login_p&quot;</span>)</span><br><span class="line">        <span class="comment">//登录处理接口</span></span><br><span class="line">        .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">        <span class="comment">//定义登录时，用户名的 key，默认为 username</span></span><br><span class="line">        .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">        <span class="comment">//定义登录时，用户密码的 key，默认为 password</span></span><br><span class="line">        .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">        <span class="comment">//登录成功的处理器</span></span><br><span class="line">        .successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()<span class="comment">//和表单登录相关的接口统统都直接通过</span></span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">            .logoutSuccessHandler(<span class="keyword">new</span> LogoutSuccessHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="string">&quot;logout success&quot;</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .httpBasic()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在 successHandler 方法中，配置登录成功的回调，如果是前后端分离开发的话，登录成功后返回 JSON 即可，同理，<strong>failureHandler</strong>方法中配置登录失败的回调，logoutSuccessHandler 中则配置注销成功的回调。</p>
<h2 id="5-忽略拦截"><a href="#5-忽略拦截" class="headerlink" title="5.忽略拦截"></a>5.忽略拦截</h2><p>如果某一个请求地址不需要拦截的话，有两种方式实现：</p>
<ul>
<li>设置该地址匿名访问</li>
<li>直接过滤掉该地址，即该地址不走 Spring Security 过滤器链<br>推荐使用第二种方案，配置如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/vercode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
参考：<a href="http://springboot.javaboy.org/2019/0725/springboot-springsecurity">http://springboot.javaboy.org/2019/0725/springboot-springsecurity</a> </li>
</ul>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot入门</title>
    <url>/2019/04/01/Spring%20Boot%E5%85%A5%E9%97%A8-Spring%20Boot%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>最近在看江南一点雨的教程以及视频，以下总结的笔记资料等将会参考他的为主，声明：仅供自己学习参考使用。</p>
<p>总结一下Spring Boot的主要优点：</p>
<h4 id="为所有Spring开发者更快的入门"><a href="#为所有Spring开发者更快的入门" class="headerlink" title="为所有Spring开发者更快的入门"></a>为所有Spring开发者更快的入门</h4><h4 id="开箱即用，提供各种默认配置来简化项目配置"><a href="#开箱即用，提供各种默认配置来简化项目配置" class="headerlink" title="开箱即用，提供各种默认配置来简化项目配置"></a>开箱即用，提供各种默认配置来简化项目配置</h4><h4 id="内嵌式容器简化Web项目"><a href="#内嵌式容器简化Web项目" class="headerlink" title="内嵌式容器简化Web项目"></a>内嵌式容器简化Web项目</h4><h4 id="没有冗余代码生成和XML配置的要求"><a href="#没有冗余代码生成和XML配置的要求" class="headerlink" title="没有冗余代码生成和XML配置的要求"></a>没有冗余代码生成和XML配置的要求</h4><h2 id="Spring-Boot-三种创建方式"><a href="#Spring-Boot-三种创建方式" class="headerlink" title="Spring Boot 三种创建方式"></a>Spring Boot 三种创建方式</h2><p>   这个就不详细写了，挑重点写，这个网上大把的有，随便百度。。。</p>
<p>   这里<strong>建议</strong>使用开发工具IntelliJ IDEA直接创建，系统的要求：Spring Boot 目前版本是 2.1.6，要求至少JDK8，集成的 Spring 版本是5.1.6 。</p>
<p>  1、首先在创建项目时选择 Spring Initializr，如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-3d344a75639a49b4bf09aa10b2023a50.png" alt="image.png"></p>
<p>2、然后点击 Next ，填入 Maven 项目的基本信息，如下：<br><img src="https://www.itmengtao.cn/upload/2020/8/image-e0c4754ba95545ccb04939ac9c99bace.png" alt="image.png"></p>
<p>3、再接下来选择需要添加的依赖，勾选Web即可，如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/image-e06f8860ae3e4d13af3a22c2f7bade58.png" alt="image.png"></p>
<p>4、勾选完成后，点击 Next 完成项目的创建。</p>
<p>  至此项目创建就完成了，很简单。然后执行这里的 main 方法就可以启动一个 Spring Boot 工程了。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cache + Redis</title>
    <url>/2019/06/12/Spring%20Cache%20+%20Redis-Spring%20Cache%20+%20Redis/</url>
    <content><![CDATA[<p>在Spring Boot中，使用Redis缓存，既可以使用RedisTemplate自己来实现，也可以使用使用这种方式，这种方式是Spring Cache提供的统一接口，实现既可以是Redis，也可以是Ehcache或者其他支持这种规范的缓存框架。从这个角度来说，Spring Cache和Redis、Ehcache的关系就像JDBC与各种数据库驱动的关系。今天整理一下 ，在Spring Boot中，使用Redis来作为Cache的实现，进而实现数据的缓存。</p>
<h2 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h2><p>首先创建一个Spring Boot工程，注意创建的时候需要引入三个依赖，web、cache以及redis，如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/10/image-6cb6b109118e4c04a56d78dabb0eae27.png" alt="image.png"></p>
<p>依赖内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;!-- Springboot <span class="number">2.1</span><span class="number">.5</span>之后远程访问Redis必须引入Spring security --&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>application.properties中配置一下Redis的基本信息，另外，这里要用到Cache，因此还需要稍微配置一下Cache，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.redis.host=<span class="number">192.168</span><span class="number">.1</span><span class="number">.132</span></span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line">spring.redis.password=<span class="number">123456</span></span><br><span class="line"></span><br><span class="line">#缓存起名叫c1</span><br><span class="line">spring.cache.cache-names=c1</span><br></pre></td></tr></table></figure>
<p>还需要在配置类上添加@EnableCaching注解，表示开启缓存： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span>  <span class="comment">//启用缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheRedisApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(CacheRedisApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置之后，Spring Boot就会自动帮我们在后台配置一个RedisCacheManager，相关的配置是在org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration类中完成的。部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(CacheManager.class)</span></span><br><span class="line"><span class="meta">@Conditional(CacheCondition.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(<span class="keyword">this</span>.determineConfiguration(resourceLoader.getClassLoader()));</span><br><span class="line">        List cacheNames = <span class="keyword">this</span>.cacheProperties.getCacheNames();</span><br><span class="line">        <span class="keyword">if</span>(!cacheNames.isEmpty()) &#123;</span><br><span class="line">            builder.initialCacheNames(<span class="keyword">new</span> LinkedHashSet(cacheNames));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (RedisCacheManager)<span class="keyword">this</span>.customizerInvoker.customize(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统会自动提供一个RedisCacheManager的Bean，这个RedisCacheManager间接实现了Spring中的Cache接口，有了这个Bean，我们就可以直接使用Spring中的缓存注解和接口了，而缓存数据则会被自动存储到Redis上。在单机的Redis中，这个Bean系统会自动提供，如果是Redis集群，这个Bean需要开发者来提供。</p>
<h2 id="缓存使用："><a href="#缓存使用：" class="headerlink" title="缓存使用："></a>缓存使用：</h2><h3 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h3><p>这个注解在类上使用，用来描述该类中所有方法使用的缓存名称，当然也可以不使用该注解，直接在具体的缓存注解上配置名称，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;c1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h3><p>这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的key就是方法的参数，缓存的value就是方法的返回值，如果你调用这个方法，但是每次传的参数一模一样，它就不会调用此方法，直接返回缓存值。否则就会调用方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id,String username)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;getUserById&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> getUserFromDBById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有多个参数时，默认就使用多个参数来做key，如果只需要其中某一个参数做key，则可以在@Cacheable注解中，通过key属性来指定key，如上代码就表示只使用id作为缓存的key，如果对key有复杂的要求，可以自定义keyGenerator。当然，Spring Cache中提供了root对象，可以在不定义keyGenerator的情况下实现一些复杂的效果：</p>
<h4 id="Cacheable-key-“-methodName”"><a href="#Cacheable-key-“-methodName”" class="headerlink" title="@Cacheable(key = “#methodName”)"></a>@Cacheable(key = “#methodName”)</h4><p><img src="https://www.itmengtao.cn/upload/2020/10/image-973e0f5b3ee74d54b11d896a5c2b7bde.png" alt="image.png"></p>
<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>这个注解一般加在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的key上，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut(key = &quot;#user.id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">updateUserById</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>这个注解一般加在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（condition属性）或者或者配置清除所有缓存（allEntries属性），示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在这里执行删除操作， 删除是去数据库中删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Alibaba 从入门到放弃</title>
    <url>/2020/08/16/Spring%20Cloud%20Alibaba%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-springcloudalibaba%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<p>@<a href="Nacos">TOC</a></p>
<h1 id="Spring-Cloud-Alibaba简介"><a href="#Spring-Cloud-Alibaba简介" class="headerlink" title="Spring Cloud Alibaba简介"></a>Spring Cloud Alibaba简介</h1><p>Spring Cloud Alibaba 致力于提供微服务开发一站式解决方案。此项目包括开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p>
<p>依托 Spring Cloud Alibaba，你只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里云中间件来迅速搭建分布式应用系统。</p>
<p><strong>SpringCloud Alibaba 和 Spring Cloud 搭配方案</strong>：</p>
<ul>
<li>SpringCoud Alibaba-Nacos：注册中心（服务发现 / 注册）</li>
<li>SpringCoud Alibaba-Nacos：配置中心（动态配置管理）</li>
<li>SpringCoud Alibaba-Sentinel：服务容错（限流、降级、熔断）</li>
<li>SpringCoud Alibaba-Seata：原 Fescar，即分布式解决方案</li>
<li>SpringCoud-Ribbon：负载均衡</li>
<li>SpringCoud-Feign：声明式 HTTP 客户端（调用远程服务）</li>
<li>SpringCoud-Gateway：API 网关（webflux 编程模式）</li>
<li> SpringCoud-Sleuth：调用链监控</li>
</ul>
<p><strong>Spring Cloud Alibaba主要功能</strong>：</p>
<ul>
<li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。</li>
<li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li>
<li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ul>
<p><strong>相关组件</strong>：</p>
<ul>
<li><p><strong>Nacos</strong>：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
</li>
<li><p><strong>Sentinel</strong>：阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
</li>
</ul>
<p>开源地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/">https://github.com/alibaba/spring-cloud-alibaba/</a></p>
<h1 id="1-Nacos-简介"><a href="#1-Nacos-简介" class="headerlink" title="1. Nacos 简介"></a>1. Nacos 简介</h1><p>Nacos 主要提供了服务发现、服务配置以及服务管理的功能。以下援引自 **<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">官方网站</a>**：</p>
<p>基本特征：</p>
<ul>
<li>服务发现</li>
<li>动态配置</li>
<li>动态 DNS 服务</li>
<li>服务及元数据管理</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020120717034960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-1-Nacos-安装-配置中心"><a href="#1-1-Nacos-安装-配置中心" class="headerlink" title="1.1  Nacos 安装 + 配置中心"></a>1.1  Nacos 安装 + 配置中心</h2><ul>
<li>Docker 安装</li>
<li>下载编译好的安装包</li>
</ul>
<p>首先下载安装包：<a href="https://github.com/alibaba/nacos/releases/download/1.4.0/nacos-server-1.4.0.tar.gz">https://github.com/alibaba/nacos/releases/download/1.4.0/nacos-server-1.4.0.tar.gz</a></p>
<p>然后解压，如果是 windows 直接在 bin 目录下双击 startup.cmd 启动。</p>
<p>如果是Linux， bin 目录下执行命令： <strong>sh startup.sh -m standalone</strong></p>
<blockquote>
<p><strong>注意：系统一定要配置好 jdk ，测试 java 和 javac 两个命令要存在！</strong></p>
</blockquote>
<p>Nacos 启动成功后，浏览器输入： <a href="http://192.168.1.132:8848/nacos">http://192.168.1.132:8848/nacos</a> 就能看到启动页面了。登录页面的默认用户名/密码都是 nacos ，登录后如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201207111851310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 配置中心：类似于 Spring Cloud Config ，点击服务端配置——&gt; 配置管理——&gt; 配置列表——&gt; 点击+，这里主要配置三个东西， Data ID、Group 以及配置的内容。</p>
<p> Data Id 的格式是：</p>
<blockquote>
<p>${prefix}- ${spring.profile.active}. ${file-extension}</p>
</blockquote>
<ol>
<li>prefix 默认为 spring.application.name 的值；</li>
<li>spring.profile.active 即为当前环境对应的 profile；</li>
<li>file-exetension 为配置内容的数据格式。<blockquote>
<p><strong>注</strong>：当 - spring.profile.active 为空 / 未填写时，相对应的连接符 - 也将不存在 (省略)，dataId 的拼接格式变成 ${prefix}. ${file-extension}；<br>file-exetensio可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>最终格式：${spring.application.name}- ${spring.profile.active}. ${spring.cloud.nacos.config.file-extension}</p>
</blockquote>
<p>然后在新添加一个配置如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201207145818106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来创建新的  Spring Cloud Alibaba 项目进行测试，添加如下依赖：<br><img src="https://img-blog.csdnimg.cn/20201207144726385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后，新建 bootstrap.properties，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=nacos</span><br><span class="line">spring.cloud.nacos.server-addr=192.168.1.132:8848</span><br><span class="line">spring.cloud.nacos.config.file-extension=properties</span><br></pre></td></tr></table></figure>
<p>添加测试 Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//动态刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后启动项目，浏览器访问： <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> ，就会获取到在页面配置的内容，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201207152620441.png" alt="在这里插入图片描述"></p>
<h2 id="1-2-注册中心"><a href="#1-2-注册中心" class="headerlink" title="1.2 注册中心"></a>1.2 注册中心</h2><p>Navos 也可做注册中心，代替 Eureka。创建 Spring Boot 项目(此时相当于provider)，添加依赖：<br><img src="https://img-blog.csdnimg.cn/20201207153453233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=nacos01</span><br><span class="line">spring.cloud.nacos.discovery.server-addr=192.168.1.132:8848</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提供测试 Controller ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    Integer port;<span class="comment">//添加端口号，测试集群</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello:&quot;</span>+port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将项目打包，启动两个实例。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">java -jar nacos01-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line">java -jar nacos01-0.0.1-SNAPSHOT.jar --server.port=8081</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动成功后，这时刷新，服务已经注册上来了。如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201207155300498.png" alt="在这里插入图片描述"></p>
<p>provider 已经创建成功，再创建一个 consumer ，配置基本与 nacos01 一致。</p>
<p><img src="https://img-blog.csdnimg.cn/20201207155622676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=nacos02</span><br><span class="line">spring.cloud.nacos.discovery.server-addr=192.168.1.132:8848</span><br><span class="line"></span><br><span class="line">server.port=8083</span><br></pre></td></tr></table></figure>

<p>开启负载均衡：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nacos02Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Nacos02Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//开启负载均衡</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建测试 Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://nacos01/hello&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 naxos02 ，然后可以看到已经注册挤进去了。</p>
<p><img src="https://img-blog.csdnimg.cn/20201207160719234.png" alt="在这里插入图片描述"><br>然后浏览器不停刷新访问：<a href="http://localhost:8083/hello%EF%BC%8C%E8%BE%BE%E5%88%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%E3%80%82">http://localhost:8083/hello，达到负载均衡效果。</a></p>
<p><img src="https://img-blog.csdnimg.cn/2020120716080490.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201207160816132.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>总结：Nacos 做为配置中心的话比 Spring Cloud Config 方便一些，作为注册中心与 Eureka、Consul 区别不大。</strong></p>
</blockquote>
<h1 id="2-Sentinel"><a href="#2-Sentinel" class="headerlink" title="2. Sentinel"></a>2. Sentinel</h1><ul>
<li>使用场景丰富</li>
<li>有完备的实时监控</li>
<li>广泛的开源生态 </li>
</ul>
<p>Sentinel 整体上可以分为两个核心部分：</p>
<ul>
<li>核心库</li>
<li>控制台 <h3 id="2-1-Sentinel-安装"><a href="#2-1-Sentinel-安装" class="headerlink" title="2.1 Sentinel 安装"></a>2.1 Sentinel 安装</h3>首先下载 <strong>控制台</strong> jar ，这是一个 Spring Boot 工程，下载好之后，直接启动。下载地址：<br><a href="https://github.com/alibaba/Sentinel/releases/download/v1.8.0/sentinel-dashboard-1.8.0.jar">https://github.com/alibaba/Sentinel/releases/download/v1.8.0/sentinel-dashboard-1.8.0.jar</a></li>
</ul>
<p>下载完后启动服务，浏览器访问如下则成功。</p>
<p><img src="https://img-blog.csdnimg.cn/2020120810511211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-2-Sentinel-应用"><a href="#2-2-Sentinel-应用" class="headerlink" title="2.2 Sentinel 应用"></a>2.2 Sentinel 应用</h3><p>1.新建一个 Spring Boot 项目，添加 Sentinel 依赖，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201208105331868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>创建成功后，配置 Sentinel 控制台地址：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=sentinel</span><br><span class="line">spring.cloud.sentinel.transport.dashboard=localhost:8080</span><br><span class="line"></span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure>
<p>再创建一个测试 Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello sentinel&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试如下：<br><img src="https://img-blog.csdnimg.cn/2020120811074363.png" alt="在这里插入图片描述"><br>然后刷新 sentinel 控制台页面，发现它的信息已经注册上去了，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201208113135991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2. 接下来做一个流量控制的测试，先配置如下信息，每秒处理5个请求：<br><img src="https://img-blog.csdnimg.cn/20201208113044333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>写一个测试类，这里假设一次来25个请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentinelApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            String forObject = restTemplate.getForObject(<span class="string">&quot;http://localhost:8081/hello&quot;</span>, String.class);</span><br><span class="line">            System.out.println(forObject+<span class="string">&quot;：&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动测试类，打印日志，每秒处理5个请求：</p>
<p><img src="https://img-blog.csdnimg.cn/20201208114238604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>总结： 这里的流控规则比之前的 Resilience4j 较为方便一些，只需针对接口进行配置即可。</strong></p>
</blockquote>
<h3 id="2-2-1-Nacos-中配置流控规则"><a href="#2-2-1-Nacos-中配置流控规则" class="headerlink" title="2.2.1 Nacos 中配置流控规则"></a>2.2.1 Nacos 中配置流控规则</h3><p>接上文代码，整合配置中心，添加依赖至 sentinel 服务中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--关联 nacos 与 sentinel --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.sentinel.datasource.ds.nacos.server-addr=192.168.1.132:8848</span><br><span class="line">spring.cloud.sentinel.datasource.ds.nacos.data-id=sentinel-rule</span><br><span class="line">spring.cloud.sentinel.datasource.ds.nacos.group-id=DEFAULT_GROUP</span><br><span class="line">spring.cloud.sentinel.datasource.ds.nacos.rule-type=flow</span><br></pre></td></tr></table></figure>

<p>由于 nacos 要把数据告诉 sentinel，然后它去创建限流规则，那么服务需要注册到 nacos 上去。那么参考之前的，新建 bootstrap.properties 配置文件注册到 nacos，添加如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.nacos.config.server-addr=192.168.1.132:8848</span><br></pre></td></tr></table></figure>

<p>访问nacos 控制台：<a href="http://192.168.1.132:8848/nacos%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://192.168.1.132:8848/nacos，新建一个配置，如下：</a><br><img src="https://img-blog.csdnimg.cn/20201209101142155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;resource&quot;: &quot;/hello&quot;,  //限流的接口</span><br><span class="line">      &quot;limitApp&quot;: &quot;default&quot;,    //流控针对的调用源【有手机的、小程序的等；default表示不限制】</span><br><span class="line">      &quot;grade&quot;: 1,  //【阈值类型】0：表示并发线程数；1：QPS</span><br><span class="line">      &quot;count&quot;: 5,  // 单机阈值</span><br><span class="line">      &quot;clusterMode&quot;: false,  //是否是集群模式</span><br><span class="line">      &quot;strategy&quot;: 0, //流控模式</span><br><span class="line">      &quot;controlBehavior&quot;: 0   //流控效果</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>添加完后启动 sentinel 服务，此时刷新 sentinel  管理页面没有数据。如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201209102632937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后访问 <a href="http://127.0.0.1:8081/hello%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:8081/hello，如下：</a></p>
<p><img src="https://img-blog.csdnimg.cn/20201209102727629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后再次刷新 sentinel  管理页面，发现数据已经注册上来了，这条数据就是刚才配置的信息，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/2020120910291924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201209102931415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>以上就是 nacos 与 sentinel  的结合使用。</p>
<p><strong>项目案例地址</strong> ：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Bus 笔记补充</title>
    <url>/2020/08/14/Spring%20Cloud%20Bus%20%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85-springcloudbus%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>Spring Cloud Bus 通过轻量级消息代理连接各个微服务，可用广播配置文件来更改/或管理服务监控。</p>
<p>首先安装 RabbitMQ，Docker 中 RabbitMQ 安装命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname my-rabbit --name some-rabbit -P 15672:15672 5672:5672 rabbitmq:3-management</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>详细安装步骤可参考 <a href="https://blog.csdn.net/ourstronger/article/details/100764478"><strong>Docker一键安装RabbitMQ</strong></a> 这篇文章。</p>
<h3 id="1-实现配置文件的动态刷新（全部刷新）。"><a href="#1-实现配置文件的动态刷新（全部刷新）。" class="headerlink" title="1. 实现配置文件的动态刷新（全部刷新）。"></a>1. 实现配置文件的动态刷新（全部刷新）。</h3><p>在上篇文章当我们的配置文件发生变化时，我们需要挨个的向 config-client 发送 include refresh 这个请求，然才能实现 config-client 配置文件的动态刷新。显然比较麻烦。   </p>
<p>结合 Spring Cloud Bus 之后，当我们的配置文件发生变化时， 我们可以只向 config-server 发送一个更新请求，然后 config-server 把消息发送给 Spring Cloud Bus ，Spring Cloud Bus 收到消息后把消息转发到 RabbitMQ ，RabbitMQ 就可以通知 config-client ，config-client 收到消息后就会自动更新。(总之就是开发者只需给 config-server 发送一次消息就可以了，剩下 config-client 都会自动刷新。)</p>
<p>RabbitMQ安装完成后，结合上篇文章在 config-server 和 config-client 分别添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时 config-server 将提供刷新接口，所以 config-server 还需添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，给两个分别配置，使之都能连接到 RabbitMQ 上。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.rabbitmq.host=192.168.1.132</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br></pre></td></tr></table></figure>
<p>在 config-server 中，添加开启 bus-refresh 端点：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=bus-refresh</span><br></pre></td></tr></table></figure>

<p>由于给 config-server 中的所有接口都添加了保护，所以刷新接口都无法直接访问，这时可通过修改 Security 配置，对端点的权限作出修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段配置中，开启了 HttpBasic 登录，这样在刷新请求时，就可以直接通过 HttpBasic 配置认证信息了。<br>最后分别启动 Eureka、 config-server 和 config-client ，访问：<a href="http://localhost:8082/hello">http://localhost:8082/hello</a> 如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2020112611483241.png#pic_center" alt="在这里插入图片描述"><br>然后修改配置信息提交到 GitHub （此处将test123改为 test），刷新 config-client 接口，查看是否有变化 (此时没变化)。</p>
<p>然后用 postman 测试发送 POST 请求： <a href="http://localhost:8081/actuator/bus-refresh">http://localhost:8081/actuator/bus-refresh</a> ，请求结果是空白则成功。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201126140552896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>这个 post 是针对 config-server 的，config-server 会把这个刷新的指令传到 rabbitMQ，然后 rabbitmq 再把指令传给各个 client。然后继续访问： <a href="http://localhost:8082/hello">http://localhost:8082/hello</a> 如下： 发现结果已经改变。（此处只要在 client 端配置了 rabbitmq，就会自动修改）。</p>
<p><img src="https://img-blog.csdnimg.cn/2020112613575947.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-逐个刷新"><a href="#2-逐个刷新" class="headerlink" title="2. 逐个刷新"></a>2. 逐个刷新</h2><p>如果更新完配置文件之后，不希望每一个微服务都去刷新配置文件，那么可以通过如下配置解决问题。<br>首先，给每个 config-client 配置文件添加一个 instance-id：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">eureka.instance.instance-id=$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span><br></pre></td></tr></table></figure>
<p>然后，对 config-client 进行打包。</p>
<p>打包完成后，在IDEA 的Terminal 框通过如下命令启动两个 config-client  实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">java -jar config-client-0.0.1-SNAPSHOT.jar --server.port=8082</span><br><span class="line">java -jar config-client-0.0.1-SNAPSHOT.jar --server.port=8083</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动成功后，在浏览器分别访问8082端口和8083端口的，访问结果相同。如下：<br><img src="https://img-blog.csdnimg.cn/20201126143553208.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201126143613130.png#pic_center" alt="在这里插入图片描述"><br>接下来修改本地文件（将 test 改为 test234），并提交至 GitHub，如下：<br><img src="https://img-blog.csdnimg.cn/20201126143907815.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-测试批量全部刷新"><a href="#1-测试批量全部刷新" class="headerlink" title="1. 测试批量全部刷新"></a>1. 测试批量全部刷新</h4><p>提交后，我们继续 post 请求 config-server ，访问 <a href="http://localhost:8081/actuator/bus-refresh">http://localhost:8081/actuator/bus-refresh</a> 如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201126144515189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 请求成功后，继续访问刚才那两个接口，<strong>都已经发生了改变</strong>。如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201126144550578.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201126144606989.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-测试逐个刷新"><a href="#2-测试逐个刷新" class="headerlink" title="2. 测试逐个刷新"></a>2. 测试逐个刷新</h4><p>继续修改本地文件（将 test234 改为 test888），并提交至 GitHub，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201126145121386.png#pic_center" alt="在这里插入图片描述"><br>提交成功后可通过如下方式只刷新某一个微服务，例如只刷新 8082 端口的服务。<br>client1:8082 表示是服务instance-id。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/actuator/bus-refresh/client1:8082</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201126145507940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时再访问原来那两个接口，结果如下，只有 8082 端口发生了变化，8083 没有改变。</p>
<p><img src="https://img-blog.csdnimg.cn/20201126145637955.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201126145654342.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="代码地址：https-github-com-astronger-springcloud-simple-samples"><a href="#代码地址：https-github-com-astronger-springcloud-simple-samples" class="headerlink" title="代码地址：https://github.com/astronger/springcloud-simple-samples"></a>代码地址：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a></h4>]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Eureka 搭建 &amp; 集群</title>
    <url>/2020/06/24/Spring%20Cloud%20Eureka%20%E6%90%AD%E5%BB%BA%20&amp;%20%E9%9B%86%E7%BE%A4-Spring%20Cloud%20Eureka%20%E6%90%AD%E5%BB%BA%20&amp;%20%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>关于 Eureka 的详细介绍已经在上篇文章通俗的讲了。Eureka 本身是使用 java 来开发的，Spring Cloud 使用 Spring Boot 技术对 Eureka 进行了封装，所以在 Spring Cloud 中使用 Eureka 非常方便，只需要引入 spring-cloud-starter-netflix-eureka-server 依赖即可，然后启动即可。</p>
<h3 id="1-Eureka-搭建"><a href="#1-Eureka-搭建" class="headerlink" title="1.Eureka 搭建"></a>1.Eureka 搭建</h3><p>创建一个普通的 Spring Boot 项目，创建时添加 Eureka 依赖：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-e005832430ea47858c80d9c1104aee73.png" alt="image.png"></p>
<p>项目创建成功后，在项目启动类上添加注解，标记该项目是一个 Eureka Server：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">//开启Eureka</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 application.properties 中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 给当前服务取名</span><br><span class="line">spring.application.name=eureka</span><br><span class="line">#端口号</span><br><span class="line">server.port=1111</span><br><span class="line">#默认情况下，eureka server 也是一个普通的微服务，所以当它还是一个注册中心的时候，会有两层身份：</span><br><span class="line"># 1.注册中心</span><br><span class="line"># 2.普通服务，即当前服务会自己注册到自己上面来</span><br><span class="line"># false 意为当前项目不要注册到注册中心上</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line"># 表示是否从 eureka server 上注册信息</span><br><span class="line">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure>

<p>然后启动项目，项目启动成功后在浏览器访问：<a href="http://localhost:1111/">http://localhost:1111</a> 就可以看到 Eureka 的管理页面了。如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-ff9388ff04634bd8818295779a144b62.png" alt="image.png"></p>
<h3 id="2-Eureka-集群"><a href="#2-Eureka-集群" class="headerlink" title="2. Eureka 集群"></a>2. Eureka 集群</h3><p>使用了注册中心后，所有的服务都要通过服务注册中心来进行信息交换。服务注册中心的稳定性就非常重要了，一旦服务注册中心掉线，会影响到整个系统的稳定性。所以在实际开发中，Eureka 一般都是以集群的形式出现的。</p>
<p>Eureka 集群，实际上就是启动多个 Eureka 实例， 多个 Eureka 实例之间互相注册，互相同步数据，共同组成一个 Eureka 集群。</p>
<p>搭建 Eureka 集群，首先要修改电脑的 hosts 文件 (c:\windows\System32\drivers\etc\hosts)，Linux 上面搭建请点击<a href="https://blog.csdn.net/a755199443/article/details/92637977">这篇文章</a>查看。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-c47afcc9bf9b46b585c73c893bda444a.png" alt="image.png"></p>
<p>我这里为了方便操作，直接在第一步搭建 eureka 的 demo 基础上，在 resources 目录下，再添加两个配置文件，分别如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-6984a33f63f44e72bfb16ba0e4f98378.png" alt="image.png"></p>
<p>application-a.properties 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 给当前服务取名</span><br><span class="line">spring.application.name=eureka</span><br><span class="line">#端口号</span><br><span class="line">server.port=1111</span><br><span class="line">eureka.instance.hostname=eurekaA</span><br><span class="line">#默认情况下，eureka server 也是一个普通的微服务，所以当它还是一个注册中心的时候，会有两层身份：</span><br><span class="line"># 1.注册中心</span><br><span class="line"># 2.普通服务，即当前服务会自己注册到自己上面来</span><br><span class="line"># false 意为当前项目不要注册到注册中心上</span><br><span class="line">eureka.client.register-with-eureka=true</span><br><span class="line"># 表示是否从 eureka server 上注册信息</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line"># A服务注册到B服务上( 配置多个的话后面用逗号隔开)</span><br><span class="line">eureka.client.service-url.defaultZone=http://eurekaB:1112/eureka</span><br></pre></td></tr></table></figure>

<p>application-b.properties 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 给当前服务取名</span><br><span class="line">spring.application.name=eureka</span><br><span class="line">#端口号</span><br><span class="line">server.port=1112</span><br><span class="line">eureka.instance.hostname=eurekaB</span><br><span class="line">#默认情况下，eureka server 也是一个普通的微服务，所以当它还是一个注册中心的时候，会有两层身份：</span><br><span class="line"># 1.注册中心</span><br><span class="line"># 2.普通服务，即当前服务会自己注册到自己上面来</span><br><span class="line"># false 意为当前项目不要注册到注册中心上</span><br><span class="line">eureka.client.register-with-eureka=true</span><br><span class="line"># 表示是否从 eureka server 上注册信息</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line"> </span><br><span class="line">eureka.client.service-url.defaultZone=http://eurekaA:1111/eureka</span><br></pre></td></tr></table></figure>

<p>配置完成后对当前项目打包， </p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-8255ba5a98264c69b481bdea2b81b074.png" alt="image.png"></p>
<p>打完包在 IDEA 命令行启动两个实例。两个启动命令分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=a</span><br><span class="line">java -jar eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=b</span><br></pre></td></tr></table></figure>

<p>注意：启动第一个 a 之后你会发现控制台报错，是因为它一直发送心跳，而同时 b 还没有上线，等 b 也启动后错误即可消失。如果还报错，那就是代码的问题了。</p>
<p> 启动成功后，就可以看到两个服务之间互相注册，共同组成一个集群。 如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-fd050b2303534905b935f495105062a4.png" alt="image.png"></p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-063d6cdf28404c6295cffcabd83e9abb.png" alt="image.png"></p>
<h3 id="2-1-Eureka-集群原理"><a href="#2-1-Eureka-集群原理" class="headerlink" title="2.1 Eureka 集群原理"></a>2.1 Eureka 集群原理</h3><p>官方的 Eureka 集群架构图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-cf082ac398674ba1bc7f734dfa03d111.png" alt="image.png"></p>
<p>在这个集群架构中，Eureka Server 之间过 Replicate 进行数据同步，不同的 EurekaServer 之间不区分主从节点，所有节点都是平等的。节点之间，通过置顶 serviceUrl 来相注册，形成一个集群，进而提高节点的可用性。</p>
<p>在 Eureka Server 集群中，如果有某一个节点宕机，Eureka Client 会自动切到新的 Eureka Server 上。每一个 Eureka Server，都会互相同步数据。Eureka Server 的连接方式，可以是单线的，就是 A——&gt;b——&gt;C，此时，A 的数据也会和 C 之间相同步。但是一般不建议这种写法，在我们配置 serviceUrl 时，可以指定多个注册地址，即 A 可以即注册到 B 上，也可以同时注册到 C 上。</p>
<p>Eureka 分区：</p>
<p>1．region：地理上的不同区域</p>
<p>2．zone：具体的机房</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Eureka(详细介绍) 大白话</title>
    <url>/2020/06/10/Spring%20Cloud%20Eureka(%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D)%20%E5%A4%A7%E7%99%BD%E8%AF%9D-Spring%20Cloud%20Eureka(%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D)%20%E5%A4%A7%E7%99%BD%E8%AF%9D/</url>
    <content><![CDATA[<h3 id="笔记补录："><a href="#笔记补录：" class="headerlink" title="笔记补录："></a>笔记补录：</h3><h4 id="1-Eureka-介绍"><a href="#1-Eureka-介绍" class="headerlink" title="1.Eureka 介绍"></a>1.Eureka 介绍</h4><p>Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件的一部分，基于 Netflix Eureka 做了二次封装，主要负责实现微服务架构中的服务治理功能。</p>
<p>服务治理是微服务架构中必不可少的一部分，阿里开源的 Dubbo 框架就是针对服务治理的。服务治理必须要有一个注册中心，除了用 Eureka 作为注册中心外，我们还可以使用 Consul、Etcd、Zookeeper 等来作为服务的注册中心。</p>
<p>Eureka 由两部分组成：服务端和客户端，服务端就是注册中心，用来接收其它的服务注册，客户端是一个java客户端，用来注册，并可以实现负载均衡等功能。 Eureka 的搭建和集群请点击查看这篇文章。</p>
<p>Eureka图解如下：</p>
<p>从图中可以看出Eureka有三个角色：</p>
<p>Eureka Server : 注册中心<br>Eureka Provider: 服务提供者<br>Eureka Consumer : 服务消费者<br>注册中心就是管理所有服务的信息和状态，12306 就好比一个注册中心，顾客就好比调用的客户端，当他们需要坐火车时，就会在 12306 网站上查询余票，有票就可以购买，然后获取火车的车次、时间等，最后出发。程序也是一样，当你需要调用某一个服务的时候，你会先去 Eureka 中去拉取服务列表，查看你调用的服务在不在其中，在的话就拿到服务地址、端口等信息，然后调用。</p>
<p>注册中心带来的好处就是，不需要知道有多少提供方，你只需要关注注册中心即可，就像顾客不必关心有多少火车在开行，只需要去 12306 网站上看有没有票就可以了。</p>
<p>为什么 Eureka 比 Zookeeper 更适合作为注册中心呢？主要是因为 Eureka 是基于 AP 原则构建的，而 ZooKeeper 是基于 CP 原则构建的。在分布式系统领域有个著名的 CAP 定理，即 C 为数据一致性；A 为服务可用性；P 为服务对网络分区故障的容错性。这三个特性在任何分布式系统中都不能同时满足，最多同时满足两个。Zookeeper 有一个 Leader，而且在这个 Leader 无法使用的时候通过 Paxos（ZAB）算法选举出一个新的 Leader。这个 Leader 的任务就是保证写数据的时候只向这个 Leader 写入，Leader 会同步信息到其他节点。通过这个操作就可以保证数据的一致性。</p>
<p>想要保证 AP 就要用 Eureka，想要保证 CP 就要用 Zookeeper。</p>
<p>Dubbo 中大部分都是基于 Zookeeper 作为注册中心的。Spring Cloud 中当然首选 Eureka。</p>
<h4 id="2-Eureka-的工作细节"><a href="#2-Eureka-的工作细节" class="headerlink" title="2. Eureka 的工作细节"></a>2. Eureka 的工作细节</h4><p>2.1 Eureka Server<br>     Eureka Server主要对外提供了三个功能：</p>
<p>服务注册，所有的服务都注册到Eureka Server上面来<br>提供注册表，注册表就是所有注册上来服务的一个列表，Eureka Client在调用服务时，需要获取这个注册表，一般来说，这个注册表会缓存下来，如果缓存失效，则直接获取最新的注册表<br>同步状态，Eureka Client 通过注册、心跳等机制，和Eureka Server同步当前客户端的状态<br>2.2 Eureka Client<br>     Eureka Client 主要是来简化每一个服务和Eureka Server 之间的交互。Eureka Client 会自动拉取、更新以及缓存Eureka Server 中的信息，这样，即便Eureka Server 所有节点都宕机，Eureka Client 依然能够获取到想要调服务的地址（但是地址可能不准确）。</p>
<p>2.2.1 服务注册</p>
<p> 服务提供者将自己注册到服务注册中心(Eureka Server)，需要注意，所渭的服务提供者，只是一个业务上的划分，本质上他就是一个 Eureka Client 。当 Eureka Client 向 Eureka Server 注册时，他需要提供自身的一些元数据信息，例如IP地址、端囗、名称、运行状态等等。</p>
<p>2.2.2 服务续约</p>
<p>Eureka Client 注册到 Eureka Server 上之后，事情还没有结束，刚刚开始而已。注册成功后，默认情况下，Eureka Client 每隔30秒就要向 Eureka Server 发送一条心跳消息，来告诉Eureka Server 我还在运行。如果 Eureka Server 连续90秒有沿有收到Eureka Client 的续约消息（连续三次没发送），它会认为Eureka Client已经线了，会将掉线的Eureka Client从当前的服务注册列表中剔除。</p>
<p>服务续约，有两个相关的属性（一般不建议修改）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 表示服务的续约时间，默认是30秒</span><br><span class="line">eureka.instance.lease-renewal-intetval-in-seconds=30 </span><br><span class="line"># 服务失效时间，默认是90秒</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=90</span><br></pre></td></tr></table></figure>
<p>2.2.3 服务下线</p>
<p>当 Eureka Client 下线时，它会主动发送一条消息，告诉Eureka Server，我下线了。</p>
<p>2.2.4 获取注册表信息</p>
<p>Eureka Client 从Eureka Server 上获取服务的注册信息，将其缓存在本地。本地客户端在需要调用远程服务时，会从该信息中查找远程服务所对应的IP地址、端囗等信息。Eureka Client 上缓存的服务注册信息会定期更新（30秒)，如果 Eureka Server 返回的注册表信息与本地缓存的注册表信息不同的话，Eureka Client 会自动处理。</p>
<p>这里，也涉及至两个属性，一个是是否允许获取注册表信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eureka.client.fetch-registry=true</span><br></pre></td></tr></table></figure>
<p>Eureka Client 上缓存的服务注册信息，定期更新的时间间隔，默认30秒：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eureka.client.registry-fetch-interval-seconds=30</span><br></pre></td></tr></table></figure>
<p> 以上。</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway 笔记补充</title>
    <url>/2020/08/14/Spring%20Cloud%20Gateway%20%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85-springcloudgateway%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>@[TOC](Spring Cloud Gateway)</p>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>SpringCloud Gateway 旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。<br>SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，使用的是Spring Boot和Spring Webflux提供的<strong>Netty</strong>底层环境，不能和传统的Servlet容器一起使用，也不能打包成一个WAR包。</p>
<p>SpringCloud官 对SpringCloud Gateway <strong>特征介绍</strong>如下：</p>
<p>（1）基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0</p>
<p>（2）集成 Hystrix 断路器</p>
<p>（3）集成 Spring Cloud DiscoveryClient</p>
<p>（4）Predicates 和 Filters 作用于特定路由，易于编写的 Predicates 和 Filters</p>
<p>（5）具备一些网关的高级功能：动态路由、限流、路径重写</p>
<p>从以上的特征来说，和Zuul的特征差别不大。SpringCloud Gateway和Zuul主要的区别，还是在底层的通信框架上。</p>
<p>简单说明一下上文中的三个术语：</p>
<p>（1）Filter（过滤器）：</p>
<p>和Zuul的过滤器在概念上类似，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。</p>
<p>（2）Route（路由）：</p>
<p>网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。</p>
<p>（3）Predicate（断言）：</p>
<p>这是一个 Java 8 的 Predicate，可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。断言的输入类型是一个 ServerWebExchange。</p>
<h1 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h1><p>SpringCloud Gateway 支持两种不同的用法：</p>
<ul>
<li>编码式</li>
<li>yml 配置</li>
</ul>
<h3 id="2-1-首先来看编码式："><a href="#2-1-首先来看编码式：" class="headerlink" title="2.1 首先来看编码式："></a>2.1 首先来看编码式：</h3><p>创建  Spring Boot 项目，添加依赖：<br><img src="https://img-blog.csdnimg.cn/20201118154026799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>项目创建成功后，直接配置一个 RouteLocator 这样一个Bean,就可以实现请求转发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="function">RouteLocator <span class="title">routeLocator</span><span class="params">(RouteLocatorBuilder builder)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 可以添加多个</span></span><br><span class="line">      <span class="keyword">return</span> builder.routes()</span><br><span class="line">              <span class="comment">// 访问网址 http://httpbin.org</span></span><br><span class="line">              <span class="comment">// 通过网关后访问 http://localhost:8080/get</span></span><br><span class="line">              .route(<span class="string">&quot;javaboy&quot;</span>, r -&gt; r.path(<span class="string">&quot;/get&quot;</span>).uri(<span class="string">&quot;http://httpbin.org&quot;</span>))</span><br><span class="line">              .build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里只需提供 RouteLocator 的Bean 就可实现请求转发，配置完成后，访问 <a href="http://localhost:8080/get">http://localhost:8080/get</a> 就会转发至 <a href="http://httpbin.org/">http://httpbin.org</a> 接口。</p>
<h3 id="2-2-yml-配置"><a href="#2-2-yml-配置" class="headerlink" title="2.2 yml 配置"></a>2.2 yml 配置</h3><p>注释掉上面的Bean ，配置如下yml，重启服务与源来效果相同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: java</span><br><span class="line">          uri: http://httpbin.org</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/get</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3-与微服务结合"><a href="#2-3-与微服务结合" class="headerlink" title="2.3 与微服务结合"></a>2.3 与微服务结合</h3><p>还是延用以前的eurek server和provider以及gateway。首先给 gateway 添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201118170657355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>然后配置yml ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          # 开启自动代理</span><br><span class="line">          enabled: true</span><br><span class="line">          # 服务id为true --&gt; 这样小写服务就可访问了</span><br><span class="line">          lower-case-service-id: true</span><br><span class="line">  application:</span><br><span class="line">    name: gateway</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url：</span><br><span class="line">      defaultZone: http://localhost:1111/eureka</span><br><span class="line"></span><br><span class="line">#日志</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org.springframework.cloud.gateway: debug</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来启动eurek server和provider以及gateway，就可以通过gateway (<a href="http://localhost:8080/provider/hello">http://localhost:8080/provider/hello</a>)<br>访问到其他注册到Erueka上的服务了。访问方式和Zuul 类似。<br><strong>小结</strong>：gateway 注册到 eureka ，就可以自动代理注册中心的所有服务，简化路由配置的使用方式。</p>
<h1 id="3-Predicate-断言"><a href="#3-Predicate-断言" class="headerlink" title="3. Predicate(断言)"></a>3. Predicate(断言)</h1><h4 id="3-1-时间断言"><a href="#3-1-时间断言" class="headerlink" title="3.1 时间断言"></a>3.1 时间断言</h4><ul>
<li>Before –&gt; 请求时间在某个时间点之前 才会被路由</li>
<li>After –&gt; 请求时间在某个时间点之后 才会被路由</li>
<li>Between –&gt; 请求时间在2个时间点之间(两个时间点,分开)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: before_route</span><br><span class="line">          uri: http://www.baidu.com</span><br><span class="line">              # 时间断言</span><br><span class="line">          predicates:</span><br><span class="line">              - Before=2021-03-31T08:38:47+08:00</span><br></pre></td></tr></table></figure>
<p>访问：  localhost:8080  如下：<br><img src="https://img-blog.csdnimg.cn/20201119100145470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>如果改为 - Before=2020-03-31T08:38:47+08:00 重启访问后如下：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201119100322920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-2-请求方法-amp-请求路径断言"><a href="#3-2-请求方法-amp-请求路径断言" class="headerlink" title="3.2 请求方法&amp;请求路径断言"></a>3.2 请求方法&amp;请求路径断言</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: java_route</span><br><span class="line">          uri: http://httpbin.org</span><br><span class="line">          predicates:</span><br><span class="line">               - Method=GET</span><br></pre></td></tr></table></figure>
<p>上面这个配置表示只给 <strong>GET</strong>请求路由，访问 <a href="http://localhost:8080/get">http://localhost:8080/get</a> 就成功。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: java_route</span><br><span class="line">          uri: http://httpbin.org</span><br><span class="line">          predicates:</span><br><span class="line">              - Path=/2020/0912/&#123;segment&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这个配置表示路径满足这个规则都会进行转发，例如：<a href="http://www.xxx.com/2020/0912/">http://www.xxx.com/2020/0912/</a>** ，否则不转发。</p>
<h4 id="3-3-Query-断言"><a href="#3-3-Query-断言" class="headerlink" title="3.3 Query 断言"></a>3.3 Query 断言</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: java_route</span><br><span class="line">          uri: http://httpbin.org</span><br><span class="line">          predicates:</span><br><span class="line">               - Query=name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面配置表示一定要有 name 参数才转发，否则不会转发。<br>也可以指定参数的值，例如参数的 key 为 name ，value 必须要以 java 开始。 如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: java_route</span><br><span class="line">          uri: http://httpbin.org</span><br><span class="line">          predicates:</span><br><span class="line">               - Query=name,java.*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-4-多种匹配方式"><a href="#3-4-多种匹配方式" class="headerlink" title="3.4 多种匹配方式"></a>3.4 多种匹配方式</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        # 组合使用</span><br><span class="line">        - id: many_route</span><br><span class="line">          uri: http://httpbin.org</span><br><span class="line">          predicates:</span><br><span class="line">            # 可以指定参数和值 ?name=1开头的值</span><br><span class="line">            - Query=name,1.*</span><br><span class="line">            - Method=GET</span><br><span class="line">            - After=2020-03-01T08:38:47+08:00</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>满足以上条件即可转发。</p>
<h4 id="3-5-自定义路由断言"><a href="#3-5-自定义路由断言" class="headerlink" title="3.5 自定义路由断言"></a>3.5 自定义路由断言</h4><p>配置自定义断言工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义路由断言工厂</span></span><br><span class="line"><span class="comment">// 命名需要以RoutePredicateFactory结尾 比aRoutePredicateFactory 那么yml在使用时a就是断言工厂的名字</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckAuthRoutePredicateFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRoutePredicateFactory</span>&lt;<span class="title">CheckAuthRoutePredicateFactory</span>.<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckAuthRoutePredicateFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(User.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 自定义配置类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="title">apply</span><span class="params">(User config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入apply：&quot;</span> + config.getName());</span><br><span class="line">            <span class="keyword">if</span> (config.getName().equals(<span class="string">&quot;kitty&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>yml 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        # 自定义断言工厂 -name就是之前以xxxRoutePredicateFactory的xxxx为断言工厂名</span><br><span class="line">        - id: customer_route</span><br><span class="line">          uri: http://httpbin.org</span><br><span class="line">          predicates:</span><br><span class="line">          - name: CheckAuth</span><br><span class="line">            args:</span><br><span class="line">              name: kitty</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当参数name=kitty与自定义断言工厂的getName一致时：</p>
<p><img src="https://img-blog.csdnimg.cn/20201119104914857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>当参数name=kitty与自定义断言工厂的getName不一致时</p>
<p><img src="https://img-blog.csdnimg.cn/20201119104924143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="4-Filter（过滤器）"><a href="#4-Filter（过滤器）" class="headerlink" title="4. Filter（过滤器）"></a>4. Filter（过滤器）</h1><p>gateway过滤器分类：</p>
<ul>
<li>GlobalFilter</li>
<li>GatewayFilter<blockquote>
<p>这里的过滤器就是在请求转发的时候，自动额外添加参数。</p>
</blockquote>
<h4 id="4-1-AddRequestParameter过滤器使用"><a href="#4-1-AddRequestParameter过滤器使用" class="headerlink" title="4.1 AddRequestParameter过滤器使用"></a>4.1 AddRequestParameter过滤器使用</h4></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: java_route</span><br><span class="line">          uri: lb://provider</span><br><span class="line">          filters:</span><br><span class="line">            - AddRequestParameter=name,javaboy</span><br><span class="line">          predicates:</span><br><span class="line">              - Method=GET</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201119110829781.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Sleuth 笔记补充</title>
    <url>/2020/08/15/Spring%20Cloud%20Sleuth%20%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85-springcloudsleuth%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>@[TOC](Spring Cloud Sleuth)</p>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在大规模的分布式系统中，一个完整的系统是由很多种不同的服务来共同支撑的。不同的系统可能分布在上千台服务器上，横跨多个数据中心。一旦系统出问题，此时的问题定位就比较麻烦。</p>
<p>分布式链路追踪：<br>在微服务环境下，一次客户端请求，可能会引起数十次、上百次的服务之间的调用。一旦请求出问题了，我们需要考虑很多东西：</p>
<ul>
<li>如何快速定位问题？</li>
<li>如何快速确定此次客户端调用，都涉及到哪些服务？</li>
<li>到底是哪一个服务出问题了</li>
</ul>
<p>要解决以上问题，就涉及到分布式链路追踪。</p>
<p>分布式链路追踪系统主要用来跟踪服务调用记录的，一般来说，一个分布式链路追踪系统，有三个部分：</p>
<ul>
<li>数据收集</li>
<li>数据存储</li>
<li>数据展示 </li>
</ul>
<p>Spring Cloud Sleuth 是Spring Cloud 提供的一套分布式链路追踪系统。</p>
<p>trace ： 从请求到达系统开始，到给请求作出响应，这样一个过程称为 trace</p>
<p>span ： 从每次调用服务时，埋入的一个调用记录，称为 span</p>
<p>annotation ： 相当于 span 的语法，描述 span 所处的状态。</p>
<h1 id="2-简单应用"><a href="#2-简单应用" class="headerlink" title="2. 简单应用"></a>2. 简单应用</h1><p>新创建一个项目，引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来创建 HelloController ，打印日志测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(HelloController.class);</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello Spring Cloud Sleuth!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello Spring Cloud Sleuth&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给服务配置名字，在输出的日志中会体现出来：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=first-sleuth</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后启动服务，访问 ：<a href="http://127.0.0.1:8080/hello%EF%BC%8C%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://127.0.0.1:8080/hello，打印日志，如下图：</a> 右边标记的就是 Spring Cloud Sleuth 的输出。</p>
<p><img src="https://img-blog.csdnimg.cn/20201205111819636.png" alt="在这里插入图片描述"></p>
<p>在定义两个接口，在 hello2 中调用 hello3 ，形成调用链：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       log.info(<span class="string">&quot;hello 2&quot;</span>);</span><br><span class="line">       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">       <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://127.0.0.1:8080/hello3&quot;</span>,String.class);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/hello3&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">hello3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       log.info(<span class="string">&quot;hello 3&quot;</span>);</span><br><span class="line">       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;hello 3&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://127.0.0.1:8080/hello2%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:8080/hello2，如下：</a></p>
<p><img src="https://img-blog.csdnimg.cn/20201205114111692.png" alt="在这里插入图片描述"></p>
<p>一个 trace 由多个 span 组成，一个 trace 相当于就是一个调用链，而一个 span 则是这个链中的每一次调用过程。</p>
<h2 id="2-1-异步任务"><a href="#2-1-异步任务" class="headerlink" title="2.1 异步任务"></a>2.1 异步任务</h2><h4 id="2-1-1-Spring-Cloud-Sleuth-中也可以收集到异步任务中的消息"><a href="#2-1-1-Spring-Cloud-Sleuth-中也可以收集到异步任务中的消息" class="headerlink" title="2.1.1 Spring Cloud Sleuth 中也可以收集到异步任务中的消息"></a>2.1.1 Spring Cloud Sleuth 中也可以收集到异步任务中的消息</h4><p>开启异步任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">//开启异步任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleuthApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SleuthApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个 HelloService ，提供一个异步任务方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(HelloController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">backgroundFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;backgroundFun!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;backgroundFun&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 HelloController 中调用异步任务方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello4&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello 4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> helloService.backgroundFun();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>启动项目，访问 /hello4 测试，Sleuth 也打印日志了，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201205140524550.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>总结： 在异步任务中，异步任务是相同的 traceId ，不同的 spanId</strong>。</p>
</blockquote>
<h4 id="2-1-2-Spring-Cloud-Sleuth-中也可以手机设定定时任务"><a href="#2-1-2-Spring-Cloud-Sleuth-中也可以手机设定定时任务" class="headerlink" title="2.1.2 Spring Cloud Sleuth 中也可以手机设定定时任务"></a>2.1.2 Spring Cloud Sleuth 中也可以手机设定定时任务</h4><p>首先开启定时任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">//开启异步任务</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">//开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleuthApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SleuthApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 HelloService 中添加定时任务，去调用 backgroun 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/10 * * * * ?&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sche1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;start:&quot;</span>);</span><br><span class="line">    backgroundFun();</span><br><span class="line">    log.info(<span class="string">&quot;end:&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后访问 /hello4 接口测试，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201205142530242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>总结： 在定时任务中，每次定时任务都会产生一个新的 Trace ，并且在调用过程中 spanId 都是一致的，这点和普通的调用不一样</strong>。</p>
</blockquote>
<h1 id="3-Zipkin"><a href="#3-Zipkin" class="headerlink" title="3. Zipkin"></a>3. Zipkin</h1><p>Zipkin 本身是 Twitter 公司开源的分布式追踪系统。</p>
<p>Zipkin 分为 server 端和 client 端， server 用来展示数据， client 用来收集 + 上报数据。</p>
<h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><p>Zipkin 要先把数据存储起来，这里我们使用 Elasticsearch 来存储，所以，首先安装 es 和 es-head。这里假设 docker 已经安装并启动。</p>
<p>es 安装命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.1.0</span><br></pre></td></tr></table></figure>
<p>可视化工具有三种安装方式：</p>
<ol>
<li>直接下载软件安装</li>
<li>通过  docker 安装</li>
<li>安装 Chrome / Firefox 插件 【这里采用第三种方式，插件名称：ElasticSearch Head】</li>
</ol>
<p>然后<a href="https://blog.csdn.net/ourstronger/article/details/100764478">安装 RabbitMQ</a></p>
<p>Zipkin 安装：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9411:9411 --name zipkin -e ES_HOSTS=192.168.1.132 -e STORAGE_TYPE=elasticsearch -e ES_HTTP_LOGGING=BASIC -e RABBIT_URI=amqp://guest:guest@192.168.1.132:5672 openzipkin/zipkin</span><br></pre></td></tr></table></figure>
<ul>
<li>ES_HOSTS ：es 的地址</li>
<li>STORAGE_TYPE ：数据存储方式</li>
<li>RABBIT_URI ： 要连接的 rabbitMQ 地址</li>
</ul>
<p>安装完成后，浏览器访问：<a href="http://192.168.1.132:9411/zipkin/">http://192.168.1.132:9411/zipkin/</a> ，如下图： 表示安装成功。<br><img src="https://img-blog.csdnimg.cn/20201205163931942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-2-实践"><a href="#3-2-实践" class="headerlink" title="3.2 实践"></a>3.2 实践</h3><p>新建项目，添加如下依赖：<img src="https://img-blog.csdnimg.cn/20201205161608149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>创建成功后，配置 zipkin 和 rabbitmq：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=zipkin01</span><br><span class="line"></span><br><span class="line"># 开启链路追踪</span><br><span class="line">spring.sleuth.web.client.enabled=true</span><br><span class="line"># 配置采样比例，默认为 0.1</span><br><span class="line">spring.sleuth.sampler.probability=1</span><br><span class="line"># zipkin 地址</span><br><span class="line">spring.zipkin.base-url=http://192.168.1.132:9411</span><br><span class="line"># 开启 zipkin</span><br><span class="line">spring.zipkin.enabled=true</span><br><span class="line"># 追踪消息的发送类型</span><br><span class="line">spring.zipkin.sender.type=rabbit</span><br><span class="line"></span><br><span class="line">spring.rabbitmq.host=192.168.1.132</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br></pre></td></tr></table></figure>
<p>接下来提供一个测试的 Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloController.class);</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;zipkin01-hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name +<span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再创建一个 zipkin02 ，和 zipkin01 的配置基本一致，修改 zipkin02 的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=zipkin02</span><br><span class="line"></span><br><span class="line"># 开启链路追踪</span><br><span class="line">spring.sleuth.web.client.enabled=true</span><br><span class="line"># 配置采样比例，默认为 0.1</span><br><span class="line">spring.sleuth.sampler.probability=1</span><br><span class="line"># zipkin 地址</span><br><span class="line">spring.zipkin.base-url=http://192.168.1.132:9411</span><br><span class="line"># 开启 zipkin</span><br><span class="line">spring.zipkin.enabled=true</span><br><span class="line"># 追踪消息的发送类型</span><br><span class="line">spring.zipkin.sender.type=rabbit</span><br><span class="line"></span><br><span class="line">spring.rabbitmq.host=192.168.1.132</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line"></span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure>
<p>添加RestTemplate ， 修改 zipkin02 的 Controller ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloController.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        String s = restTemplate.getForObject(<span class="string">&quot;http://127.0.0.1:8080/hello?name=&#123;1&#125;&quot;</span>, String.class, <span class="string">&quot;javaboy&quot;</span>);</span><br><span class="line">        logger.info(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分别启动 zipkin01 和 zipkin02 ，启动成功后，访问：<a href="http://127.0.0.1:8081/hello?name=qqq">http://127.0.0.1:8081/hello?name=qqq</a>，查看控制台， traceId 和 spanId 均已输出。然后浏览器访问：<br><a href="http://192.168.1.132:9411/zipkin/">http://192.168.1.132:9411/zipkin/</a>， 所有的信息都已经可视化的展示出来了。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201205170123186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020120517015519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上是数据的可视化展示，那么数据本身在哪里呢？打开Chrome的 Elasticsearch Head 插件，访问： <a href="http://192.168.1.132:9200/">http://192.168.1.132:9200/</a> 连接，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201205171009213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后访问 ： <a href="http://192.168.1.132:15672/">http://192.168.1.132:15672/</a> ，登陆后，发现 zipkin 已经添加至 rabbitMQ 队列中。<br><img src="https://img-blog.csdnimg.cn/20201205170318616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时，这三个已经连通起来了。数据从 rabbitmq 传递到 es 上面去，es再可视化展示出来。</p>
<p>项目地址：**<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a>**</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Stream （消息驱动）笔记补充</title>
    <url>/2020/08/15/Spring%20Cloud%20Stream%20%EF%BC%88%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%EF%BC%89%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85-springcloudstream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>@[TOC](Spring Cloud Stream 笔记补充)</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring Cloud Stream 是一个用来为微服务应用构建消息驱动能力的框架。它可以基于 Spring Boot 来创建独立的、可用于生产的 Spring 应用程序。Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并引入了发布-订阅、消费组、分区这三个核心概念。</p>
<p>通过使用 Spring Cloud Stream，可以有效简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。但是目前 Spring Cloud Stream 只支持 RabbitMQ 和 Kafka 的自动化配置。</p>
<p>Spring Cloud Stream 提供了 Binder (负责与消息中间件进行交互)，我们则通过 inputs 或者 outputs 这样的消息通道与 Binder 进行交互。</p>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p>创建一个Spring Cloud Stream项目，添加如下三个依赖：<br><img src="https://img-blog.csdnimg.cn/20201201151240532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>项目创建成功后，添加Rabbitmq基本配置信息，这里默认已经启动 Rabbitmq：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.rabbitmq.host=192.168.1.132</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br></pre></td></tr></table></figure>
<p>然后创建一个简单的<strong>消息接收器</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该注解表示绑定Sink消息通道</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MsgReceiver.class);</span><br><span class="line">    <span class="comment">// 自带 消费者</span></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span><span class="comment">//(sink是一个默认的消息通道)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;received: &quot;</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 stream 项目，然后在 rabbitmq 后台管理页面去发送一条消息：</p>
<p><img src="https://img-blog.csdnimg.cn/20201201155015302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在IDEA 控制台会收到消息，此时说明消息已经成功发送并且消费。如下图：<br><img src="https://img-blog.csdnimg.cn/20201201155114270.png" alt="在这里插入图片描述"></p>
<h1 id="自定义消息通道"><a href="#自定义消息通道" class="headerlink" title="自定义消息通道"></a>自定义消息通道</h1><p>首先创建一个名叫 MyChannel 的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyChannel</span> </span>&#123;</span><br><span class="line">    String INPUT = <span class="string">&quot;test-input&quot;</span>;</span><br><span class="line">    String OUTPUT = <span class="string">&quot;test-output&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这两个通道可能定义在两个不同的通道里面，这里为了方便放在同一个项目中演示</span></span><br><span class="line"><span class="comment">     * F版之前消息通道的名称可以相同</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 收(订阅频道/消息消费者)</span></span><br><span class="line">    <span class="meta">@Input(INPUT)</span></span><br><span class="line">    <span class="function">SubscribableChannel <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发（消息生产者）</span></span><br><span class="line">    <span class="meta">@Output(OUTPUT)</span></span><br><span class="line">    <span class="function">MessageChannel <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>两个消息通道的名字是不一样的</li>
<li>从 F 版开始，默认使用通道的名称作为实例命令，所以这里的通道名称<strong>不同</strong> (早期版本可以相同)，这样的话，为了能够正常收发消息，需要我们在 application.properties 中做一些额外的配置。</li>
</ol>
</blockquote>
<p>接下来自定义一个<strong>消息接收器</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定自定义消息通道【 MyChannel 为刚才自己建立的通道】</span></span><br><span class="line"><span class="meta">@EnableBinding(MyChannel.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgReceiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MsgReceiver1.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收器</span></span><br><span class="line">    <span class="meta">@StreamListener(MyChannel.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;received1: &quot;</span> + payload + <span class="string">&quot;:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 HelloController 进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyChannel myChannel;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myChannel.output().send(MessageBuilder.withPayload(<span class="string">&quot;你好 spring cloud stream!&quot;</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，因为现在这两个通道的名称不同，为了让消息输入输出通道对接上，再增加一些额外配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 此处的test-input/test-output 与实际的输入输出通道一致即可，test-topic 要配置一样； </span><br><span class="line">spring.cloud.stream.bindings.test-input.destination=test-topic</span><br><span class="line">spring.cloud.stream.bindings.test-output.destination=test-topic</span><br></pre></td></tr></table></figure>
<p>启动服务，访问 <a href="http://localhost:8080/hello%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8080/hello，如下：</a><br><img src="https://img-blog.csdnimg.cn/20201202143550594.png" alt="在这里插入图片描述"></p>
<h1 id="消息分组"><a href="#消息分组" class="headerlink" title="消息分组"></a>消息分组</h1><p>紧接上文。默认情况下，如果消费者是一个集群，此时，一条消息会被多次消费。通过消息分组，我们可以解决这个问题。</p>
<p>添加如下配置分组，放入组 g1：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.bindings.test-input.destination=test-topic</span><br><span class="line">spring.cloud.stream.bindings.test-output.destination=test-topic</span><br><span class="line"> </span><br><span class="line">spring.cloud.stream.bindings.test-input.group=g1</span><br><span class="line">spring.cloud.stream.bindings.test-output.group=g1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后对 Spring Cloud Stream 项目进行打包，打包完毕后，在 target 目录下分别启动：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">java -jar stream-0.0.1-SNAPSHOT.jar </span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">java -jar stream-0.0.1-SNAPSHOT.jar --server.port=8081</span><br></pre></td></tr></table></figure>

<p>运行访问 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a></p>
<p><img src="https://img-blog.csdnimg.cn/20201202153209751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201202153223349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图，现在<strong>同一个消息只能被一个实例消费</strong>，至于是哪一个，不可控。但是可以确定的只被一个实例消费。</p>
<h1 id="消息分区"><a href="#消息分区" class="headerlink" title="消息分区"></a>消息分区</h1><p>在分组的基础上，通过消息分区可以实现<strong>相同特征</strong>的消息总是被同一个实例处理。只需要添加如下配置即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 分为同一个组g1</span><br><span class="line">spring.cloud.stream.bindings.test-input.group=g1</span><br><span class="line">spring.cloud.stream.bindings.test-output.group=g1</span><br><span class="line"></span><br><span class="line"># 开启消息分区 （消费者上配置）</span><br><span class="line">spring.cloud.stream.bindings.test-input.consumer.partitioned=true</span><br><span class="line"># 消费者实例个数 （消费者上配置）</span><br><span class="line">spring.cloud.stream.instance-count=2</span><br><span class="line"># 当前实例的下标 （消费者上配置）</span><br><span class="line">spring.cloud.stream.instance-index=0</span><br><span class="line"># (生产者上配置)【此处为方便放一起】</span><br><span class="line"># 表示消息将被下标为1的消费者所消费</span><br><span class="line">spring.cloud.stream.bindings.test-output.producer.partition-key-expression=1</span><br><span class="line"># 消费端的节点数量（生产者上配置）</span><br><span class="line">spring.cloud.stream.bindings.test-output.producer.partition-count=2</span><br></pre></td></tr></table></figure>
<p>注意，启动时 spring.cloud.stream.instance-index 参数要修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">java -jar stream-0.0.1-SNAPSHOT.jar --server.port=8080 --spring.cloud.stream.instance-index=0</span><br><span class="line">java -jar stream-0.0.1-SNAPSHOT.jar --server.port=8081 --spring.cloud.stream.instance-index=1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后继续 <strong>多次</strong> 访问 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> ，由于配置了spring.cloud.stream.bindings.test-output.producer.partition-key-expression=1 ，并且正如上文所说，此时的消息具有<strong>相同的特征</strong>。所以<strong>消息将被下标为 1 的消费者所消费</strong>，也就是 8081 端口消费，不会被 8080 端口消费。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201202161507377.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201202161554481.png" alt="在这里插入图片描述"></p>
<h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><p>每天定时执行的任务，可以使用 cron 表达式， 有一种比较特殊的定时任务，例如几分钟后执行，这种可以结合 Spring Cloud Stream + RabbitMQ 来实现。</p>
<p>首先需要下载一个 rabbitMQ 插件：<a href="https://dl.bintray.com/rabbitmq/community-plugins/3.7.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171201-3.7.x.zip"><strong>点击这里下载</strong></a>，下载完后上传至root目录下。</p>
<p>执行如下命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> # 将上传的文件解压</span><br><span class="line"> unzip rabbitmq_delayed_message_exchange-20171201-3.7.x.zip </span><br><span class="line"> # 将解压后的文件拷贝到 docker 容器中【lemon-rabbit 是docker中rabbitmq 的 NAMES】</span><br><span class="line">docker cp /root/rabbitmq_delayed_message_exchange-20171201-3.7.x.ez lemon-rabbit:/plugins</span><br><span class="line"> # 进入到容器中</span><br><span class="line">docker exec -it lemon-rabbit /bin/bash</span><br><span class="line"> # 启用插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line"> # 查看是否启用成功</span><br><span class="line">rabbitmq-plugins list</span><br></pre></td></tr></table></figure>

<p>配置文件中开启消息延迟功能：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 绑定通道</span><br><span class="line">spring.cloud.stream.bindings.test-input.destination=topic</span><br><span class="line">spring.cloud.stream.bindings.test-output.destination=topic</span><br><span class="line"></span><br><span class="line"># 开启消息延迟功能</span><br><span class="line">spring.cloud.stream.rabbit.bindings.test-input.consumer.delayed-exchange=true</span><br><span class="line">spring.cloud.stream.rabbit.bindings.test-output.producer.delayed-exchange=true</span><br></pre></td></tr></table></figure>
<p>在消息发送时，将消息延迟设置为 3 秒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MsgReceiver1.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyChannel myChannel;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;send msg:&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        myChannel.output().send(MessageBuilder.withPayload(<span class="string">&quot;你好 spring cloud stream!&quot;</span>).setHeader(<span class="string">&quot;x-delay&quot;</span>,<span class="number">3000</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时在消息接收时，打印出延迟时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(MyChannel.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgReceiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MsgReceiver1.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收器</span></span><br><span class="line">    <span class="meta">@StreamListener(MyChannel.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;received1: &quot;</span> + payload + <span class="string">&quot;:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动项目，访问 ：<a href="http://localhost:8080/hello">http://localhost:8080/hello</a> ，延迟3秒 ，如下图：<img src="https://img-blog.csdnimg.cn/20201203112920135.png" alt="在这里插入图片描述"><br>项目地址：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 入门</title>
    <url>/2020/04/22/Spring%20Cloud%20%E5%85%A5%E9%97%A8-Spring%20Cloud%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>简单粗暴的记录一下微服务以及spring cloud </p>
<h3 id="1-什么是微服务"><a href="#1-什么是微服务" class="headerlink" title="1.什么是微服务"></a>1.什么是微服务</h3><p>       简单来说，微服务就是一种将一个单一应用程序拆分为一组小型服务的方法，拆分完成后，每一个服务都运行在独立的进程中，服 务于服务之间采用轻量级的通信机制来进行沟通（Spring Cloud 中采用基于HTTP 的 RESTful API）。<br>       每一个服务，都是围绕具体的业务进行构建，例如一个电商系统，订单服务、支付服务、物流服务、会员服务等等，这些拆分后的应用都是独立的应用，都可以独立的部署到生产环境中。就是在采用微服务之后，我们的项目不再拘泥于一种语言，可以 Java、Go、Python、PHP 等等，混合使用，这在传统的应用开发中，是无法想象的。而使用了微服务之后，我们可以根据业务上下文来选择合适的语言和构建工具进行构建。<br>       微服务可以理解为是 SOA 的一个传承，一个本质的区别是微服务是一个真正分布式、去中心化的，微服务的拆分比 SOA 更加彻底。</p>
<h3 id="2-微服务优势"><a href="#2-微服务优势" class="headerlink" title="2.微服务优势"></a>2.微服务优势</h3><ol>
<li>复杂度可控</li>
<li>独立部署</li>
<li>技术选型灵活</li>
<li>较好的容错性</li>
<li>较强的可扩展性</li>
</ol>
<h3 id="3-Spring-Cloud-介绍"><a href="#3-Spring-Cloud-介绍" class="headerlink" title="3.Spring Cloud 介绍"></a>3.Spring Cloud 介绍</h3><h4 id="3-1什么是-Spring-Cloud"><a href="#3-1什么是-Spring-Cloud" class="headerlink" title="3.1什么是 Spring Cloud"></a>3.1什么是 Spring Cloud</h4><p>Spring Cloud 是一系列框架的集合，Spring Cloud 内部包含了许多框架，这些框架互相协作，共同来构建分布式系统。利用这些组件，可以非常方便的构建一个分布式系统。</p>
<h4 id="3-2-使用-Spring-Cloud-的优势"><a href="#3-2-使用-Spring-Cloud-的优势" class="headerlink" title="3.2 使用 Spring Cloud 的优势"></a>3.2 使用 Spring Cloud 的优势</h4><p>       Spring Cloud 可以理解为微服务这种思想在 Java 领域的一个具体落地。Spring Cloud 在发展之初，就借鉴了微服务的思想，同时结合 Spring Boot，Spring Cloud 提供了组件的一键式启动和部署的能力，极大的简化了微服务架构的落地。<br>       Spring Cloud 这种框架，从设计之初，就充分考虑了分布式架构演化所需要的功能，例如服务注册、配置中心、消息总线以及负载均衡等。这些功能都是以可插拔的形式提供出来的，这样，在分布式系统不断演化的过程中，我们的 Spring Cloud 也可以非常方便的进化。</p>
<h4 id="3-3核心特性"><a href="#3-3核心特性" class="headerlink" title="3.3核心特性"></a>3.3核心特性</h4><ol>
<li>服务注册与发现</li>
<li>负载均衡</li>
<li>服务之间调用</li>
<li>容错、服务降级、断路器</li>
<li>消息总线</li>
<li>分布式配置中心</li>
<li>链路器</li>
</ol>
<h4 id="3-4版本名称"><a href="#3-4版本名称" class="headerlink" title="3.4版本名称"></a>3.4版本名称</h4><p>不同于其他的框架，Spring Cloud 版本名称是通过 A（Angel）、B（Brixton）、C（Camden）、D（Dalston）、E（Edgware）、F（Finchley）。。 这样来明明的，这些名字使用了伦敦地铁站的名字，目前最新版是 H （Hoxton）版。<br>Spring Cloud 中，除了大的版本之外，还有一些小版本，小版本命名方式如下：<br>1.M ，M 版是 milestone 的缩写，所以我们会看到一些版本叫 M1、M2<br>2.RC，RC 是 Release Candidate，表示该项目处于候选状态，这是正式发版之前的一个状态，所以<br>我们会看到 RC1、RC2<br>3.SR，SR 是 Service Release ，表示项目正式发布的稳定版，其实相当于 GA（Generally<br>Available） 版。所以，我们会看到 SR1、SR2<br>4.SNAPSHOT，这个表示快照版。</p>
<h4 id="3-5-Spring-Cloud-包含的组件"><a href="#3-5-Spring-Cloud-包含的组件" class="headerlink" title="3.5 Spring Cloud 包含的组件"></a>3.5 Spring Cloud 包含的组件</h4><p>Spring Cloud Netflix，这个组件，在 Spring Cloud 成立之初，立下了汗马功劳。但是， 2018 年的断更，也是 Netflix 掉链子了。<br>Spring Cloud Config，分布式配置中心，利用 Git/Svn 来集中管理项目的配置文件<br>Spring Cloud Bus，消息总线，可以构建消息驱动的微服务，也可以用来做一些状态管理等<br>Spring Cloud Consul，服务注册发现<br>Spring Cloud Stream，基于 Redis、RabbitMQ、Kafka 实现的消息微服务<br>Spring Cloud OpenFeign，提供 OpenFeign 集成到 Spring Boot 应用中的方式，主要解决微服务之间的调用问题<br>Spring Cloud Gateway，Spring Cloud 官方推出的网关服务<br>Spring Cloud Cloudfoundry，利用 Cloudfoundry 集成我们的应用程序<br>Spring Cloud Security，在 Zuul 代理中，为 OAuth2 客户端认证提供支持<br>Spring Cloud AWS ，快速集成亚马逊云服务<br>Spring Cloud Contract，一个消费者驱动的、面向 Java 的契约框架<br>Spring Cloud Zookeeper，基于 Apache Zookeeper 的服务注册和发现<br>Spring Cloud Data Flow，在一个结构化的平台上，组成数据微服务<br>Spring Cloud Kubernetes，Spring Cloud 提供的针对 Kubernetes 的支持<br>Spring Cloud Function<br>Spring Cloud Task，短生命周期的微服务</p>
<h4 id="3-6-Spring-Cloud-和-Spring-Boot-版本关系"><a href="#3-6-Spring-Cloud-和-Spring-Boot-版本关系" class="headerlink" title="3.6 Spring Cloud 和 Spring Boot 版本关系"></a>3.6 Spring Cloud 和 Spring Boot 版本关系</h4><p>  <br>|Spring Cloud|Spring Boot|<br>|——-|——-|<br>|Hoxton    |2.2.x|<br>|Greenwich|2.1.x|<br>|Finchley|2.0.x|<br>|Edgware|1.5.x|<br>|Dalston|1.5.x|</p>
<p>参考： <a href="https://wx.zsxq.com/dweb2/index/group/28518511144481">https://wx.zsxq.com/dweb2/index/group/28518511144481</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Security 使用 JSON 登录</title>
    <url>/2019/07/10/Spring%20Security%20%E4%BD%BF%E7%94%A8%20JSON%20%E7%99%BB%E5%BD%95-Spring%20Security%20%E4%BD%BF%E7%94%A8%20JSON%20%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>首先创建 SpringBoot 工程，添加 SpringSecurity 依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果想将用户名密码通过 JSON 的方式进行传递，则需要自定义相关过滤器，通过分析源码我们发现，默认的用户名密码提取在 UsernamePasswordAuthenticationFilter 过滤器中，部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">		<span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FORM_USERNAME_KEY = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FORM_PASSWORD_KEY = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;</span><br><span class="line">	<span class="keyword">private</span> String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> postOnly = <span class="keyword">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;POST&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">			HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line">					<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		String username = obtainUsername(request);</span><br><span class="line">		String password = obtainPassword(request);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">			username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">			password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		username = username.trim();</span><br><span class="line"> </span><br><span class="line">		UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">				username, password);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Allow subclasses to set the &quot;details&quot; property</span></span><br><span class="line">		setDetails(request, authRequest);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">obtainPassword</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> request.getParameter(passwordParameter);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">obtainUsername</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> request.getParameter(usernameParameter);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到，默认的用户名/密码提取就是通过 request 中的 getParameter 来提取的，如果想使用 JSON 传递用户名密码，只需要将这个过滤器替换掉即可，自定义过滤器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">                || request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) &#123;</span><br><span class="line">            ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> (InputStream is = request.getInputStream()) &#123;</span><br><span class="line">                Map&lt;String,String&gt; authenticationBean = mapper.readValue(is, Map.class);</span><br><span class="line">                authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                        authenticationBean.get(<span class="string">&quot;username&quot;</span>), authenticationBean.get(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                setDetails(request, authRequest);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.attemptAuthentication(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是将用户名/密码的获取方案重新修正下，改为了从 JSON 中获取用户名密码，然后在 SecurityConfig 中作出如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">    http.addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">CustomAuthenticationFilter <span class="title">customAuthenticationFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CustomAuthenticationFilter filter = <span class="keyword">new</span> CustomAuthenticationFilter();</span><br><span class="line">    filter.setAuthenticationSuccessHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            PrintWriter out = resp.getWriter();</span><br><span class="line">            RespBean respBean = RespBean.ok(<span class="string">&quot;登录成功!&quot;</span>);</span><br><span class="line">            out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    filter.setAuthenticationFailureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            PrintWriter out = resp.getWriter();</span><br><span class="line">            RespBean respBean = RespBean.error(<span class="string">&quot;登录失败!&quot;</span>);</span><br><span class="line">            out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    filter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">    <span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将自定义的 CustomAuthenticationFilter 类加入进来即可，接下来就可以使用 JSON 进行登录了，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-8f591f4e5a9140d2a2340bdb4995296c.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 如何登录</title>
    <url>/2019/07/07/Spring%20Security%20%E5%A6%82%E4%BD%95%E7%99%BB%E5%BD%95-Spring%20Security%20%E5%A6%82%E4%BD%95%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>在使用 SpringSecurity 中，大家都知道默认的登录数据是通过 key/value 的形式来传递的，默认情况下不支持 JSON格式的登录数据，如果有这种需求，就需要自己来解决。</p>
<h2 id="基本登录方法"><a href="#基本登录方法" class="headerlink" title="基本登录方法"></a>基本登录方法</h2><p>本文为了简单，SpringSecurity 在使用中就不连接数据库了，直接在内存中配置用户名和密码，具体操作步骤如下：</p>
<p>首先创建 SpringBoot 工程，添加 SpringSecurity 依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="添加-Security-配置"><a href="#添加-Security-配置" class="headerlink" title="添加 Security 配置"></a>添加 Security 配置</h3><p>创建 SecurityConfig，完成 SpringSecurity 的配置，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication().withUser(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;$2a$10$2O4EwLrrFPEboTfDOtC0F.RpUMk.3q3KvBHRx7XXKUMLBGjOOBs8q&quot;</span>).roles(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        RespBean ok = RespBean.ok(<span class="string">&quot;登录成功！&quot;</span>,authentication.getPrincipal());</span><br><span class="line">                        resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(ok));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        RespBean error = RespBean.error(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">                        resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .logoutSuccessHandler(<span class="keyword">new</span> LogoutSuccessHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        RespBean ok = RespBean.ok(<span class="string">&quot;注销成功！&quot;</span>);</span><br><span class="line">                        resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(ok));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .accessDeniedHandler(<span class="keyword">new</span> AccessDeniedHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        RespBean error = RespBean.error(<span class="string">&quot;权限不足，访问失败&quot;</span>);</span><br><span class="line">                        resp.setStatus(<span class="number">403</span>);</span><br><span class="line">                        resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的配置虽然有点长，但是很基础，配置含义也比较清晰，首先提供 BCryptPasswordEncoder 作为 PasswordEncoder ，可以实现对密码的自动加密加盐，非常方便，然后提供了一个名为 zhangsan 的用户，密码是 123 ，角色是 user ，最后配置登录逻辑，所有的请求都需要登录后才能访问，登录接口是 /doLogin ，用户名的 key 是 username ，密码的 key 是 password ，同时配置登录成功、登录失败以及注销成功、权限不足时都给用户返回JSON提示，另外，这里虽然配置了登录页面为 /login ，实际上这不是一个页面，而是一段 JSON ，在 LoginController 中提供该接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(<span class="string">&quot;尚未登录，请登录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 /login 只是一个 JSON 提示，而不是页面， /hello 则是一个测试接口。</p>
<p>OK，做完上述步骤就可以开始测试了，运行SpringBoot项目，访问 /hello 接口，结果如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-8d0f65b3672c4555a1319af34d4e23e0.png" alt="image.png"></p>
<p>此时先调用登录接口进行登录，如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-c377cf8cdf51436aadfe24e4c56dda84.png" alt="image.png"></p>
<p>登录成功后，再去访问 /hello 接口就可以成功访问了。</p>
<p>参考：<a href="http://springboot.javaboy.org/2019/0613/springsecurity-json">http://springboot.javaboy.org/2019/0613/springsecurity-json</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot —— 启动类的注解</title>
    <url>/2019/04/03/SpringBoot%20%E2%80%94%E2%80%94%20%E5%90%AF%E5%8A%A8%E7%B1%BB%E7%9A%84%E6%B3%A8%E8%A7%A3-SpringBoot%20%E2%80%94%E2%80%94%20%E5%90%AF%E5%8A%A8%E7%B1%BB%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>1、SpringBoot项目创建完成之后默认会生成一个*Application的入口类，通过该类的main方法即可启动SpringBoot项目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootRunApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringbootRunApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在此入口类中，我们可以看到SpringBoot创建的业务代码中的一个注解——@SpringBootApplication，这也是SpringBoot的核心注解。源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据类排除不使用的自动配置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = EnableAutoConfiguration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据类名排除不使用的自动配置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = EnableAutoConfiguration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定扫描的包</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = ComponentScan.class,</span></span><br><span class="line"><span class="meta">        attribute = &quot;basePackages&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定扫描的类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = ComponentScan.class,</span></span><br><span class="line"><span class="meta">        attribute = &quot;basePackageClasses&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exclude：根据类排除不使用的自动配置<br>excludeName：根据类名排除不使用的自动配置；<br>scanBasePackages：扫描指定的包；<br>scanBasePackageClasses:扫描指定的类；</p>
<p><strong>@SpringBootApplication = @SpringBootConfiguration(Configuration) + @EnableAutoConfiguration + @ComponentScan</strong></p>
<p><strong>Configuration:</strong> 普通配置类。</p>
<p><strong>EnableAutoConfiguration:</strong> 开启自动化配置（Spring/SpringMVC那套东西都有了 ）。可以根据类路径中的jar包依赖可以为项目进行一些自动配置。这也是SpringBoot最核心的功能。</p>
<p><strong>ComponentScan:</strong> 用来指定扫描的组建所在的包路径或class文件（扫描启动类所在的包下面的所有类）。</p>
<p>如果忘记或不知道SpringBoot默认扫描的路径，随意创建包和类的位置，导致项目启动之后，无法实例化对应的组建，无法正确访问接口，那么我们就可以使用@ComponentScan来指定一些特殊的需要实例化的包或类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定一些特殊的需要实例化的包或类</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = “com.example.controller&quot;)</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example.controller&quot;)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot——整合Swagger2</title>
    <url>/2019/09/13/SpringBoot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Swagger2-SpringBoot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Swagger2/</url>
    <content><![CDATA[<h1 id="1-Swagger"><a href="#1-Swagger" class="headerlink" title="1.Swagger"></a>1.Swagger</h1><p>Swagger 给我们提供了一个全新的维护 API 文档的方式，可以很好地降低前端开发人员与后端开发人员对WebAPI接口的沟通成本。它可以动态生成Api接口文档，促进项目高效开发。下面我们就来了解一下它的<strong>优点</strong>：</p>
<ol>
<li>代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。</li>
<li>跨语言性，支持 40 多种语言。</li>
<li>Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</li>
<li>还可以将文档规范导入相关的工具（例如 SoapUI）, 这些工具将会为我们自动地创建自动化测试。<h2 id="在项目中常用的注解说明和案例"><a href="#在项目中常用的注解说明和案例" class="headerlink" title="在项目中常用的注解说明和案例"></a>在项目中常用的注解说明和案例</h2><img src="https://www.itmengtao.cn/upload/2020/11/%E6%8D%95%E8%8E%B7-b9e05b355180482581e9395c4f424e0c.PNG" alt="捕获.PNG"><img src="https://www.itmengtao.cn/upload/2020/11/%E6%8D%95%E8%8E%B71-b6c7896a5cb24dddb47d52df4f3fa5b0.PNG" alt="捕获1.PNG"><br>下面我们来创建一个Spring Boot项目测试一下。</li>
</ol>
<h1 id="2-工程创建"><a href="#2-工程创建" class="headerlink" title="2.工程创建"></a>2.工程创建</h1><p>首先是创建一个Spring Boot项目，创建成功后，加入web依赖，加入两个Swagger2相关的依赖，完整的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-1Swagger2配置"><a href="#2-1Swagger2配置" class="headerlink" title="2.1Swagger2配置"></a>2.1Swagger2配置</h2><p>在项目创建成功之后，只需要创建一个配置类提供一个Docket的Bean即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2Config</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .pathMapping(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.example.swagger2.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build().apiInfo(<span class="keyword">new</span> ApiInfoBuilder() </span><br><span class="line">                        .title(<span class="string">&quot;SpringBoot整合Swagger&quot;</span>)</span><br><span class="line">                        .description(<span class="string">&quot;接口文档描述信息......&quot;</span>)</span><br><span class="line">                        .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                        .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;涛声依旧&quot;</span>,<span class="string">&quot;https://blog.csdn.net/ourstronger&quot;</span>,<span class="string">&quot;aaa@gmail.com&quot;</span>)) </span><br><span class="line">                        .license(<span class="string">&quot;The Apache License&quot;</span>)</span><br><span class="line">                        .licenseUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>) </span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>@EnableSwagger2注解启用Swagger2 .</p>
</li>
<li><p>这个Bean中，配置映射路径和要扫描的接口的位置，在apiInfo中，主要配置一下Swagger2文档网站的信息，例如网站的title，网站的描述，联系人的信息，使用的协议等等。</p>
</li>
</ol>
<p>配置完后，Swagger2就算配置成功了。</p>
<p>此时启动项目，输入<a href="http://localhost:8080/swagger-ui.html%EF%BC%8C%E8%83%BD%E5%A4%9F%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%AF%B4%E6%98%8E%E5%B7%B2%E7%BB%8F%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F%E4%BA%86%EF%BC%9A">http://localhost:8080/swagger-ui.html，能够看到如下页面，说明已经配置成功了：</a></p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-ba6a648094a24f2081e0875c72d8aa97.png" alt="image.png"></p>
<h2 id="2-2-创建接口"><a href="#2-2-创建接口" class="headerlink" title="2.2.创建接口"></a>2.2.创建接口</h2><p>Swagger2相关的注解其实并不多，上文中已经列出来了，下来创建一个<strong>增删改查</strong>举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;用户数据接口&quot;)</span> <span class="comment">//标记当前Controller的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;查询用户&quot;,notes = &quot;根据id查询用户&quot;)</span></span><br><span class="line">    <span class="comment">//描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，required = true表示如果swagger测试为必填,defaultValue默认值</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name= &quot;id&quot;,value = &quot;用户id&quot;,required = true,defaultValue = &quot;66&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;删除用户&quot;,notes = &quot;根据id删&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;id&quot;,value = &quot;用户id&quot;,required = true,defaultValue = &quot;55&quot;)</span></span><br><span class="line">    <span class="meta">@ApiResponses(&#123;</span></span><br><span class="line"><span class="meta">            @ApiResponse(code = 200,message = &quot;删除成功&quot;),</span></span><br><span class="line"><span class="meta">            @ApiResponse(code = 500,message = &quot;失败&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;deleteUserById:&quot;</span>+id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;添加用户&quot;,notes = &quot;添加用户接口&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name=&quot;id&quot;,value = &quot;用户id&quot;,required = true,defaultValue = &quot;77&quot;),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name=&quot;username&quot;,value = &quot;用户名&quot;,required = true,defaultValue = &quot;taoge&quot;),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name=&quot;address&quot;,value = &quot;地址&quot;,required = true,defaultValue = &quot;深圳&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;更新用户&quot;,notes= &quot;根据id更新用户的接口&quot;)</span></span><br><span class="line"><span class="comment">//    @ApiIgnore  //表示忽略生成此接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUserById</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@ApiIgnore 注解</strong>：如果想在文档中屏蔽掉删除用户的接口（user/delete），那么只需要在删除用户的方法上加上 @ApiIgnore 即可。</p>
<p> 如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中。例如下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户地址&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过如上配置之后，接下来，刷新刚刚打开的页面，可以看到如下效果：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-e9329d58926847649f00f4da74a3e686.png" alt="image.png"></p>
<p>可以看到，所有的接口这里都列出来了，包括接口请求方式，接口地址以及接口的名字等，点开一个接口，可以看到如下信息：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-fea4a7c19ee949718f673850ab43ecae.png" alt="image.png"><br> 参数类型下的query表示参数以key/value的形式传递，点击右上角的Try it out，就可以进行接口测试：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-7911360db2704bdba9f3d980ee09ffc0.png" alt="image.png"><br><img src="https://www.itmengtao.cn/upload/2020/11/image-7022c914d0f94d9ca4b960398733077e.png" alt="image.png"><br> 点击Execute按钮，表示发送请求进行测试。测试结果会展示在下面的Response中。<br><img src="https://www.itmengtao.cn/upload/2020/11/image-90493558468f43ab99af40688933c234.png" alt="image.png"></p>
<h2 id="2-3-在Security中的配置"><a href="#2-3-在Security中的配置" class="headerlink" title="2.3.在Security中的配置"></a>2.3.在Security中的配置</h2><p>如果我们的Spring Boot项目中集成了Spring Security，那么如果不做额外配置，Swagger2文档可能会被拦截，此时只需要在Spring Security的配置类中重写configure方法，添加如下过滤即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>)</span><br><span class="line">            .antMatchers(<span class="string">&quot;/v2/**&quot;</span>)</span><br><span class="line">            .antMatchers(<span class="string">&quot;/swagger-resources/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此之后，Swagger2文件就不需要认证就能访问了。</p>
<p> 项目已上传至github，具体请下载示例代码测试：<a href="https://github.com/astronger/springboot-swagger2">https://github.com/astronger/springboot-swagger2</a></p>
]]></content>
      <categories>
        <category>Spring Boot | Swagger2</category>
      </categories>
      <tags>
        <tag>Spring Boot | Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>U盘安装Centos 7.x系统</title>
    <url>/2019/02/27/U%E7%9B%98%E5%AE%89%E8%A3%85Centos%207.x%E7%B3%BB%E7%BB%9F-U%E7%9B%98%E5%AE%89%E8%A3%85Centos%207x%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>笔记记录：</p>
<p>一.制作U盘启动盘<br>参考：<a href="http://jingyan.baidu.com/article/a378c960630e61b329283045.html">http://jingyan.baidu.com/article/a378c960630e61b329283045.html</a></p>
<p>1.安装UltraISO  </p>
<p>2.安装完成后点击  试用</p>
<p>3.点击文件，选择打开</p>
<p>4.找到Centos7包所在的文件夹，选择Centos7包，点击打开</p>
<p>5.插入准备好的U盘</p>
<p>6.点击顶部菜单中的 启动  选择 写入硬盘映像  ps：注意是硬盘不是软盘</p>
<p>7.硬盘驱动器选择你的U盘 ，写入方式 usb+hdd+</p>
<p>8.点击写入</p>
<p>二.安装Centos7</p>
<p>1.把U盘插到电脑上</p>
<p>2.设置开机U盘启动 ps：机器不一样设置也不一样具体请百度，我的是按F12可选择U盘。</p>
<p>3.选择U盘后跳转到下图界面</p>
<p>4.按下键盘TAB键将最下面的vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet 改为 vmlinuz initrd=initrd.img linux dd quiet</p>
<p>5.查看U盘启动盘的名称比如：sda，sdb，sdc  ps：label一列会显示Centos7等字样的</p>
<p>6.重启后到第三步界面按下TAB键</p>
<p>7.(第4步-第7步改路径，最终以第7步为准，我的u盘名默认为sdb4,以下例子为sdb1)<br>将vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet  改为  vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb1 quiet     ps：sdb1就是你看到的启动盘名称</p>
<p>8.之后等待安装到图形界面</p>
<p>9.选择中文→简体中文→点击继续</p>
<p>10.安装源：本地介质，软件选择：GNOME桌面（如果默认的看不到可视化桌面只是命令行），安装位置：选择你的硬盘，自动分配（内存最大的，自己也可分配我默认自动的），网络和主机名：打开（默认关闭的）</p>
<p>11.设置完成点击开始安装</p>
<p>12.之后会有设置root账号和常用账号的界面，点进去设置root密码然后创建常用账号。密码过于简单点击确定会有提示，如果就想用这个密码可以再次点击确定</p>
<p>13.等待安装完成会让重启，点击重启按钮</p>
<p>14.重启后会有一个安全协议的操作，有些可以界面选择有些是命令行，界面不多说，命令行的话 输入：1，回车，2，回车，c，回车，c，回车</p>
<p>15.安装完成。</p>
]]></content>
      <categories>
        <category>CentOS | Linux</category>
      </categories>
      <tags>
        <tag>CentOS  | Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>WebStorm 设置文件类型</title>
    <url>/2019/11/10/WebStorm%20%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-WebStorm%20%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>今天将生成的Vue脚手架项目导入到Webstorm中，发现vue组件文件全部不识别并且变灰，如下图：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-e04ac433b555404fb49e6fb2683b23b3.png" alt="image.png"></p>
<p>后来发现是文件类型不识别导致的，解决如下：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-c18bb2c160cd41239c4902a7fae6344b.png" alt="image.png"><br>点击OK即可，其它类型问题未识别也是同样的操作，具体看需要配置什么文件。 </p>
]]></content>
      <categories>
        <category>WebStorm</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title>Webstorm中 *.vue 文件报红</title>
    <url>/2019/11/09/Webstorm%E4%B8%AD%20_.vue%20%E6%96%87%E4%BB%B6%E6%8A%A5%E7%BA%A2-Webstorm%E4%B8%AD%20_.vue%20%E6%96%87%E4%BB%B6%E6%8A%A5%E7%BA%A2/</url>
    <content><![CDATA[<p>今天用WebStorm 2019.2 将本地的Vue项目打开后，发现vue组件中的script 标签全部报红了，虽然后不影响项目启动，但是作为强迫症的我还是想改好这些文件，经过查阅资料，解决方案如下：</p>
<p> 打开 File——&gt;Settings ——&gt; File Types 找到 HTML 添加 *.vue ，然后点击OK即可解决报红问题。<br><img src="https://www.itmengtao.cn/upload/2020/11/image-3cef8954a0864e4da54c4e4c480f3f1a.png" alt="image.png"></p>
<p>这样vue文件就相当于html文件，可以编辑css，js，也都有智能提示。如果.vue文件中es6语法还是报错的话用如下方法：</p>
<p>(1)直接在<script>标签中添加type="text/ecmascript-6"，.vue里面的代码会支持ES6。</p>
<p>(2)将script标签添加 type=”es6” 属性，<script type="es6"> </script></p>
<p>然后打开 File——&gt;Settings ——&gt; Language Injections 添加 XML Tag Injection，内容如下图:</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-7d7a5c928b8948c8a766e73bfb94e794.png" alt="image.png"></p>
<p>参考：<a href="https://www.cnblogs.com/momo798/p/6519477.html">https://www.cnblogs.com/momo798/p/6519477.html</a></p>
]]></content>
      <categories>
        <category>WebStorm</category>
      </categories>
  </entry>
  <entry>
    <title>Zuul  笔记补充</title>
    <url>/2020/08/13/Zuul%20%20%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85-zuul%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>@[TOC](Zuul 笔记补充)</p>
<h1 id="1-服务网关"><a href="#1-服务网关" class="headerlink" title="1. 服务网关"></a>1. 服务网关</h1><p>由于每个微服务的地址都有可能发生变化，无法直接对外公布这些服务地址，基于安全以及高内聚低耦合等设计，我们有必要将内部系统与外部系统做一个切割。<br>一个专门用来处理外部请求的组件就是服务网关。</p>
<ul>
<li>好处：</li>
<li>客户端调用更加简单</li>
<li>权限问题统一处理</li>
<li>数据分割和拼接</li>
<li>不同客户端可提供不同的网关支持</li>
</ul>
<p>Spring Cloud 中，常见的网关：</p>
<ul>
<li>Zuul</li>
<li>Spring Cloud Gateway</li>
</ul>
<h1 id="2-Zuul-简介"><a href="#2-Zuul-简介" class="headerlink" title="2. Zuul 简介"></a>2. Zuul 简介</h1><p> Zuul 的<strong>功能</strong>：</p>
<ul>
<li> 监控</li>
<li>权限控制(认证和授权)</li>
<li>动态路由</li>
<li>负载均衡</li>
<li>静态资源处理</li>
</ul>
<p>Zuul 中的功能基本上都是基于过滤器实现，它的过滤器有几种不同的类型：</p>
<ol>
<li>PRE (前置过滤器，比如要做声明校验)</li>
<li>ROUTING (过滤器将请求路由到微服务上面)</li>
<li>POST  (请求的微服务执行完之后，这个过滤器才执行)</li>
<li>ERROR  (过滤器执行出错时进入error)<blockquote>
<p>执行顺序: pre –&gt; routing –&gt; post(任何一个过滤器异常 都会进入error)</p>
</blockquote>
<h2 id="2-1-初识-Zuul"><a href="#2-1-初识-Zuul" class="headerlink" title="2.1 初识 Zuul"></a>2.1 初识 Zuul</h2>首选创建项目，添加依赖：<br><img src="https://img-blog.csdnimg.cn/20201118104315578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>创建成功后，将项目注册到Eureka上：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=zuul</span><br><span class="line">server.port=2020</span><br><span class="line">eureka.client.service-defaultZone=http://localhost:1111/eureka</span><br></pre></td></tr></table></figure>
<p>然后在启动类上开启路由代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 开启网关代理</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完成后，重启 Eureka 、Provider、Zuul ，接下来在浏览器中，通过 Zuul 的代理就可以访问到 provider 了。访问：<a href="http://localhost:2020/provider/hello">http://localhost:2020/provider/hello</a>  与直接访问 <a href="http://localhost:1113/hello">http://localhost:1113/hello</a><br>的结果是一样的。在这个访问中， provider 就是要访问的服务名称，/hello 则是要访问的服务接口。<br>以上是一个简单的例子，Zuul 中的路由规则也可以自己配置。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">zuul.routes.javaboy-a.path=/javaboy-a/**</span><br><span class="line">zuul.routes.javaboy-a.service-id=provider</span><br></pre></td></tr></table></figure>
<p>此时。重启服务后，直接访问 <a href="http://localhost:2020/javaboy-a/hello">http://localhost:2020/javaboy-a/hello</a> 即可。与上述访问结果一致。<br>对于上面的配置也可以进行简化：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.provider</span>=<span class="string">/javaboy-a/**</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-zuul过滤"><a href="#2-2-zuul过滤" class="headerlink" title="2.2 zuul过滤"></a>2.2 zuul过滤</h2><p>对于来自客户端的请求，可以在 Zuul 中进行预处理，例如权限判断等。<br>定义一个简单的权限过滤器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParmPermissFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤器类型 权限判断一般是pre</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤器优先级</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否过滤 修改一下(true --&gt; 是)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断逻辑</span></span><br><span class="line">    <span class="comment">// 在源码已经说过了 该返回值忽略它 无所谓返回了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = context.getRequest();</span><br><span class="line">        String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;烤肉&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 设置响应返回</span></span><br><span class="line">            <span class="comment">// 设置响应头(乱码)</span></span><br><span class="line">            context.addZuulResponseHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 响应码</span></span><br><span class="line">            context.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            context.setResponseBody(<span class="string">&quot;请求拦截&quot;</span>);</span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启 Zuul ，然后访问请求必须带上 name 参数，否则请求不通过。如下：<br><a href="http://127.0.0.1:2020/javaboy-a/hello?name=%E7%83%A4%E8%82%89">http://127.0.0.1:2020/javaboy-a/hello?name=烤肉</a></p>
<p>访问：<a href="http://127.0.0.1:2020/javaboy-a/hello">http://127.0.0.1:2020/javaboy-a/hello</a>  会被拦截。如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201118114815219.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-3-Zuul-中的其他配置"><a href="#2-3-Zuul-中的其他配置" class="headerlink" title="2.3 Zuul 中的其他配置"></a>2.3 Zuul 中的其他配置</h2><h4 id="2-3-1-匹配规则"><a href="#2-3-1-匹配规则" class="headerlink" title="2.3.1 匹配规则"></a>2.3.1 匹配规则</h4><p>例如有两个服务，一个叫 consumer ，另一个叫 consumer-hello ,在做路由规则设置时，假如出现了如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">zuul.routes.consumer=/consumer/**</span><br><span class="line">zuul.routes.consumer-hello=/consumer/hello/**</span><br></pre></td></tr></table></figure>
<p>此时如果访问 <a href="http://localhost:2020/consumer/hello/123">http://localhost:2020/consumer/hello/123</a> ，会出现冲突。这时，只需将配置文件改为 yml 格式就可以了（yml 是有优先级的，只要调换它们位置即可。properties文件是无序的）。</p>
<h4 id="2-3-2-忽略路径"><a href="#2-3-2-忽略路径" class="headerlink" title="2.3.2 忽略路径"></a>2.3.2 忽略路径</h4><p>默认情况下，zuul 注册到 eureka 上之后， eureka 上的所有注册服务都会被代理。如果不想给某一个服务做代理，可忽略该服务，配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示忽略 provider 服务，此时就不会自动代理</span></span><br><span class="line"><span class="meta">zuul.ignored-services</span>=<span class="string">provider</span></span><br></pre></td></tr></table></figure>
<p>也可以忽略某一类地址：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 表示请求路径中如果包含 hello ,则不做代理</span><br><span class="line">zuul.ignored-patterns=/**/hello/**</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-前缀"><a href="#2-3-3-前缀" class="headerlink" title="2.3.3 前缀"></a>2.3.3 前缀</h4><p>也可以给路由加前缀。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">zuul.prefix=/javaboy</span><br></pre></td></tr></table></figure>
<p>这样所有的请求地址自动多了前缀： /javaboy</p>
<p>项目地址：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>docker解决删除镜像时出错 image is referenced in multiple repositories</title>
    <url>/2019/12/30/docker%E8%A7%A3%E5%86%B3%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E6%97%B6%E5%87%BA%E9%94%99%20image%20is%20referenced%20in%20multiple%20repositories-docker%E8%A7%A3%E5%86%B3%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E6%97%B6%E5%87%BA%E9%94%99%20image%20is%20referenced%20in%20multiple%20repositories/</url>
    <content><![CDATA[<p>1、查看镜像 docker images ，删除镜像，会报错</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-3971633560774e7e9839a38faa1c735e.png" alt="image.png"></p>
<p> 2、仔细观察，发现9e64176cd8a2这个镜像id指向了两个repository，因此无法删除。所以我们可以用repository和tag的方式来删除</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-b68cf8ffb1944146a8cb767b71216dc9.png" alt="image.png"></p>
<p> 再次查看镜像，删除成功了。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git commit -m 与 git commit -am 的区别</title>
    <url>/2019/09/26/git%20commit%20-m%20%E4%B8%8E%20git%20commit%20-am%20%E7%9A%84%E5%8C%BA%E5%88%AB-git%20commit%20-m%20%E4%B8%8E%20git%20commit%20-am%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>第三步等于第一步第二步的结合，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 $ git add .</span><br><span class="line">2 $ git commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line"> </span><br><span class="line">3 $ git commit -am <span class="string">&quot;xxx&quot;</span> (第三步等于第一步和第二步)</span><br></pre></td></tr></table></figure>
<h2 id="区别：-如果是新增的文件就必须使用第一步和第二步的命令；-git-commit-am-‘xxx’命令只能提交已经跟踪过且修改了的文件。"><a href="#区别：-如果是新增的文件就必须使用第一步和第二步的命令；-git-commit-am-‘xxx’命令只能提交已经跟踪过且修改了的文件。" class="headerlink" title="区别：    如果是新增的文件就必须使用第一步和第二步的命令； git commit -am ‘xxx’命令只能提交已经跟踪过且修改了的文件。"></a>区别：    如果是新增的文件就必须使用第一步和第二步的命令； git commit -am ‘xxx’命令只能提交已经跟踪过且修改了的文件。</h2>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git stash工作区储藏</title>
    <url>/2019/09/29/git%20stash%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%82%A8%E8%97%8F-git%20stash%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%82%A8%E8%97%8F/</url>
    <content><![CDATA[<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>现在有两个分支master 和 ha 分支，假设一开始 master 和 ha 分支中的文件内容都是一致的，而且两个分支的工作区都没有东西需要 add/commit ，此时，我在 master 中修改了文件，修改完成之后，执行 git status 命令我们看到 master 中有东西需要 add/commit ，此时我想切换到 ha 分支中去，但是并不想对 master 分支执行 add/commit ，这个时候我们可以执行如下命令，先将当前分支中的文件储藏起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure>
<p>执行完 git stash 命令之后，再执行 git status ，我们发现此时 master 分支已经是干净的了，此时我们可以切换到 ha 分中，切换到 ha 分支之后，我们发现 master 中的修改并没有干扰到 ha 分支，当我们完成了 ha 分支中的工作之后，再回到 master 分支，此时执行如下命令可以恢复刚刚储藏的数据（<strong>表示恢复最近一次储藏</strong>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure>
<p>上面这个命令执行完之后，master 分支中的工作区中的文件就恢复了，此时执行 git status 就可以看到又有数据需要 add/commit 了。上面的过程如<strong>下图</strong>所示：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-fda336d69054424d8ac95640b6e74681.png" alt="image.png"></p>
<p>我们也可将工作区<strong>储藏多次</strong>，这个时候我们可以执行如下命令来查看储藏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>
<p>执行效果如下： </p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-f1118bee9e5d45b9be0c526a9f38f558.png" alt="image.png"></p>
<p>git stash apply 表示恢复最近一次储藏，如果我们想恢复到之前的某一次储藏，可以加上储藏的名字，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h2 id="还有一些其他的关于储藏的命令："><a href="#还有一些其他的关于储藏的命令：" class="headerlink" title="还有一些其他的关于储藏的命令："></a>还有一些其他的关于储藏的命令：</h2><h3 id="1-恢复储藏并出栈"><a href="#1-恢复储藏并出栈" class="headerlink" title="1. 恢复储藏并出栈"></a>1. 恢复储藏并出栈</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
<p>执行效果和 git stash apply 一样，不同的是，这里执行完之后，会将栈顶的储藏移除。</p>
<h3 id="2-删除某一个储藏"><a href="#2-删除某一个储藏" class="headerlink" title="2.删除某一个储藏"></a>2.删除某一个储藏</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash drop stash@&#123;4&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个参数是指储藏的名字。</p>
<p>其它文章：</p>
<p><a href="https://blog.csdn.net/ourstronger/article/details/101028450">Git 基本操作</a><br><a href="https://blog.csdn.net/ourstronger/article/details/101033323">Git 分支管理</a><br><a href="https://blog.csdn.net/ourstronger/article/details/101059246">Git 关联远程仓库GitHub</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>image is referenced in multiple repositories 解决docker删除镜像时出错</title>
    <url>/2019/08/30/image%20is%20referenced%20in%20multiple%20repositories%20%E8%A7%A3%E5%86%B3docker%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E6%97%B6%E5%87%BA%E9%94%99-image%20is%20referenced%20in%20multiple%20repositories%20%E8%A7%A3%E5%86%B3docker%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E6%97%B6%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p> 1、查看镜像 docker images ，删除镜像，会报错，如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-8ad2426616b14e9687710e646e4c4212.png" alt="image.png"></p>
<p> 2、仔细观察，发现9e64176cd8a2这个镜像id指向了两个repository，因此无法删除。所以我们可以用repository和tag的方式来删除</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-8759115a5d4e4673a6e77962d21f2576.png" alt="image.png"></p>
<p> 再次查看镜像，删除成功了。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>java 利用 spire.pdf 将图片添加到 pdf</title>
    <url>/2020/01/05/java%20%E5%88%A9%E7%94%A8%20spire.pdf%20%E5%B0%86%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E5%88%B0%20pdf-java%20%E5%88%A9%E7%94%A8%20spire.pdf%20%E5%B0%86%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E5%88%B0%20pdf%E4%B8%AD/</url>
    <content><![CDATA[<p>工具：<a href="https://www.e-iceblue.cn/Downloads/Free-Spire-PDF-JAVA.html">Free Spire.PDF for Java V2.0.0</a>（免费版）</p>
<p>首先，在 pom.xml 文件中配置 Maven 仓库路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;com.e-iceblue&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;e-iceblue&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http://repo.e-iceblue.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>
<p>引入免费版本（免费版有页数限制，不能超出 10 页）： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spire.pdf.free&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.spire.pdf.FileFormat;</span><br><span class="line">import com.spire.pdf.PdfDocument;</span><br><span class="line">import com.spire.pdf.PdfPageBase;</span><br><span class="line">import com.spire.pdf.annotations.PdfRubberStampAnnotation;</span><br><span class="line">import com.spire.pdf.annotations.appearance.PdfAppearance;</span><br><span class="line">import com.spire.pdf.graphics.PdfImage;</span><br><span class="line">import com.spire.pdf.graphics.PdfTemplate;</span><br><span class="line"> </span><br><span class="line">import java.awt.geom.Rectangle2D;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class ImageStamp &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建PdfDocument对象，加载PDF测试文档</span><br><span class="line">        PdfDocument doc = new PdfDocument();</span><br><span class="line">        doc.loadFromFile(&quot;D:\\test.pdf&quot;);</span><br><span class="line">        //获取PDF文件的页数</span><br><span class="line">        int pageCount = doc.getPages().getCount();</span><br><span class="line">        //循环给PDF添加印章</span><br><span class="line">        for (int i=0; i&lt;pageCount;i++) &#123;</span><br><span class="line">            //获取文档第几页</span><br><span class="line">            PdfPageBase page = doc.getPages().get(i);</span><br><span class="line">            //加载印章图片</span><br><span class="line">            PdfImage image = PdfImage.fromFile(&quot;D:\\test.png&quot;);</span><br><span class="line">            //获取印章图片的宽度和高度</span><br><span class="line">            int width = 120;</span><br><span class="line">            int height = 120;</span><br><span class="line">            //创建PdfTemplate对象</span><br><span class="line">            PdfTemplate template = new PdfTemplate(width, height);</span><br><span class="line">            //将图片绘制到模板</span><br><span class="line">            template.getGraphics().drawImage(image, 0, 0, width, height);</span><br><span class="line">            //创建PdfRubebrStampAnnotation对象，指定大小和位置</span><br><span class="line">            Rectangle2D rect = new Rectangle2D.Float((float) (page.getActualSize().getWidth() - width - 50), (float) (page.getActualSize().getHeight() - height - 100), width, height);</span><br><span class="line">            PdfRubberStampAnnotation stamp = new PdfRubberStampAnnotation(rect);</span><br><span class="line">            //创建PdfAppearance对象</span><br><span class="line">            PdfAppearance pdfAppearance = new PdfAppearance(stamp);</span><br><span class="line">            //将模板应用为PdfAppearance的一般状态</span><br><span class="line">            pdfAppearance.setNormal(template);</span><br><span class="line">            //将PdfAppearance 应用为图章的样式</span><br><span class="line">            stamp.setAppearance(pdfAppearance);</span><br><span class="line">            //添加图章到PDF</span><br><span class="line">            page.getAnnotationsWidget().add(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">        //保存文档</span><br><span class="line">        doc.saveToFile(&quot;D:\\test.pdf&quot;,FileFormat.PDF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它 pdf 相关文章： </p>
<ol>
<li><a href="https://blog.csdn.net/ourstronger/article/details/103527074">去除 Spire.pdf 生成时出现警告语 Evaluation Warning</a></li>
<li><a href="https://blog.csdn.net/ourstronger/article/details/103526898">Spire.PDF 中的坐标体系详解及应用</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>json对比</title>
    <url>/2019/03/14/json%E5%AF%B9%E6%AF%94-json%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>笔记：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 对比json</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">jsonContrastJson</span><span class="params">(String json1, String json2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Map&lt;String, Integer&gt; map1 = jsonStringMap(json1);</span><br><span class="line">	Map&lt;String, Integer&gt; map2 = jsonStringMap(json2);</span><br><span class="line">	Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entries2 = map2.entrySet().iterator();</span><br><span class="line">	<span class="keyword">if</span> (map1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (entries2.hasNext()) &#123;</span><br><span class="line">			Map.Entry&lt;String, Integer&gt; entry = entries2.next();</span><br><span class="line">			<span class="keyword">if</span> (map1.containsKey(entry.getKey())) &#123;</span><br><span class="line">				<span class="keyword">int</span> n = map1.get(entry.getKey());</span><br><span class="line">				map1.put(entry.getKey(), n + entry.getValue());</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map1.put(entry.getKey(), entry.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> json2;</span><br><span class="line">	&#125;</span><br><span class="line">	Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">	String json = gson.toJson(map1);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + json + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">jsonStringMap</span><span class="params">(String rsContent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	JSONArray arry = JSONArray.fromObject(rsContent);</span><br><span class="line">	Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arry.size(); i++) &#123;</span><br><span class="line">		JSONObject jsonObject = arry.getJSONObject(i);</span><br><span class="line">		<span class="keyword">for</span> (Iterator&lt;?&gt; iter = jsonObject.keys(); iter.hasNext();) &#123;</span><br><span class="line">			String key = (String) iter.next();</span><br><span class="line">			<span class="keyword">int</span> value = Integer.parseInt(jsonObject.get(key).toString());</span><br><span class="line">			System.out.println(key + <span class="string">&quot;*********&quot;</span> + value);</span><br><span class="line">			map.put(key, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>mysql服务设置远程连接 解决1251 client does not support 的问题</title>
    <url>/2019/03/09/mysql%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%20%E8%A7%A3%E5%86%B31251%20client%20does%20not%20support%20%E7%9A%84%E9%97%AE%E9%A2%98-mysql%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%20%E8%A7%A3%E5%86%B31251%20client%20does%20not%20support%20..%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一、前期准备<br>1、虚拟机/物理机    mysql环境（非本机）<br>2、本机 navicat软件（验证远程连接）<br>二 、mysql配置<br>1、在远程主机的本机   使用root用户连接mysql</p>
<p>mysql -u root -p<br>备注 ： mysql -u 最高权限用户名 -p   再输入密码进入<br><img src="https://www.itmengtao.cn/upload/2020/8/%E5%9B%BE%E7%89%87-7618a564be724b97992bd0248e8a5477.png" alt="图片.png"></p>
<p>2、设置用户配置项</p>
<p>(1) 查看用户信息</p>
<p>select host,user,plugin,authentication_string from mysql.user;<br><img src="https://www.itmengtao.cn/upload/2020/8/%E5%9B%BE%E7%89%87-98a256112fb349b3985b1f6430f359c6.png" alt="图片.png"></p>
<p>备注：host为 % 表示不限制ip   localhost表示本机使用    plugin非mysql_native_password 则需要修改密码</p>
<p>(2)修改用户密码</p>
<p>ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘newpassword’; #更新一下用户的密码 root用户密码为newpassword</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/%E5%9B%BE%E7%89%87-48ccc5c565204e3b852f0377ef8fd633.png" alt="图片.png"></p>
<p>三、使用navicat连接远程mysql<br>未配置情况为,连接拒绝<br><img src="https://www.itmengtao.cn/upload/2020/8/%E5%9B%BE%E7%89%87-effbc70238f5407e88f45c5ccba04f34.png" alt="图片.png"></p>
<p>配置成功后</p>
<p><img src="https://www.itmengtao.cn/upload/2020/8/%E5%9B%BE%E7%89%87-7235270ce0c74917894087cf54a037a9.png" alt="图片.png"></p>
]]></content>
      <categories>
        <category>CentOS | MySQL | Linux</category>
      </categories>
      <tags>
        <tag>CentOS  | MySQL | Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要写博客？</title>
    <url>/2019/02/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>在这之前，有什么问题都是直接Google、百度，过后也就不了了之，直到最近看到许多大神写的文章，大家都用文字去记录工作以及生活中的点点滴滴，现在觉得是一件非常值得做的事情，不仅是对自己的总结，而且也是一个很好的技术积累与沉淀的过程。</p>
<p>为什么要写博客？写博客有的东西可能一时半会在工作中用不到，大家就没有动力去做，可能想着等以后用到了再说(当然我也是这么想的)，但实际上很多公司里的开发都是业务驱动的， 如果要等到用上这个技术再去学的话，估计是要凉凉。所以我决定隔三差五的也写点东西吧，不要担心自己的水平菜，每个人都是从菜鸟过来的！把自己的东西分享出来，不论好坏，首先是对自己的总结或记录，能帮助到别人更好。希望对大家有所启发， 剩下的就是最难的：坚持！</p>
]]></content>
      <categories>
        <category>工作生活</category>
      </categories>
      <tags>
        <tag>工作生活</tag>
      </tags>
  </entry>
  <entry>
    <title>去除 Spire.pdf 生成时出现警告语 Evaluation Warning</title>
    <url>/2020/01/05/%E5%8E%BB%E9%99%A4%20Spire.pdf%20%E7%94%9F%E6%88%90%E6%97%B6%E5%87%BA%E7%8E%B0%E8%AD%A6%E5%91%8A%E8%AF%AD%20Evaluation%20Warning-%E5%8E%BB%E9%99%A4%20Spire.pdf%20%E7%94%9F%E6%88%90%E6%97%B6%E5%87%BA%E7%8E%B0%E8%AD%A6%E5%91%8A%E8%AF%AD%20Evaluation%20Warning/</url>
    <content><![CDATA[<p>用 Spire.PDF 生成报告时出现警告语:<br><img src="https://www.itmengtao.cn/upload/2020/12/image-9e4102bcac25444fa3ca14551be26168.png" alt="image.png"></p>
<h3 id="1-删除第一个页（最好的方法）"><a href="#1-删除第一个页（最好的方法）" class="headerlink" title="1. 删除第一个页（最好的方法）"></a>1. 删除第一个页（最好的方法）</h3><p>因为警告语只会在文档的第一页生成，所有删除文档第一页即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PdfDocument pdfDocument = new PdfDocument();</span><br><span class="line">pdfDocument.Pages.Add();</span><br><span class="line">pdfDocument.Pages.RemoveAt(0);</span><br></pre></td></tr></table></figure>
<h3 id="2-使用免费版的。"><a href="#2-使用免费版的。" class="headerlink" title="2. 使用免费版的。"></a>2. 使用免费版的。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spire.pdf.free&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>但是免费版的有限制功能，比如最多只能创建 10 页，在现实开发中，报告的页数是不固定的，有时会大于 10 页，比如报告总共有 15 页，那么使用免费版的，虽然没有警告语，但是限制 10 页，后面的 5 页就没了，所以还是不推荐这个方法。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>在Adobe Acrobat DC中设置PDF单页连续</title>
    <url>/2019/11/25/%E5%9C%A8Adobe%20Acrobat%20DC%E4%B8%AD%E8%AE%BE%E7%BD%AEPDF%E5%8D%95%E9%A1%B5%E8%BF%9E%E7%BB%AD-%E5%9C%A8Adobe%20Acrobat%20DC%E4%B8%AD%E8%AE%BE%E7%BD%AEPDF%E5%8D%95%E9%A1%B5%E8%BF%9E%E7%BB%AD/</url>
    <content><![CDATA[<p>点击 编辑——&gt;首选项——&gt;辅助工具——&gt;选择总是使用页面布局样式——&gt;单页连续，如下图所示。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-a629418bf0444dcca0ad5e63765d9fea.png" alt="image.png"></p>
<p>然后点击 文档——&gt;打开设置，去掉“重新打开文档时恢复上次视图设置”选项。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-c24009317a1c434dae6654864bf3625e.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>工作生活</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用Halo搭建自己的博客网站</title>
    <url>/2019/02/20/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Halo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-hellohalo/</url>
    <content><![CDATA[<p>工作需要学习，学习需要积累。网上有很多好的博客系统。我们可以去”CSDN”，”博客园”等这种大厂提供的博客空间，也可以自己搭建高逼格的独立博客。例如，适合github的hexo，大众的wordpress，OneBlog，Tale等。对比了一波，我选择halo这款博客系统。对于我它有以下几个优点：<br>（1）java语言实现，适合java程序员。<br>（2）动态的主题切换（特别炫支持移动端，响应式页面）<br>（3）完善的后台管理功能操作方便。<br>（4）部署超级简单，五分钟完成搭建。<br>（5）站点迁移方便，复制文件一键迁移。</p>
<p>下面讲讲如何搭建Halo，在这之前，购买自己的云服务器，备案自己的域名。这是搭建自己站点，拉取流量的基础；我这里是阿里云，域名备案也直接在阿里云备案：</p>
<h1 id="使用-Docker-部署-Halo"><a href="#使用-Docker-部署-Halo" class="headerlink" title="使用 Docker 部署 Halo"></a><strong>使用 Docker 部署 Halo</strong></h1><p>使用 Docker 部署 Halo 的指南，假设你已经<a href="%E5%AE%89%E8%A3%85Docker">安装Docker</a> 并了解它的基本使用。本篇教程以 CentOS 7.x 为例，其他系统大同小异。</p>
<h2 id="1-环境要求"><a href="#1-环境要求" class="headerlink" title="1. 环境要求"></a>1. <strong>环境要求</strong></h2><p>为了在使用过程中不出现意外的事故，给出下列推荐的配置<br>CentOS 7.x<br>1G 以上内存</p>
<h2 id="2-服务器配置，配置-Docker-运行环境"><a href="#2-服务器配置，配置-Docker-运行环境" class="headerlink" title="2. 服务器配置，配置 Docker 运行环境"></a>2. <strong>服务器配置，配置 Docker 运行环境</strong></h2><ul>
<li>请确保服务器的软件包已经是最新的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum update -y</span><br></pre></td></tr></table></figure></li>
<li>启动 Docker 后台服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h2 id="3-安装-Halo"><a href="#3-安装-Halo" class="headerlink" title="3. 安装 Halo"></a>3. 安装 Halo</h2><h3 id="1-自定义配置文件"><a href="#1-自定义配置文件" class="headerlink" title="1. 自定义配置文件"></a>1. 自定义配置文件</h3><p>考虑到部分用户的需要，可能需要自定义比如端口等设置项，我们提供了公共的配置文件，并且该配置文件是完全独立于安装包的。当然，你也可以使用安装包内的默认配置文件，但是安装包内的配置文件是不可修改的。请注意：配置文件的路径为 ~/.halo/application.yaml。</p>
<figure class="highlight plaintext"><figcaption><span>下载配置文件到 ~/.halo 目录</span></figcaption><table><tr><td class="code"><pre><span class="line">curl -o ~/.halo/application.yaml --create-dirs http://halo.ryanc.cc/config/application-template.yaml</span><br></pre></td></tr></table></figure>
<h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>完成上一步操作，我们就可以自己配置 Halo 的运行端口，以及数据库相关的配置了。</p>
<figure class="highlight plaintext"><figcaption><span>使用 Vim 工具修改配置文件</span></figcaption><table><tr><td class="code"><pre><span class="line">vim ~/.halo/application.yaml</span><br></pre></td></tr></table></figure>
<p>打开之后我们可以看到：</p>
<p><strong>H2 配置如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  port: 8090</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line"></span><br><span class="line">    # H2 Database 配置</span><br><span class="line">    driver-class-name: org.h2.Driver</span><br><span class="line">    url: jdbc:h2:file:~/.halo/db/halo</span><br><span class="line">    username: admin</span><br><span class="line">    password: openadmin</span><br><span class="line">  h2:</span><br><span class="line">    console:</span><br><span class="line">      settings:</span><br><span class="line">        web-allow-others: false</span><br><span class="line">      path: /h2-console</span><br><span class="line">      enabled: false</span><br></pre></td></tr></table></figure>
<p>MySQL 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  port: 8090</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    # MySQL 配置</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/halodb?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: openroot</span><br></pre></td></tr></table></figure>
<ol>
<li>如果需要自定义端口，修改 server 节点下的 port 即可。</li>
<li>默认使用的是 H2 Database 数据库，这是一种嵌入式的数据库，使用起来非常方便。需要注意的是，默认的用户名和密码为 admin 和 123456，这个是自定义的，最好将其修改，并妥善保存。</li>
<li>如果需要使用 MySQL 数据库，需要将 H2 Database 的所有相关配置都注释掉，并取消 MySQL 的相关配置。另外，MySQL 的默认数据库名为 halodb，请<strong>自行配置 MySQL</strong> 并创建数据库，以及修改配置文件中的用户名和密码。</li>
<li>h2 节点为 H2 Database 的控制台配置，默认是关闭的，如需使用请将 h2.console.settings.web-allow-others 和 h2.console.enabled 设置为 true。控制台地址即为 域名/h2-console。注意：非紧急情况，不建议开启该配置。</li>
</ol>
<h3 id="3-拉取最新-Halo-镜像"><a href="#3-拉取最新-Halo-镜像" class="headerlink" title="3. 拉取最新 Halo 镜像"></a>3. 拉取最新 Halo 镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker pull ruibaby/halo</span><br></pre></td></tr></table></figure>
<h3 id="4-创建容器并运行"><a href="#4-创建容器并运行" class="headerlink" title="4. 创建容器并运行"></a>4. 创建容器并运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name halo -d -p 8090:8090  -v ~/.halo:/root/.halo ruibaby/halo</span><br></pre></td></tr></table></figure>
<p>完成以上操作即可通过 ip:端口 访问了。端口默认是8090可以在配置文件或者启动时添加参数修改。虽然可以访问，但是端口暴露很不安全，后续<strong>第5步</strong>是如何配置域名访问。</p>
<h4 id="4-1-打开博客进行博客的初始化操作。初始化完成进入admin管理页面。"><a href="#4-1-打开博客进行博客的初始化操作。初始化完成进入admin管理页面。" class="headerlink" title="4.1 打开博客进行博客的初始化操作。初始化完成进入admin管理页面。"></a>4.1 打开博客进行博客的初始化操作。初始化完成进入admin管理页面。</h4><p><img src="https://www.itmengtao.cn/upload/2019/12/image-656356d91e394763b8b14869ea4b4938.png" alt="image.png"><br>点击右上角头像位置最左边的按钮，跳转到博客首页。设置主题!</p>
<h4 id="4-2-创建数据库，不需要创建表结构，初始化应用的时候自动生成。"><a href="#4-2-创建数据库，不需要创建表结构，初始化应用的时候自动生成。" class="headerlink" title="4.2 创建数据库，不需要创建表结构，初始化应用的时候自动生成。"></a>4.2 创建数据库，不需要创建表结构，初始化应用的时候自动生成。</h4><p>重启服务，打开地址，我们再一次初始化博客。打开数据库，可以看到表和数据已经初始化好了：<br><img src="https://www.itmengtao.cn/upload/2019/12/image-6cd8dbe349264b068ecc9b7215788bcb.png" alt="image.png"></p>
<p>服务搭建完成，解释一下后台配置，特别是主题配置</p>
<h4 id="4-3-菜单分为仪表盘，文章，页面，附件，评论，外观，用户，系统这几个，重点解释一下外观。外观菜单可以设置博客的主题显示效果。打开菜单如下："><a href="#4-3-菜单分为仪表盘，文章，页面，附件，评论，外观，用户，系统这几个，重点解释一下外观。外观菜单可以设置博客的主题显示效果。打开菜单如下：" class="headerlink" title="4.3 菜单分为仪表盘，文章，页面，附件，评论，外观，用户，系统这几个，重点解释一下外观。外观菜单可以设置博客的主题显示效果。打开菜单如下："></a>4.3 菜单分为仪表盘，文章，页面，附件，评论，外观，用户，系统这几个，重点解释一下外观。外观菜单可以设置博客的主题显示效果。打开菜单如下：</h4><p><img src="http://47.98.208.34:8090/upload/2019/12/t_1_5-e9833b0569a8441b90a1b868fa21758f-8ea23be7e9834bbdb75cbb972af8b990.png" alt="t_1_5e9833b0569a8441b90a1b868fa21758f.png"></p>
<h4 id="4-4-如何修改主题打开编辑主题页面："><a href="#4-4-如何修改主题打开编辑主题页面：" class="headerlink" title="4.4 如何修改主题打开编辑主题页面："></a>4.4 如何修改主题打开编辑主题页面：</h4><p><img src="http://47.98.208.34:8090/upload/2019/12/t_1_6-85b6b5a581c94f738627536dd7f7b8b0-0dfd57e773fc4c02a6fe5d3cf589a7a0.png" alt="t_1_685b6b5a581c94f738627536dd7f7b8b0.png"><br>可以根据自己的喜好设置自己的页面效果，可以自定义友情链接，社交网点等。</p>
<h3 id="5-配置域名访问"><a href="#5-配置域名访问" class="headerlink" title="5.配置域名访问"></a>5.配置域名访问</h3><p>使用 Caddy 进行反向代理。Caddy 是一款使用 Go 语言开发的 Web 服务器。其配置更为简洁，并可以自动申请及配置 SSL 证书（这里推荐使用）。</p>
<p>5.1 安装 Caddy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 Caddy 软件包</span><br><span class="line">yum install caddy -y</span><br></pre></td></tr></table></figure>
<p>5.2 配置 Caddy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载 Halo 官方的 Caddy 配置模板</span><br><span class="line">curl -o /etc/caddy/conf.d/Caddyfile.conf --create-dirs http://halo.ryanc.cc/config/Caddyfile</span><br></pre></td></tr></table></figure>

<p>5.3 下载完成之后，我们还需要对其进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 vim 编辑 Caddyfile</span><br><span class="line">vim /etc/caddy/conf.d/Caddyfile.conf</span><br></pre></td></tr></table></figure>

<p>5.4 打开之后我们可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.simple.com &#123;</span><br><span class="line"> gzip</span><br><span class="line"> tls xxxx@xxx.xx</span><br><span class="line"> proxy / localhost:port &#123;</span><br><span class="line">  transparent</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)请把 <a href="https://www.simple.com/">https://www.simple.com</a> 改为自己的域名。<br>(2)tls 后面的 <a href="mailto:&#x78;&#x78;&#x78;&#120;&#x40;&#x78;&#x78;&#120;&#46;&#x78;&#x78;">&#x78;&#x78;&#x78;&#120;&#x40;&#x78;&#x78;&#120;&#46;&#x78;&#x78;</a> 改为自己的邮箱地址，这是用于自动申请 SSL 证书用的。需要注意的是，不需要你自己配置 SSL 证书，而且会自动帮你续签。<br>(3)localhost:port 请将 port 修改为 Halo 的运行端口，默认为 8090。</p>
<p>5.5 修改完成之后启动 Caddy 服务即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启自启 Caddy 服务</span><br><span class="line">systemctl enable caddy</span><br><span class="line"></span><br><span class="line"># 启动 Caddy</span><br><span class="line">service caddy start</span><br><span class="line"></span><br><span class="line"># 停止运行 Caddy</span><br><span class="line">service caddy stop</span><br><span class="line"></span><br><span class="line"># 重启 Caddy</span><br><span class="line">service caddy restart</span><br><span class="line"></span><br><span class="line"># 查看 Caddy 运行状态</span><br><span class="line">service caddy status</span><br></pre></td></tr></table></figure>
<p>++注意:<br>如果 Caddy 启动出现诸如 [/usr/lib/systemd/system/caddy.service:23] Unknown lvalue ‘AmbientCapabilities’ in section ‘Service’ 这样的问题，请使用 yum update -y 更新系统。然后再使用 service caddy restart 重启，已知 CentOS 7.3 会出现该问题。++</p>
<h3 id="6-进阶设置"><a href="#6-进阶设置" class="headerlink" title="6.进阶设置"></a>6.进阶设置</h3><p>多网址重定向到主网址，比如访问 simple.com 跳转到 <a href="http://www.simple.com/">www.simple.com</a> 应该怎么做呢？</p>
<p>使用 vim 编辑 Caddyfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/caddy/conf.d/Caddyfile.conf</span><br></pre></td></tr></table></figure>
<p>打开之后我们在原有的基础上添加以下配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://simple.com &#123;</span><br><span class="line">  redir https://www.simple.com&#123;url&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <a href="https://simple.com/">https://simple.com</a> 和 <a href="https://www.simple.com{url}/">https://www.simple.com{url}</a> 修改为自己需要的网址就行了，比如我要求访问 ryanc.cc 跳转到 <a href="http://www.ryanc.cc，完整的配置如下：">www.ryanc.cc，完整的配置如下：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ryanc.cc &#123;</span><br><span class="line">  redir https://www.ryanc.cc&#123;url&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https://www.ryanc.cc &#123;</span><br><span class="line">  gzip</span><br><span class="line">  tls i@ryanc.cc</span><br><span class="line">  proxy / localhost:8090 &#123;</span><br><span class="line">    transparent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们(service caddy restart)重启 Caddy 即可。</p>
<p>到这里，关于 Caddy 反向代理的配置也就完成了，现在你可以访问一下自己的域名，并进行 Halo 的初始化了。</p>
<p>++注意:<br>在设置了反向代理之后，请一定记得去 halo 的管理端设置一下正确的博客地址，否则会造成资源获取不成功。++</p>
<p>参考:<br><a href="https://ailijie.top/archives/hello-halo">https://ailijie.top/archives/hello-halo</a></p>
<p><a href="https://halo.run/guide/install/reverse-proxy.html#%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8-caddy-%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">https://halo.run/guide/install/reverse-proxy.html#%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8-caddy-%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86</a></p>
]]></content>
      <categories>
        <category>工作生活</category>
      </categories>
      <tags>
        <tag>halo个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>带实体的 Collection 转换为 List 集合</title>
    <url>/2020/05/28/%E5%B8%A6%E5%AE%9E%E4%BD%93%E7%9A%84%20Collection%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%20List%20%E9%9B%86%E5%90%88-%E5%B8%A6%E5%AE%9E%E4%BD%93%E7%9A%84%20Collection%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%20List%20%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>笔记： 带实体的 Collection 与 List 集合转换～</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	    </span><br><span class="line">//求并集--a和b是自己创建的实体List集合 T实体类</span><br><span class="line">Collection&lt;T&gt; union= CollectionUtils.union(a,b);</span><br><span class="line">        </span><br><span class="line">//Collection转化成List</span><br><span class="line"> Iterator&lt;T&gt; iterator = union.iterator();</span><br><span class="line">          Collection&lt;T&gt; entityList =new ArrayList&lt;&gt;();</span><br><span class="line">            while (iterator .hasNext())&#123;</span><br><span class="line">                T needEntity= iterator.next();</span><br><span class="line">                entityList.add(needEntity);</span><br><span class="line">            &#125;</span><br><span class="line">  System.out.println(entityList);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>服务监控</title>
    <url>/2020/08/12/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7-%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>微服务由于服务数量众多，所以出故障的概率很大，这种时候不能单纯地依靠人肉运维。早期的 Spring Cloud 中，服务监控主要使用 Hystrix Dashboad ，集群数据库监控使用 Turbine。在 Greenwich 版本中，官方的建议监控工具使用 <strong>Micrometer</strong>。<br><strong>Micrometer</strong>：</p>
<ol>
<li>提供了度量指标，例如 timers、counters</li>
<li>一揽子开箱即用的解决方案，如缓存、类加载器、垃圾收集等等。</li>
</ol>
<p>新建一个 Spring Boot 项目， 添加 Actuator 依赖。<br><img src="https://img-blog.csdnimg.cn/20201116101455998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>项目创建成功后，添加如下配置，开启所有端点。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>
<p>启动项目，如下图查看：<br><img src="https://img-blog.csdnimg.cn/20201116101907388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>点击用浏览器打开，如下图，一堆json.<br><img src="https://img-blog.csdnimg.cn/20201116102227115.png#pic_center" alt="在这里插入图片描述"><br>我们需要一个可视化的工具，来展示这些json ，这里来看一下 Prometheus。</p>
<p>首先 <strong><a href="https://blog.csdn.net/ourstronger/article/details/109715671">安装 Prometheus 点这里</a></strong></p>
<p>安装完成后，接下来，将Prometheus整合到 Spring Boot 项目中。添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 application.properties 中添加 Prometheus 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoint.prometheus.enabled=true</span><br><span class="line">management.metrics.export.prometheus.enabled=true</span><br><span class="line">management.endpoint.metrics.enabled=true</span><br></pre></td></tr></table></figure>
<p>然后启动 Prometheus 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./prometheus --config.file=prometheus.yml</span><br></pre></td></tr></table></figure>
<p>启动成功后，浏览器输入 <a href="http://192.168.1.132:9090/graph">http://192.168.1.132:9090/graph</a>，查看 Prometheus 数据信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20201116114410815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 CentOS 没有字体导致 pdf 转图片乱码问题</title>
    <url>/2020/06/18/%E8%A7%A3%E5%86%B3%20CentOS%20%E6%B2%A1%E6%9C%89%E5%AD%97%E4%BD%93%E5%AF%BC%E8%87%B4%20pdf%20%E8%BD%AC%E5%9B%BE%E7%89%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%20Centos%20%E6%B2%A1%E6%9C%89%E5%AD%97%E4%BD%93%E5%AF%BC%E8%87%B4%20pdf%20%E8%BD%AC%E5%9B%BE%E7%89%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近做了一个报价功能，其中有 pdf 转图片，用到的是 pdfbox，在 windows 系统测试是正常的，但放到 centos 7 下就出现了乱码现象，如下图：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-4987621fd6e444f08f0d06c164c99c8a.png" alt="image.png"></p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>在 Centos 下安装字体：</p>
<ol>
<li>查看 /usr/share 目录下是否有 fonts 和 fontconfig 目录<br>如果没有，执行下面指令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum -y install fontconfig </span><br></pre></td></tr></table></figure>

<p>执行完后重新进入该目录就可以看到 fonts 和 fontconfig 目录了。</p>
<ol start="2">
<li>进入字体目录，创建文件夹（自定义命名）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /usr/share/fonts/   //进入fonts 目录</span><br><span class="line"> </span><br><span class="line"># mkdir hrtfont   //创建新文件夹 </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改 hrtfont 目录的权限使 root 用户以外的用户也可以使用  </li>
</ol>
<p> <img src="https://www.itmengtao.cn/upload/2020/12/image-5e9d7ca5377f4952ae5df73926f289e0.png" alt="image.png"></p>
<ol start="4">
<li>使用 xftp 复制 window 系统 C:\Windows\Fonts 下的 华文宋体.TTF (华文宋体就是 STSong) 字体到 hrtfont 目录下</li>
</ol>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-11862ee502e04f08b0026db1ef83c257.png" alt="image.png"> </p>
<ol start="5">
<li>建立字体缓存</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mkfontscale	// 如果提示 mkfontscale: command not found，需自行安装 #yum install mkfontscale</span><br><span class="line">#mkfontdir</span><br><span class="line">#fc-cache –fv	// 刷新内存中的字体缓存</span><br><span class="line">#source /etc/profile	// 执行以下命令让字体生效</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>查看是否安装成功</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#fc-list</span><br></pre></td></tr></table></figure>

<p>出现 STSsong 说明安装成功：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-688c0333bd9a42b7aee7474abdc1a434.png" alt="image.png"> </p>
<p><strong>最后，reboot 命令重启 centos 系统即可！</strong></p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Consul 启动后 Service Check 报红叉的错误</title>
    <url>/2020/06/05/%E8%A7%A3%E5%86%B3%20Consul%20%E5%90%AF%E5%8A%A8%E5%90%8E%20Service%20Check%20%E6%8A%A5%E7%BA%A2%E5%8F%89%E7%9A%84%E9%94%99%E8%AF%AF-%E8%A7%A3%E5%86%B3%20Consul%20%E5%90%AF%E5%8A%A8%E5%90%8E%20Service%20Check%20%E6%8A%A5%E7%BA%A2%E5%8F%89%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>consul 启动后，访问 <a href="http://ip:8500/ui">http://ip:8500/ui</a> ，提示报错 (xxx 是服务器的主机名)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get &quot;http://xxx:2000/actuator/health&quot;: dial tcp: lookup xxx on 100.100.2.136:53: no such host</span><br></pre></td></tr></table></figure>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>首先检查心跳协议是否关闭。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-6338bf5dd0a64cb18192267cb38f08d1.png" alt="image.png"></p>
<p> 打开后还继续报错，然后在 Consul 所在的服务器上配置 host 映射，将报错中的 xxx 映射到 127.0.0.1 ，即可解决。</p>
<ol>
<li>编辑 hosts 文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure></li>
<li>在 127.0.0.1 的后面配置你的主机名 xxx ，保存退出。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在127.0.0.1 的后面配置你的主机名xxx</span><br><span class="line">127.0.0.1 xxx</span><br></pre></td></tr></table></figure>
健康检测通过不再报错。</li>
</ol>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Consul 启动后访问不了原因</title>
    <url>/2020/06/05/%E8%A7%A3%E5%86%B3%20Consul%20%E5%90%AF%E5%8A%A8%E5%90%8E%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E5%8E%9F%E5%9B%A0-%E8%A7%A3%E5%86%B3%20Consul%20%E5%90%AF%E5%8A%A8%E5%90%8E%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>笔记补录：</p>
<p>在阿里云上安装并启动了 consul，以开发模式启动，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./consul agent -dev -ui -node=consul-dev -client=ip地址</span><br></pre></td></tr></table></figure>
<p>于是我在浏览器输入 <a href="http://ip/">http://ip</a> 地址：8500/ui 时一直访问不了。然后查看服务器安全组是否开放 8500 端口。开放 8500 端口后还是访问不了。</p>
<p>解决方法：</p>
<p> -client 加上的指定其他机器即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./consul agent -dev -ui -node=consul-dev -client=0.0.0.0</span><br></pre></td></tr></table></figure>
<p>然后访问 <a href="http://ip/">http://ip</a> 地址：8500/ui 成功。</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Thymeleaf 中 th:if、th:each、th:href、th:onclick 等问题亲测</title>
    <url>/2020/05/26/%E8%A7%A3%E5%86%B3%20Thymeleaf%20%E4%B8%AD%20th_if%E3%80%81th_each%E3%80%81th_href%E3%80%81th_onclick%20%E7%AD%89%E9%97%AE%E9%A2%98%E4%BA%B2%E6%B5%8B-%E8%A7%A3%E5%86%B3%20Thymeleaf%20%E4%B8%AD%20th_if%E3%80%81th_each%E3%80%81th_href%E3%80%81th_onclick%20%E7%AD%89%E9%97%AE%E9%A2%98%E4%BA%B2%E6%B5%8B/</url>
    <content><![CDATA[<p>最近使用若依，对前端的 thymeleaf 语法不是很熟悉，下面是自己的笔记，大神请忽略。 </p>
<h3 id="一、th-if"><a href="#一、th-if" class="headerlink" title="一、th:if"></a>一、th:if</h3><p><strong>gt:     great than（大于）&gt;<br>ge：    great equal（大于等于）&gt;=<br>eq：    equal（等于）==<br>lt：    less than（小于）&lt;<br>le：    less equal（小于等于）&lt;=<br>ne：    not equal（不等于）!=</strong></p>
<p>写法如下，其它写法类似。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div th:if=&quot;$&#123;substringName&#125; ne null&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>th:if 多条件判断 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div th:if=&quot;($&#123;t.pid&#125;==$&#123;s.id&#125;) and $&#123;t.recycle!=1&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="二、th-each"><a href="#二、th-each" class="headerlink" title="二、th:each"></a>二、th:each</h3><p>（1）页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tr th:each=&quot;userStat : $&#123;list&#125;&quot;&gt;</span><br><span class="line">      &lt;td th:text=&quot;$&#123;userStat.substringName&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">      &lt;td id=&quot;ids&quot; th:value=&quot;$&#123;userStat.id&#125;&quot; &gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>

<p>后台：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">HashMap&lt;Object, Object&gt; objectObjectHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">objectObjectHashMap.put(<span class="string">&quot;id&quot;</span>, value.getId());</span><br><span class="line">objectObjectHashMap.put(<span class="string">&quot;substringName&quot;</span>, substringName);</span><br><span class="line">objectObjectHashMap.put(<span class="string">&quot;returnContractPath&quot;</span>, returnContractPath());</span><br><span class="line">list.add(objectObjectHashMap);</span><br><span class="line">map.put(<span class="string">&quot;list&quot;</span>,list);</span><br></pre></td></tr></table></figure>

<p>（2）下拉框传值问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- th:text 为显示的值，th:value 为实际传值 --&gt;</span><br><span class="line">&lt;select name=&quot;contactsId&quot; class=&quot;form-control&quot; id=&quot;contactsId&quot; required&gt;</span><br><span class="line">             &lt;option value=&quot;&quot;&gt;请选择联系人&lt;/option&gt;</span><br><span class="line">             &lt;option th:each=&quot;list:$&#123;sysContacts&#125;&quot; th:value=&quot;$&#123;list.id&#125;&quot;</span><br><span class="line">                   th:text=&quot;$&#123;list.contactName&#125;&quot;&gt;&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="三、js-中引用-thymeleaf"><a href="#三、js-中引用-thymeleaf" class="headerlink" title="三、js 中引用 thymeleaf"></a>三、js 中引用 thymeleaf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注意标签 --&gt;</span><br><span class="line">&lt;script th:inline=&quot;javascript&quot;&gt; </span><br><span class="line">    var editFlag = [[$&#123;@permission.hasPermi(&#x27;system:quotation:edit&#x27;)&#125;]];</span><br><span class="line">    var checkFlag = [[$&#123;@permission.hasPermi(&#x27;system:quotation:check&#x27;)&#125;]];</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="四、th-href-多参数"><a href="#四、th-href-多参数" class="headerlink" title="四、th:href 多参数"></a>四、th:href 多参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a th:href=&quot;@&#123;&#x27;/system/business/downloadFail?failName=&#x27;+$&#123;userStat.substringName&#125;+&#x27;&amp;returnContractPath=&#x27;+$&#123;userStat.returnContractPath&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; class=&quot;btn-xs btn-info&quot; style=&quot;width: 40px&quot; value=&quot;下载&quot;/&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="五、th-onclick-多参数"><a href="#五、th-onclick-多参数" class="headerlink" title="五、th:onclick 多参数"></a>五、th:onclick 多参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot; th:onclick=&quot;removeFile([[$&#123;userStat.id&#125;]],[[$&#123;userStat.returnContractPath&#125;]]);&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; class=&quot;btn btn-danger btn-xs&quot; style=&quot;width: 40px&quot; value=&quot;删除&quot;/&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>js 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function removeFile(userStatId,returnContractPath) &#123;</span><br><span class="line">       var formData = new FormData();</span><br><span class="line">       formData.append(&quot;id&quot;,userStatId);</span><br><span class="line">       formData.append(&quot;returnContractPath&quot;,returnContractPath);</span><br><span class="line">       $.ajax(&#123;</span><br><span class="line">           url: prefix + &quot;/removeFail&quot;,</span><br><span class="line">           type: &#x27;post&#x27;,</span><br><span class="line">           async: false,</span><br><span class="line">           data: formData,</span><br><span class="line">           processData: false,</span><br><span class="line">           contentType: false,</span><br><span class="line">           success: function(result) &#123;</span><br><span class="line">               $.operate.successCallback(result);</span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>解决在WebStorm中使用Vue组件的v-xxx等指令报错</title>
    <url>/2019/11/10/%E8%A7%A3%E5%86%B3%E5%9C%A8WebStorm%E4%B8%AD%E4%BD%BF%E7%94%A8Vue%E7%BB%84%E4%BB%B6%E7%9A%84v-xxx%E7%AD%89%E6%8C%87%E4%BB%A4%E6%8A%A5%E9%94%99-%E8%A7%A3%E5%86%B3%E5%9C%A8WebStorm%E4%B8%AD%E4%BD%BF%E7%94%A8Vue%E7%BB%84%E4%BB%B6%E7%9A%84v-xxx%E7%AD%89%E6%8C%87%E4%BB%A4%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>错误如下，这个报错并不会影响代码执行，但强迫症受不了：<br><img src="https://www.itmengtao.cn/upload/2020/11/image-507c8c19584040b5bc2851e3d76d8b12.png" alt="image.png"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><p>点击File——&gt;Settings——&gt;直接搜索 Unbound XML namespace prefix ，直接把后面的勾去掉，保存即可。<br><img src="https://www.itmengtao.cn/upload/2020/11/image-8649cbe534e548e6a69cad1e0d4c05bb.png" alt="image.png"><br>保存后如下，错误消失。<br><img src="https://www.itmengtao.cn/upload/2020/11/image-ee78aadc50354a4d8f2947785c1f7fc3.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>WebStorm</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title>解密 PDF 并且转换为图片</title>
    <url>/2020/03/03/%E8%A7%A3%E5%AF%86%20PDF%20%E5%B9%B6%E4%B8%94%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9B%BE%E7%89%87-%E8%A7%A3%E5%AF%86%20PDF%20%E5%B9%B6%E4%B8%94%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>工作中遇到问题，将已经加密的 pdf 文档转换为图片。解决如下：</p>
<p>1、先添加依赖进去。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.pdfbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fontbox<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.pdfbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pdfbox<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lowagie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、直接上代码 (亲测)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> com.spire.pdf.PdfDocument;</span><br><span class="line"><span class="keyword">import</span> com.spire.pdf.security.PdfEncryptionKeySize;</span><br><span class="line"><span class="keyword">import</span> com.spire.pdf.security.PdfPermissionsFlags;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.pdmodel.PDDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.rendering.PDFRenderer;</span><br><span class="line"><span class="keyword">import</span> com.lowagie.text.pdf.PdfReader;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfToImg</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//以下是解密文档</span></span><br><span class="line">            <span class="comment">//创建PdfDocument实例</span></span><br><span class="line">            PdfDocument doc = <span class="keyword">new</span> PdfDocument();</span><br><span class="line">            <span class="comment">//加载带密码保护的PDF文件</span></span><br><span class="line">            doc.loadFromFile(<span class="string">&quot;D:\\aaa.pdf&quot;</span>, <span class="string">&quot;这里是打开文档的密码,如果不加给个空就行&quot;</span>);</span><br><span class="line">            <span class="comment">//解除文档中的密码保护</span></span><br><span class="line">            doc.getSecurity().encrypt(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, PdfPermissionsFlags.getDefaultPermissions(), PdfEncryptionKeySize.Key_256_Bit, <span class="string">&quot;这里是允许编辑文档的密码，如果不加给个空就行&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//保存文件(保存的新文件不能与源文件同名)</span></span><br><span class="line">            doc.saveToFile(<span class="string">&quot;D:\\bbb.pdf&quot;</span>);</span><br><span class="line">            doc.close();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment">//以下是pdf转图片 dpi越大转换后越清晰，相对转换速度越慢</span></span><br><span class="line">            pdf2Image(<span class="string">&quot;D:\\bbb.pdf&quot;</span>, <span class="string">&quot;D:\\pdf\\&quot;</span>, <span class="number">400</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * PDF文件转PNG图片，全部页数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> PdfFilePath pdf完整路径</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> dpi dpi越大转换后越清晰，相对转换速度越慢</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pdf2Image</span><span class="params">(String PdfFilePath, String dstImgFolder, <span class="keyword">int</span> dpi)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            File file = <span class="keyword">new</span> File(PdfFilePath);</span><br><span class="line"> </span><br><span class="line">            PDDocument pdDocument;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">                String imgPDFPath = file.getParent();</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">int</span> dot = file.getName().lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">                String imagePDFName = file.getName().substring(<span class="number">0</span>, dot); <span class="comment">// 获取图片文件名</span></span><br><span class="line"> </span><br><span class="line">                String imgFolderPath = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (dstImgFolder.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line"> </span><br><span class="line">                    imgFolderPath = imgPDFPath + File.separator + imagePDFName;<span class="comment">// 获取图片存放的文件夹路径</span></span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">                    imgFolderPath = dstImgFolder + File.separator + imagePDFName;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (createDirectory(imgFolderPath)) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                    pdDocument = PDDocument.load(file);</span><br><span class="line"> </span><br><span class="line">                    PDFRenderer renderer = <span class="keyword">new</span> PDFRenderer(pdDocument);</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">/* dpi越大转换后越清晰，相对转换速度越慢 */</span></span><br><span class="line"> </span><br><span class="line">                    PdfReader reader = <span class="keyword">new</span> PdfReader(PdfFilePath);</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">int</span> pages = reader.getNumberOfPages();</span><br><span class="line"> </span><br><span class="line">                    StringBuffer imgFilePath = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pages; i++) &#123;</span><br><span class="line"> </span><br><span class="line">                        String imgFilePathPrefix = imgFolderPath + File.separator + imagePDFName;</span><br><span class="line"> </span><br><span class="line">                        imgFilePath = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> </span><br><span class="line">                        imgFilePath.append(imgFilePathPrefix);</span><br><span class="line"> </span><br><span class="line">                        imgFilePath.append(<span class="string">&quot;_&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                        imgFilePath.append(String.valueOf(i + <span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">                        imgFilePath.append(<span class="string">&quot;.png&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                        File dstFile = <span class="keyword">new</span> File(imgFilePath.toString());</span><br><span class="line"> </span><br><span class="line">                        BufferedImage image = renderer.renderImageWithDPI(i, dpi);</span><br><span class="line"> </span><br><span class="line">                        ImageIO.write(image, <span class="string">&quot;png&quot;</span>, dstFile);</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    System.out.println(<span class="string">&quot;PDF文档转PNG图片成功！&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">                    System.out.println(<span class="string">&quot;PDF文档转PNG图片失败：&quot;</span> + <span class="string">&quot;创建&quot;</span> + imgFolderPath + <span class="string">&quot;失败&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">createDirectory</span><span class="params">(String folder)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            File dir = <span class="keyword">new</span> File(folder);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (dir.exists()) &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">return</span> dir.mkdirs();</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>详解 Spire.PDF 中的坐标体系及应用</title>
    <url>/2020/01/05/%E8%AF%A6%E8%A7%A3%20Spire.PDF%20%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB%E5%8F%8A%E5%BA%94%E7%94%A8-%E8%AF%A6%E8%A7%A3%20Spire.PDF%20%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>Spire.PDF 是一款专业的基于.NET 平台的 PDF 组件。它能够让开发人员在不使用 Adobe Acrobat 和其他外部控件的情况下，运用.NET 应用程序创建，阅读，编写和操纵 PDF 文档。文本将详细为大家介绍 Spire.PDF 中坐标体系及其应用。</p>
<h2 id="坐标系定义"><a href="#坐标系定义" class="headerlink" title="坐标系定义"></a>坐标系定义</h2><p>坐标系是 PDF 中一项十分重要的体系，PDF 的中任何元素，例如文本、图片、表格等，都必须建立在坐标体系上。有了坐标系，我们才能在指定的位置添加（绘制）这些内容。Adobe 公司的 PDF 文档规范中将坐标系的原点定在了页面的左下角，这样的坐标系其实不方便我们自上而下书写内容。Spire.PDF 的坐标系有如下规定：</p>
<ul>
<li>原点位于 PDF 页面的左上角定点</li>
<li>X 正半轴是原点开始向右延伸的轴，Y 正半轴是原点开始向下延伸的轴</li>
<li>以磅作为单位，如果 PDF 页面大小为 A4，那么页面右下角定点坐标为（595,842）</li>
</ul>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-99d720d3be49499a9204bcaaaefdf422.png" alt="image.png"></p>
<p>从以上规定中，我们很容易看出，Spire.PDF 中的坐标体系很方便程序员自上而下在 PDF 页面上添加页面元素。除了以上设定以外，Spire.PDF 的新建 PDF 页面内还有边缘（PdfMargins）的设定，边缘是为了方便程序员在除边缘以外的地方添加内容，这跟 Word 中的边缘设定比较类似。由于边缘的出现，在新建页面中，坐标原点的位置是除边缘以外的区域的左上角定点。这样的设定，方便程序员在 PDF 页面上添加内容时不再需要人为地留出空白。</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-651d8b9412b7474390382d160d505cb7.png" alt="image.png"></p>
<p>上面一直强调新建页面，在现成的 PDF 页面中是没有边缘的概念的。实际上，Adobe PDF 文档规范也没有边缘的概念。对于一个现成的 PDF 页面，坐标系维持原先的规定不变。现在对新建页面中的坐标体系做出总结：</p>
<ul>
<li>新建页面中，坐标系原点开始于除边缘外的左上角定点</li>
<li>边缘区域内有坐标，但是边缘区域不能显示任何内容</li>
<li>如果想在边缘区域绘制内容，在创建页面时必须将边缘设置为 0，此时坐标系原点回到页面左上角定点</li>
</ul>
<h2 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h2><p>在 PDF 中添加内容时，为了让内容呈现某种的效果，例如将文字和图片旋转一定角度，我们需要借助坐标系转换来是实现这些效果。Spire.PDF 中坐标系转换包括下如图 3 所示的四种方式，它们对应的方法分别是 TranslateTrsanform, ScaleTransform, RotateTransform 和 SkewTransform。下面举例说明它们的用法：  </p>
<p>TranslateTransform (5,5) 表示坐标系向右、向下分别平移 5 个单位<br>ScaleTransform (2,2) 表示 X、Y 轴上的单位长度放大 2 倍<br>RotateTansform (-45) 表示坐标系逆时针旋转 45 度<br>SkewTransform (10,10) 表示 X 轴向下倾斜 10 度，Y 轴向右倾斜 10 度</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-f80a0f826516467fba68311bd34519f2.png" alt="image.png"></p>
<h2 id="坐标系的应用"><a href="#坐标系的应用" class="headerlink" title="坐标系的应用"></a>坐标系的应用</h2><h3 id="1-在指定位置绘制文本、图片等"><a href="#1-在指定位置绘制文本、图片等" class="headerlink" title="1. 在指定位置绘制文本、图片等"></a>1. 在指定位置绘制文本、图片等</h3><p>整个 PDF 页面实际上一块大的画布，我们需要通过 Canvas.DrawString 方法和 Canvas.DrawImage 方法绘制文本和图片，参考代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建PdfDocument对象</span></span><br><span class="line">PdfDocument doc = <span class="keyword">new</span> PdfDocument();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*添加页面，指定页面大小和边缘大小</span></span><br><span class="line"><span class="comment"> *   该方法还有以下重载方法，无参的方法默认含有40磅的边距</span></span><br><span class="line"><span class="comment"> *   Add(); </span></span><br><span class="line"><span class="comment"> *   Add(SizeF size); </span></span><br><span class="line"><span class="comment"> *   Add(SizeF size, PdfMargins margins);</span></span><br><span class="line"><span class="comment"> *   Add(SizeF size, PdfMargins margins, PdfPageRotateAngle rotation);</span></span><br><span class="line"><span class="comment"> *   Add(SizeF size, PdfMargins margins, PdfPageRotateAngle rotation, PdfPageOrientation orientation);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">doc.Pages.Add(PdfPageSize.A4, <span class="keyword">new</span> PdfMargins(<span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建TrueType字体</span></span><br><span class="line">PdfTrueTypeFont font= <span class="keyword">new</span> PdfTrueTypeFont(<span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>,<span class="number">10</span>),<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在PDF页面中的指定位置绘制文字</span></span><br><span class="line">doc.Pages[<span class="number">0</span>].Canvas.DrawString(<span class="string">&quot;你好&quot;</span>, font, PdfPens.Black, <span class="keyword">new</span> PointF(<span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加载图片到PdfImage对象</span></span><br><span class="line">PdfImage image= PdfImage.FromFile(@<span class="string">&quot;C:\Users\Administrator\Desktop\flag.png&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在PDF页面中的指定位置绘制图片</span></span><br><span class="line">doc.Pages[<span class="number">0</span>].Canvas.DrawImage(image, <span class="number">50</span>, <span class="number">70</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//保存文档</span></span><br><span class="line">doc.SaveToFile(<span class="string">&quot;output.pdf&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-获取文字、图片坐标"><a href="#2-获取文字、图片坐标" class="headerlink" title="2. 获取文字、图片坐标"></a>2. 获取文字、图片坐标</h3><p>有了坐标体系，我们也可以获取现有 PDF 文档中文字或图片的位置（X,Y 坐标），代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建PdfDocument对象</span></span><br><span class="line">PdfDocument doc = <span class="keyword">new</span> PdfDocument();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加载一个现有的PDF文档</span></span><br><span class="line">doc.LoadFromFile(@<span class="string">&quot;C:\Users\Administrator\Desktop\test.pdf&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查找第一页中所有的“Germany”</span></span><br><span class="line">PdfTextFind[] text = doc.Pages[<span class="number">0</span>].FindText(<span class="string">&quot;Germany&quot;</span>).Finds;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取第一个“Germany”出现的位置</span></span><br><span class="line">PointF p = text[<span class="number">0</span>].Position;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;第一个Germany出现的位置：(&#123;0&#125;,&#123;1&#125;)&quot;</span>, p.X, p.Y);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取第一页中所有的图片信息</span></span><br><span class="line">PdfImageInfo[] imageInfo = doc.Pages[<span class="number">0</span>].ImagesInfo;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取第一张图片的位置信息</span></span><br><span class="line">RectangleF rect = imageInfo[<span class="number">0</span>].Bounds;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;第一张图片的位置：(&#123;0&#125;,&#123;1&#125;)&quot;</span>, rect.X, rect.Y);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<h3 id="3-利用坐标系转换创建居中呈-45-度的文字效果"><a href="#3-利用坐标系转换创建居中呈-45-度的文字效果" class="headerlink" title="3. 利用坐标系转换创建居中呈 45 度的文字效果"></a>3. 利用坐标系转换创建居中呈 45 度的文字效果</h3><p>这里我们将借助坐标的转换方法，在一个文档正中间添加一行斜向上的文字，形成一种 “水印文字” 的感觉。代码中涉及到了一些坐标平移的位置计算，这里不做太详细的介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建PdfDocument对象</span></span><br><span class="line">PdfDocument pdf = <span class="keyword">new</span> PdfDocument();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加载现有PDF文档</span></span><br><span class="line">pdf.LoadFromFile(@<span class="string">&quot;F:\Documents\PDF\系统测试.pdf&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建字体</span></span><br><span class="line">PdfTrueTypeFont font = <span class="keyword">new</span> PdfTrueTypeFont(<span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>, <span class="number">40f</span>), <span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//要写的文字</span></span><br><span class="line">string text = <span class="string">&quot;版权所有，侵权必究&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测量文字所占的位置大小，即高宽</span></span><br><span class="line">SizeF fontSize = font.MeasureString(text);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//计算两个偏移量</span></span><br><span class="line"><span class="keyword">float</span> offset1 = (<span class="keyword">float</span>)(fontSize.Width * System.Math.Sqrt(<span class="number">2</span>) / <span class="number">4</span>);</span><br><span class="line"><span class="keyword">float</span> offset2 = (<span class="keyword">float</span>)(fontSize.Height * System.Math.Sqrt(<span class="number">2</span>) / <span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历文档每一页</span></span><br><span class="line">foreach (PdfPageBase page in pdf.Pages)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置页面透明度</span></span><br><span class="line">    page.Canvas.SetTransparency(<span class="number">0.8f</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将页面中坐标系向右下平移</span></span><br><span class="line">    page.Canvas.TranslateTransform(page.Canvas.Size.Width / <span class="number">2</span> - offset1 - offset2, page.Canvas.Size.Height / <span class="number">2</span> + offset1 - offset2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将坐标系逆时针旋转45度</span></span><br><span class="line">    page.Canvas.RotateTransform(-<span class="number">45</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在页面上绘制文本</span></span><br><span class="line">    page.Canvas.DrawString(text, font, PdfBrushes.DarkGray, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//保存文档</span></span><br><span class="line">pdf.SaveToFile(<span class="string">&quot;output.pdf&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-d43005cb006e48099aa178d8edc9451c.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云 Centos 7.x 安装 Consul</title>
    <url>/2020/06/26/%E9%98%BF%E9%87%8C%E4%BA%91%20Centos%207.x%20%E5%AE%89%E8%A3%85%20Consul-%E9%98%BF%E9%87%8C%E4%BA%91%20Centos%207.x%20%E5%AE%89%E8%A3%85%20Consul/</url>
    <content><![CDATA[<h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><p><a href="https://www.consul.io/downloads.html">consul 下载链接</a><br>选择 linux 版本 下载好后 在传到服务器上</p>
<p>或者直接在 linux wget 下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://releases.hashicorp.com/consul/1.7.1/consul_1.7.1_linux_amd64.zip</span><br></pre></td></tr></table></figure>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><p>然后进入根目录解压：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip consul_1.7.1_linux_amd64.zip</span><br></pre></td></tr></table></figure>
<p>解压完成后，在根目录 可以看到 Consul 文件，然后执行以下命令，启动 Consul.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #此处ip也可写0.0.0.0</span><br><span class="line">./consul agent -dev -ui -node=consul-dev -client=ip地址</span><br></pre></td></tr></table></figure>

<p>阿里云设置安全组加入 8500 端口。防火墙加入 8500 端口并重启。</p>
<p>然后浏览器输入：<a href="http://id/8500">http://id/8500</a>    如下图已安装成功：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/12/image-603c6479da7d4e88b83dd11fb4e01eeb.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云盘不限速来了，一大堆福利码送上</title>
    <url>/2021/03/24/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E4%B8%8D%E9%99%90%E9%80%9F%E6%9D%A5%E4%BA%86%EF%BC%8C%E4%B8%80%E5%A4%A7%E5%A0%86%E7%A6%8F%E5%88%A9%E7%A0%81%E9%80%81%E4%B8%8A-%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E4%B8%8D%E9%99%90%E9%80%9F%E6%9D%A5%E4%BA%86%E4%B8%80%E5%A4%A7%E5%A0%86%E7%A6%8F%E5%88%A9%E7%A0%81%E9%80%81%E4%B8%8A/</url>
    <content><![CDATA[<p>近期，大家都在聊的阿里云盘 App 版迎来了 2.0.5 更新，相册、探索、保险箱等功能升级，同时也上线了福利社功能，用户可以通过做任务的方式扩增阿里云盘容量，轻松解锁福利卡，并且后续可能还会有新的福利卡解锁。</p>
<p>但这些都不是亮点，亮点就是上传下载均 “<strong>不限速</strong>”。我也体验了一下视频的上传下载，几乎秒传，确实比百度云有感觉多了。那么不限速的问题解决了，容量的问题怎么办呢？上面那些做任务的说实话真不够用。我目前已经找到一些福利码，如下（亲测有用）：</p>
<p>・戴老师爱较真（500G）</p>
<p>・飞跃彩虹（322G 官方）</p>
<p>・江宁婆婆 （500G）</p>
<p>・陈泥玛评测 （500G）</p>
<p>・知识就是力量 （500G）</p>
<p>・知识需要容量 （500G）</p>
<p>・科技中国 （500G）</p>
<p>・干翻百度 （500G）</p>
<p>・资深盘友 （500G）</p>
<p>・手机中国. （500G）</p>
<p>・上云上阿里云 500G</p>
<p>・巴巴带你扩容 500G</p>
<p>・阿里云购爆款 500G</p>
<p>・达摩院招保洁 500G</p>
<p>・寄快递用裹裹 500G</p>
<p>・发言人求来的 500G</p>
<p>・发言人送你的 500G</p>
<p>・许愿不要过气 500G</p>
<p>・扫地僧头发多 500G</p>
<p>・我爱爱范儿 200G</p>
<p>・天涯历知幸 200G</p>
<p>·yangyi</p>
<p>・科技中国</p>
<p>・手机中国</p>
<p>・资深盘友</p>
<p>・陈泥玛评测</p>
<p>以上福利码我在两天时间已经领了接近 3T 了，相信最终领个 7/8T 不是问题。如下：</p>
<p><img src="https://www.itmengtao.cn/upload/2021/03/image-b6f4729cfec248af8b4e4e4158cbb297.png" alt="image.png"></p>
<p>最后再来说说百度云，百度云盘在前两年出了一款应用名叫 “<strong>一刻相册</strong>”。这个应用是 “<strong>无限空间</strong>”，对，你没有看错，随意存储​。它可以完全代替你的手机相册并且不占用那么多空间，图片视频都可随意上传​。目前唯一的缺点就是大容量的视频上传不了，当然你开会员就可以了。不过没必要，我们用阿里云不限速它不香吗？当你第一次下载时只有 100GB，需要邀请码才可变为无限空间。一刻相册邀请码奉上：</p>
<p><img src="https://www.itmengtao.cn/upload/2021/03/image-982806acb3b1407b947ff1c4e68817d1.png" alt="image.png"></p>
<p>​<strong>总结</strong>：两个 APP 就能让节省大部分手机内存了，关键是白嫖​而且好用，以上。</p>
]]></content>
      <categories>
        <category>工作生活</category>
      </categories>
      <tags>
        <tag>工作生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot——整合websocket构建在线聊天室（群聊 / 私聊）</title>
    <url>/2019/07/20/Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88websocket%E6%9E%84%E5%BB%BA%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%88%E7%BE%A4%E8%81%8A/%20%E7%A7%81%E8%81%8A%EF%BC%89-Spring%20Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88websocket%E6%9E%84%E5%BB%BA%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%88%E7%BE%A4%E8%81%8A/%20%E7%A7%81%E8%81%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-注入对象ServerEndpointExporter"><a href="#2-注入对象ServerEndpointExporter" class="headerlink" title="2.注入对象ServerEndpointExporter"></a>2.注入对象ServerEndpointExporter</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *编写一个WebSocketConfig配置类，注入对象ServerEndpointExporter，</span></span><br><span class="line"><span class="comment"> *      这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-WebSocket-具体实现类"><a href="#3-WebSocket-具体实现类" class="headerlink" title="3.WebSocket 具体实现类"></a>3.WebSocket 具体实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springbootwebsocket.mysocket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonParseException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonMappingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.PathParam;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 虽然<span class="doctag">@Component</span>默认是单例模式的，但是spring boot 还是会为每个websocket连接初始化一个bean,所以这里使用一个静态的set保存spring boot</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 创建的bean--MyWebSocket.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@ServerEndpoint(value=&quot;/websocket/&#123;nickname&#125;&quot;)</span><span class="comment">// websocket连接点映射.</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocket</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//用来存储每个客户端对应的MyWebSocket对象.</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;MyWebSocket&gt; webSocketSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;MyWebSocket&gt;();</span><br><span class="line">	<span class="comment">//用来记录sessionId和该session之间的绑定关系.</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Session&gt; map = <span class="keyword">new</span> HashMap&lt;String,Session&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Session session;<span class="comment">//当前会话的session.</span></span><br><span class="line">	<span class="keyword">private</span> String nickname;<span class="comment">//昵称.</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 成功建立连接调用的方法.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@OnOpen</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session,<span class="meta">@PathParam(&quot;nickname&quot;)</span> String nickname)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.session = session;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">		map.put(session.getId(), session);</span><br><span class="line">		webSocketSet.add(<span class="keyword">this</span>);<span class="comment">//加入set中.</span></span><br><span class="line">		<span class="keyword">this</span>.session.getAsyncRemote().sendText(nickname+<span class="string">&quot;上线了,（我的id号是&quot;</span>+session.getId()+<span class="string">&quot;）&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 连接关闭调用的方法.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@OnClose</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">		webSocketSet.remove(<span class="keyword">this</span>);<span class="comment">//从set中移除.</span></span><br><span class="line">		map.remove(session.getId());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 收到客户端消息后调用的方法.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@OnMessage</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message,Session session,<span class="meta">@PathParam(&quot;nickname&quot;)</span> String nickname)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//message 不是普通的string ，而是我们定义的SocketMsg json字符串.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			SocketMsg socketMsg = <span class="keyword">new</span> ObjectMapper().readValue(message, SocketMsg.class);</span><br><span class="line">			</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//单聊.</span></span><br><span class="line">			<span class="keyword">if</span>(socketMsg.getType() == <span class="number">1</span>)&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//单聊：需要找到发送者和接受者即可.</span></span><br><span class="line">				socketMsg.setFromUser(session.getId());<span class="comment">//发送者.</span></span><br><span class="line">				<span class="comment">//socketMsg.setToUser(toUser);//这个是由客户端进行设置.</span></span><br><span class="line">				Session fromSession = map.get(socketMsg.getFromUser());</span><br><span class="line">				Session toSession = map.get(socketMsg.getToUser());</span><br><span class="line">				<span class="keyword">if</span>(toSession != <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="comment">//发送消息.</span></span><br><span class="line">					fromSession.getAsyncRemote().sendText(nickname+<span class="string">&quot;：&quot;</span>+socketMsg.getMsg());</span><br><span class="line">					toSession.getAsyncRemote().sendText(nickname+<span class="string">&quot;：&quot;</span>+socketMsg.getMsg());</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					fromSession.getAsyncRemote().sendText(<span class="string">&quot;系统消息：对方不在线或者您输入的id号有误&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//群发给每个客户端.</span></span><br><span class="line">				broadcast(socketMsg,nickname);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (JsonParseException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (JsonMappingException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 发生错误时调用.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session,Throwable error)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">		error.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 群发的方法.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(SocketMsg socketMsg ,String nickname)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(MyWebSocket item:webSocketSet)&#123;</span><br><span class="line">			<span class="comment">//发送消息.</span></span><br><span class="line">			item.session.getAsyncRemote().sendText(nickname+<span class="string">&quot;：&quot;</span>+socketMsg.getMsg());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-创建消息对象SocketMsg"><a href="#4-创建消息对象SocketMsg" class="headerlink" title="4.创建消息对象SocketMsg"></a>4.创建消息对象SocketMsg</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springbootwebsocket.mysocket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMsg</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> type;<span class="comment">//聊天类型，0：群聊；1：单聊;</span></span><br><span class="line">	<span class="keyword">private</span> String fromUser;<span class="comment">//发送者.</span></span><br><span class="line">	<span class="keyword">private</span> String toUser;<span class="comment">//接受者. session.getId();</span></span><br><span class="line">	<span class="keyword">private</span> String msg;<span class="comment">//消息.</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getFromUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fromUser;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFromUser</span><span class="params">(String fromUser)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.fromUser = fromUser;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getToUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> toUser;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToUser</span><span class="params">(String toUser)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.toUser = toUser;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> msg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-static目录下创建客户端-webSocketTest-html"><a href="#5-static目录下创建客户端-webSocketTest-html" class="headerlink" title="5.static目录下创建客户端 webSocketTest.html"></a>5.static目录下创建客户端 webSocketTest.html</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"> </span></span><br><span class="line"><span class="css">        <span class="selector-id">#message</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>:<span class="number">1px</span> solid gray;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">昵称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nickname&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;conectWebSocket()&quot;</span>&gt;</span>连接服务器<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;closeWebSocket()&quot;</span>&gt;</span>断开连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">消息：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>  /&gt;</span></span><br><span class="line">id号<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;toUser&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send()&quot;</span>&gt;</span>发送消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 存放接收到的消息. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    <span class="comment">//连接对象.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> nickname = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">conectWebSocket</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        nickname = <span class="built_in">document</span>.getElementById(<span class="string">&quot;nickname&quot;</span>).value;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(nickname == <span class="string">&#x27;&#x27;</span>)&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;请输入昵称&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//判断当前的浏览器是否支持websocket.</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="string">&quot;WebSocket&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span></span><br><span class="line"><span class="javascript">            websocket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8080/websocket/&quot;</span>+nickname);</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;Not support websocket&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">        <span class="comment">//连接成功的方法.</span></span></span><br><span class="line"><span class="javascript">        websocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            setMessgeHtml(<span class="string">&quot;Loc MSG:连接成功&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">        <span class="comment">//连接关闭.</span></span></span><br><span class="line"><span class="javascript">        websocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            setMessgeHtml(<span class="string">&quot;Loc MSG:连接关闭&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">        <span class="comment">//连接异常.</span></span></span><br><span class="line"><span class="javascript">        websocket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            setMessgeHtml(<span class="string">&quot;Loc MSG:连接异常&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">        websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            setMessgeHtml(event.data);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">setMessgeHtml</span>(<span class="params">msg</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">&quot;message&quot;</span>);</span></span><br><span class="line"><span class="javascript">        message.innerHTML += msg+<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="javascript">     发送消息.</span></span></span><br><span class="line"><span class="comment"><span class="javascript">     */</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">&quot;text&quot;</span>).value;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> toUser = <span class="built_in">document</span>.getElementById(<span class="string">&quot;toUser&quot;</span>).value;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> socketMsg = &#123;<span class="attr">msg</span>:message,<span class="attr">toUser</span>:toUser&#125;;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(toUser == <span class="string">&#x27;&#x27;</span>)&#123;</span></span><br><span class="line"><span class="javascript">            socketMsg.type =<span class="number">0</span>;<span class="comment">//群聊.</span></span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            socketMsg.type =<span class="number">1</span>;<span class="comment">//单聊.</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">        <span class="comment">//websocket.send(nickname+&quot;:&quot;+message);</span></span></span><br><span class="line"><span class="javascript">        websocket.send(<span class="built_in">JSON</span>.stringify(socketMsg));<span class="comment">//将json对象转换为json字符串.</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试，打开多个登录窗口，输入<a href="http://127.0.0.1:8080/webSocketTest.html">http://127.0.0.1:8080/webSocketTest.html</a> ，输入昵称点击连接即可登录成功，群聊直接发送消息即可，私聊输入完消息后，选择对应那个人的id号码就行，快去试试吧：</p>
<p><img src="https://www.itmengtao.cn/upload/2020/11/image-d04e9785d4e246049bd5b6d6caf0eff0.png" alt="image.png"></p>
<p>总结：了解了websocket底层是怎么实现的，websocket协议稍微麻烦，其实我们完全可以用它的子协议STOMP来实现本文所有的功能，因已封装的很好，用起来非常简单，实例：<a href="https://blog.csdn.net/qq_41603102/article/details/88351729">SpringBoot+STOMP 实现聊天室（单聊+多聊）及群发消息详解</a>。</p>
<p>参考：<a href="https://www.iteye.com/blog/412887952-qq-com-2405514">https://www.iteye.com/blog/412887952-qq-com-2405514</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令大全</title>
    <url>/2019/02/28/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>文件和目录:</p>
<p> cd /home                        进入 ‘/home’ 目录</p>
<p> cd ..                                返回上一级目录</p>
<p> cd ../..                             返回上两级目录</p>
<p> cd -                                 返回上次所在目录</p>
<p> cp file1 file2                    将file1复制为file2</p>
<p> cp -a dir1 dir2                 复制一个目录</p>
<p> cp -a /tmp/dir1 .              复制一个目录到当前工作目录（.代表当前目录）</p>
<p> ls                                    查看目录中的文件</p>
<p> ls -a                                显示隐藏文件</p>
<p> ls -l                                 显示详细信息</p>
<p> ls -lrt                               按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）</p>
<p> pwd                                显示工作路径</p>
<p> mkdir dir1                       创建 ‘dir1’ 目录</p>
<p> mkdir dir1 dir2                同时创建两个目录</p>
<p> mkdir -p /tmp/dir1/dir2    创建一个目录树</p>
<p> mv dir1 dir2                    移动/重命名一个目录</p>
<p> rm -f file1                        删除 ‘file1’</p>
<p> rm -rf dir1                       删除 ‘dir1’ 目录及其子目录内容</p>
<p>查看文件内容:</p>
<p> cat file1                          从第一个字节开始正向查看文件的内容</p>
<p> head -2 file1                   查看一个文件的前两行</p>
<p> more file1                       查看一个长文件的内容</p>
<p> tac file1                          从最后一行开始反向查看一个文件的内容</p>
<p> tail -3 file1                      查看一个文件的最后三行</p>
<p>文本处理:</p>
<p> grep str /tmp/test            在文件 ‘/tmp/test’ 中查找 “str”</p>
<p> grep ^str /tmp/test           在文件 ‘/tmp/test’ 中查找以 “str” 开始的行</p>
<p> grep [0-9] /tmp/test         查找 ‘/tmp/test’ 文件中所有包含数字的行</p>
<p> grep str -r /tmp/*             在目录 ‘/tmp’ 及其子目录中查找 “str”</p>
<p> diff file1 file2                   找出两个文件的不同处</p>
<p> sdiff file1 file2                 以对比的方式显示两个文件的不同</p>
<p>查找:</p>
<p> find / -name file1                                                 从 ‘/‘ 开始进入根文件系统查找文件和目录</p>
<p> find / -user user1                                                查找属于用户 ‘user1’ 的文件和目录</p>
<p> find /home/user1 -name *.bin                            在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件</p>
<p> find /usr/bin -type f -atime +100                         查找在过去100天内未被使用过的执行文件</p>
<p> find /usr/bin -type f -mtime -10                           查找在10天内被创建或者修改过的文件</p>
<p> locate *.ps                                                         寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令</p>
<p> find -name ‘*.[ch]’ | xargs grep -E ‘expr’              在当前目录及其子目录所有.c和.h文件中查找 ‘expr’</p>
<p> find -type f -print0 | xargs -r0 grep -F ‘expr’        在当前目录及其子目录的常规文件中查找 ‘expr’</p>
<p> find -maxdepth 1 -type f | xargs grep -F ‘expr’    在当前目录中查找 ‘expr’</p>
<p>压缩和解压:</p>
<p> bzip2 file1                                   压缩 file1</p>
<p> bunzip2 file1.bz2                        解压 file1.bz2</p>
<p> gzip file1                                     压缩 file1</p>
<p> gzip -9 file1                                最大程度压缩 file1</p>
<p> gunzip file1.gz                            解压 file1.gz</p>
<p> tar -cvf archive.tar file1               把file1打包成 archive.tar</p>
<p>（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）</p>
<p> tar -cvf archive.tar file1 dir1        把 file1，dir1 打包成 archive.tar</p>
<p> tar -tf archive.tar                         显示一个包中的内容</p>
<p> tar -xvf archive.tar                      释放一个包</p>
<p> tar -xvf archive.tar -C /tmp         把压缩包释放到 /tmp目录下</p>
<p> zip file1.zip file1                          创建一个zip格式的压缩包</p>
<p> zip -r file1.zip file1 dir1               把文件和目录压缩成一个zip格式的压缩包</p>
<p> unzip file1.zip                             解压一个zip格式的压缩包到当前目录</p>
<p> unzip test.zip -d /tmp/                 解压一个zip格式的压缩包到 /tmp 目录</p>
<p>yum工具:</p>
<p> yum -y install [package]              下载并安装一个rpm包</p>
<p> yum localinstall [package.rpm]    安装一个rpm包，使用你自己的软件仓库解决所有依赖关系</p>
<p> yum -y update                              更新当前系统中安装的所有rpm包</p>
<p> yum update [package]                 更新一个rpm包</p>
<p> yum remove [package]                删除一个rpm包</p>
<p> yum list                                        列出当前系统中安装的所有包</p>
<p> yum search [package]                 在rpm仓库中搜寻软件包</p>
<p> yum clean [package]                   清除缓存目录（/var/cache/yum）下的软件包</p>
<p> yum clean headers                      删除所有头文件</p>
<p> yum clean all                                删除所有缓存的包和头文件</p>
<p>网络:</p>
<p> ifconfig eth0                                                                       显示一个以太网卡的配置</p>
<p> ifconfig eth0 192.168.1.1 netmask 255.255.255.0            配置网卡的IP地址</p>
<p> ifdown eth0                                                                        禁用 ‘eth0’ 网络设备</p>
<p> ifup eth0                                                                            启用 ‘eth0’ 网络设备</p>
<p> iwconfig eth1                                                                     显示一个无线网卡的配置</p>
<p> iwlist scan                                                                         显示无线网络</p>
<p> ip addr show                                                                     显示网卡的IP地址</p>
<p>其他:</p>
<p> su -                                 切换到root权限（与su有区别）</p>
<p> shutdown -h now           关机</p>
<p> shutdown -r now            重启</p>
<p> top                                  罗列使用CPU资源最多的linux任务 （输入q退出）</p>
<p> pstree                             以树状图显示程序</p>
<p> man ping                        查看参考手册（例如ping 命令）</p>
<p> passwd                          修改密码</p>
<p> df -h                               显示磁盘的使用情况</p>
<p> cal -3                             显示前一个月，当前月以及下一个月的月历</p>
<p> cal 10 1988                   显示指定月，年的月历</p>
<p> date –date ‘1970-01-01 UTC 1427888888 seconds’   把一相对于1970-01-01 00:00的秒数转换成时间</p>
<p>第二次整理：<br>系统信息<br>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS</p>
<p>关机 (系统的关机、重启以及登出 )<br>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销</p>
<p>保存命令<br>按ESC键 跳到命令模式，然后：<br>:w   保存文件但不退出vi<br>:w file 将修改另外保存到file中，不退出vi<br>:w!   强制保存，不推出vi<br>:wq  保存文件并退出vi (默认)<br>:wq! 强制保存文件，并退出vi<br>:q 不保存文件，退出vi<br>:q! 不保存文件，强制退出vi<br>:e! 放弃所有修改，从上次保存文件开始再编辑</p>
<p>文件和目录<br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</p>
<p>文件搜索<br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径</p>
<p>挂载一个文件系统<br>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p>
<p>磁盘空间<br>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p>
<p>用户和群组<br>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p>
<p>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消<br>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位         赋予文件夹权限：chmod -R 777   /路径/…</p>
<p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消<br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性       </p>
<p>打包和压缩文件<br>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包</p>
<p>RPM 包 - （Fedora, Redhat及类似系统）<br>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p>
<p>YUM 软件包升级器 - （Fedora, RedHat及类似系统）<br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件</p>
<p>DEB 包 (Debian, Ubuntu 以及类似系统)<br>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</p>
<p>APT 软件工具 (Debian, Ubuntu 以及类似系统)<br>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</p>
<p>查看文件内容<br>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p>
<p>文本处理<br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p>
<p>字符设置和文件格式转换<br>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式</p>
<p>文件系统分析<br>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p>
<p>初始化一个文件系统<br>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统</p>
<p>SWAP文件系统<br>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区</p>
<p>备份<br>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容</p>
<p>光盘<br>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD</p>
]]></content>
      <categories>
        <category>CentOS | Linux</category>
      </categories>
      <tags>
        <tag>CentOS  | Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql高性能优化规范建议</title>
    <url>/2019/03/06/Mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE-Mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>阅读目录(Content)</p>
<p>数据库命令规范<br>数据库基本设计规范</p>
<ol>
<li>所有表必须使用Innodb存储引擎</li>
<li>数据库和表的字符集统一使用UTF8</li>
<li>所有表和字段都需要添加注释</li>
<li>尽量控制单表数据量的大小，建议控制在500万以内</li>
<li>谨慎使用Mysql分区表</li>
<li>尽量做到冷热数据分离，减小表的宽度</li>
<li>禁止在表中建立预留字段</li>
<li>禁止在数据库中存储图片，文件等大的二进制数据</li>
<li>禁止在线上做数据库压力测试</li>
<li>禁止从开发环境，测试环境直接连接生成环境数据库<br>数据库字段设计规范</li>
<li>优先选择符合存储需要的最小的数据类型</li>
<li>避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据</li>
<li>避免使用ENUM类型</li>
<li>尽可能把所有列定义为NOT NULL</li>
<li>使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间</li>
<li>同财务相关的金额类数据必须使用decimal类型<br>索引设计规范</li>
<li>限制每张表上的索引数量，建议单张表索引不超过5个</li>
<li>禁止给表中的每一列都建立单独的索引</li>
<li>每个Innodb表必须有个主键<br>常见索引列建议<br>如何选择索引列的顺序<br>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）<br>对于频繁的查询优先考虑使用覆盖索引<br>索引SET规范<br>尽量避免使用外键约束<br>数据库SQL开发规范</li>
<li>建议使用预编译语句进行数据库操作</li>
<li>避免数据类型的隐式转换</li>
<li>充分利用表上已经存在的索引<br>避免使用双%号的查询条件。<br>一个SQL只能利用到复合索引中的一列进行范围查询<br>使用left join 或 not exists 来优化not in 操作</li>
<li>数据库设计时，应该要对以后扩展进行考虑</li>
<li>程序连接不同的数据库使用不同的账号，进制跨库查询</li>
<li>禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询</li>
<li>禁止使用不含字段列表的INSERT语句</li>
<li>避免使用子查询，可以把子查询优化为join操作</li>
<li>避免使用JOIN关联太多的表</li>
<li>减少同数据库的交互次数</li>
<li>对应同一列进行or判断时，使用in代替or</li>
<li>禁止使用order by rand() 进行随机排序</li>
<li>WHERE从句中禁止对列进行函数转换和计算</li>
<li>在明显不会有重复值时使用UNION ALL 而不是UNION</li>
<li>拆分复杂的大SQL为多个小SQL<br>数据库操作行为规范<br>超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</li>
<li>大批量操作可能会造成严重的主从延迟</li>
<li>binlog日志为row格式时会产生大量的日志</li>
<li>避免产生大事务操作<br>对于大表使用pt-online-schema-change修改表结构<br>禁止为程序使用的账号赋予super权限<br>对于程序连接数据库账号，遵循权限最小原则<br>回到顶部(go to top)<br>数据库命令规范<br>所有数据库对象名称必须使用小写字母并用下划线分割</li>
</ol>
<p>所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</p>
<p>数据库对象的命名要能做到见名识意，并且最后不要超过32个字符</p>
<p>临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀</p>
<p>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</p>
<p>回到顶部(go to top)<br>数据库基本设计规范</p>
<ol>
<li><p>所有表必须使用Innodb存储引擎<br>没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）<br>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</p>
</li>
<li><p>数据库和表的字符集统一使用UTF8<br>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储emoji表情的需要，字符集需要采用utf8mb4字符集</p>
</li>
<li><p>所有表和字段都需要添加注释<br>使用comment从句添加表和列的备注<br>从一开始就进行数据字典的维护</p>
</li>
<li><p>尽量控制单表数据量的大小，建议控制在500万以内<br>500万并不是Mysql数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题<br>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
</li>
<li><p>谨慎使用Mysql分区表<br>分区表在物理上表现为多个文件，在逻辑上表现为一个表<br>谨慎选择分区键，跨分区查询效率可能更低<br>建议采用物理分表的方式管理大数据</p>
</li>
<li><p>尽量做到冷热数据分离，减小表的宽度<br>Mysql限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节</p>
</li>
</ol>
<p>减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO）<br>更有效的利用缓存，避免读入无用的冷数据<br>经常一起使用的列放到一个表中（避免更多的关联操作）<br>7. 禁止在表中建立预留字段<br>预留字段的命名很难做到见名识义<br>预留字段无法确认存储的数据类型，所以无法选择合适的类型<br>对预留字段类型的修改，会对表进行锁定<br>8. 禁止在数据库中存储图片，文件等大的二进制数据<br>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时<br>通常存储于文件服务器，数据库只存储文件地址信息<br>9. 禁止在线上做数据库压力测试<br>10. 禁止从开发环境，测试环境直接连接生成环境数据库<br>回到顶部(go to top)<br>数据库字段设计规范</p>
<ol>
<li>优先选择符合存储需要的最小的数据类型<br>原因是：列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多，<br>索引的性能也就越差<br>方法：<br>将字符串转换成数字类型存储，如：将IP地址转换成整形数据<br>mysql提供了两个方法来处理ip地址</li>
</ol>
<p>inet_aton 把ip转为无符号整型(4-8位)<br>inet_ntoa 把整型的ip转为地址</p>
<p>插入数据前，先用inet_aton把ip地址转为整型，可以节省空间<br>显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。</p>
<p>对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储<br>因为：无符号相对于有符号可以多出一倍的存储空间<br>SIGNED INT -2147483648<del>2147483647<br>UNSIGNED INT 0</del>4294967295</p>
<p>VARCHAR(N)中的N代表的是字符数，而不是字节数<br>使用UTF8存储255个汉字 Varchar(255)=765个字节</p>
<p>过大的长度会消耗更多的内存</p>
<ol start="2">
<li>避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据<br>建议把BLOB或是TEXT列分离到单独的扩展表中<br>Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行<br>而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型</li>
</ol>
<p>如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询</p>
<p>TEXT或BLOB类型只能使用前缀索引<br>因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的</p>
<ol start="3">
<li><p>避免使用ENUM类型<br>修改ENUM值需要使用ALTER语句<br>ENUM类型的ORDER BY操作效率低，需要额外操作<br>禁止使用数值作为ENUM的枚举值</p>
</li>
<li><p>尽可能把所有列定义为NOT NULL<br>原因：<br>索引NULL列需要额外的空间来保存，所以要占用更多的空间<br>进行比较和计算时要对NULL值做特别的处理</p>
</li>
<li><p>使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间<br>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07<br>TIMESTAMP 占用4字节和INT相同，但比INT可读性高<br>超出TIMESTAMP取值范围的使用DATETIME类型存储</p>
</li>
</ol>
<p>经常会有人用字符串存储日期型的数据（不正确的做法）<br>缺点1：无法用日期函数进行计算和比较<br>缺点2：用字符串存储日期要占用更多的空间</p>
<ol start="6">
<li>同财务相关的金额类数据必须使用decimal类型<br>非精准浮点：float,double<br>精准浮点：decimal<br>Decimal类型为精准浮点数，在计算时不会丢失精度<br>占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节<br>可用于存储比bigint更大的整型数据</li>
</ol>
<p>回到顶部(go to top)<br>索引设计规范</p>
<ol>
<li>限制每张表上的索引数量，建议单张表索引不超过5个<br>索引并不是越多越好！索引可以提高效率同样可以降低效率</li>
</ol>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率</p>
<p>因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个<br>索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能<br>2. 禁止给表中的每一列都建立单独的索引<br>5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好<br>3. 每个Innodb表必须有个主键<br>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的<br>每个表都可以有多个索引，但是表的存储顺序只能有一种<br>Innodb是按照主键索引的顺序来组织表的</p>
<p>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）<br>不要使用UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）<br>主键建议使用自增ID值<br>回到顶部(go to top)<br>常见索引列建议<br>出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列</p>
<p>包含在ORDER BY、GROUP BY、DISTINCT中的字段</p>
<p>并不要将符合1和2中的字段的列都建立一个索引， 通常将1、2中的字段建立联合索引效果更好</p>
<p>多表join的关联列</p>
<p>回到顶部(go to top)<br>如何选择索引列的顺序<br>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少<br>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）<br>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）<br>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）<br>回到顶部(go to top)<br>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）<br>重复索引示例：primary key(id)、index(id)、unique index(id)<br>冗余索引示例：index(a,b,c)、index(a,b)、index(a)<br>回到顶部(go to top)<br>对于频繁的查询优先考虑使用覆盖索引<br>覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引</p>
<p>覆盖索引的好处:</p>
<p>避免Innodb表进行索引的二次查询<br>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，<br>如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据<br>而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率</p>
<p>可以把随机IO变成顺序IO加快查询效率<br>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，<br>因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO</p>
<p>回到顶部(go to top)<br>索引SET规范<br>尽量避免使用外键约束<br>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引<br>外键可用于保证数据的参照完整性，但建议在业务端实现<br>外键会影响父表和子表的写操作从而降低性能</p>
<p>回到顶部(go to top)<br>数据库SQL开发规范</p>
<ol>
<li>建议使用预编译语句进行数据库操作<br>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题<br>只传参数，比传递SQL语句更高效<br>相同语句可以一次解析，多次使用，提高处理效率</li>
<li>避免数据类型的隐式转换<br>隐式转换会导致索引失效<br>如:  select name,phone from customer where id = ‘111’;</li>
<li>充分利用表上已经存在的索引<br>避免使用双%号的查询条件。<br>如 a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）</li>
</ol>
<p>一个SQL只能利用到复合索引中的一列进行范围查询<br>如 有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，<br>在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧<br>使用left join 或 not exists 来优化not in 操作<br>因为not in 也通常会使用索引失效<br>4. 数据库设计时，应该要对以后扩展进行考虑<br>5. 程序连接不同的数据库使用不同的账号，进制跨库查询<br>为数据库迁移和分库分表留出余地<br>降低业务耦合度<br>避免权限过大而产生的安全风险<br>6. 禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询<br>原因：<br>    消耗更多的CPU和IO以网络带宽资源<br>    无法使用覆盖索引<br>    可减少表结构变更带来的影响<br>7. 禁止使用不含字段列表的INSERT语句<br>如： insert into values (‘a’,’b’,’c’);<br>应使用 insert into t(c1,c2,c3) values (‘a’,’b’,’c’);<br>8. 避免使用子查询，可以把子查询优化为join操作<br>通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时,才可以把子查询转化为关联查询进行优化</p>
<p>子查询性能差的原因：</p>
<p> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响<br> 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大<br> 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询<br>9. 避免使用JOIN关联太多的表<br>对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置<br>在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，<br>所占用的内存也就越大</p>
<p>如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，<br>就会影响到服务器数据库性能的稳定性</p>
<p>同时对于关联操作来说，会产生临时表操作，影响查询效率<br>Mysql最多允许关联61个表，建议不超过5个<br>10. 减少同数据库的交互次数<br>数据库更适合处理批量操作<br>合并多个相同的操作到一起，可以提高处理效率<br>11. 对应同一列进行or判断时，使用in代替or<br>in 的值不要超过500个<br>in 操作可以更有效的利用索引，or大多数情况下很少能利用到索引<br>12. 禁止使用order by rand() 进行随机排序<br>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，<br>就会消耗大量的CPU和IO及内存资源<br>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式<br>13. WHERE从句中禁止对列进行函数转换和计算<br>对列进行函数转换或计算时会导致无法使用索引</p>
<p>不推荐：<br>where date(create_time)=’20190101’<br>推荐：<br>where create_time &gt;= ‘20190101’ and create_time &lt; ‘20190102’<br>14. 在明显不会有重复值时使用UNION ALL 而不是UNION<br>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作<br>UNION ALL 不会再对结果集进行去重操作<br>15. 拆分复杂的大SQL为多个小SQL<br>大SQL:逻辑上比较复杂，需要占用大量CPU进行计算的SQL<br>MySQL 一个SQL只能使用一个CPU进行计算<br>SQL拆分后可以通过并行执行来提高处理效率<br>回到顶部(go to top)<br>数据库操作行为规范<br>超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</p>
<ol>
<li><p>大批量操作可能会造成严重的主从延迟<br>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，<br>而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
</li>
<li><p>binlog日志为row格式时会产生大量的日志<br>大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，<br>产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
</li>
<li><p>避免产生大事务操作<br>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响<br>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
</li>
</ol>
<p>对于大表使用pt-online-schema-change修改表结构<br>避免大表修改产生的主从延迟<br>避免在对表字段进行修改时进行锁表<br>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的</p>
<p>pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器<br>把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉<br>把原来一个DDL操作，分解成多个小的批次进行</p>
<p>禁止为程序使用的账号赋予super权限<br>当达到最大连接数限制时，还运行1个有super权限的用户连接<br>super权限只能留给DBA处理问题的账号使用<br>对于程序连接数据库账号，遵循权限最小原则<br>程序使用数据库账号只能在一个DB下使用，不准跨库<br>程序使用的账号原则上不准有drop权限</p>
<p>摘自：<br><a href="https://www.cnblogs.com/huchong/p/10219318.html">https://www.cnblogs.com/huchong/p/10219318.html</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Resilience4j 从入门到放弃</title>
    <url>/2020/08/11/Resilience4j%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-resilience4j%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<p>@<a href="Resilience4j">TOC</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Resilience4j 是 Spring Cloud Greenwich 版推荐的容错解决方案，相比 Hystrix ，Resilience4j 专为 <strong>Java8</strong> 以及函数编程而设计。在 Resilience4j 中你用什么可直接添加什么以来就行。<br>Resilience4j 主要有以下功能：</p>
<ol>
<li>CircuitBreaker(熔断器)</li>
<li>RateLimiter(限流)</li>
<li> Retry(请求重试)</li>
<li> 限时</li>
<li> 缓存</li>
<li> 信号量的隔离</li>
</ol>
<h1 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h1><p>首先搭建一个测试环境。新建maven子模，导入pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-1熔断器"><a href="#1-1熔断器" class="headerlink" title="1.1熔断器"></a>1.1熔断器</h2><p>添加断路器依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-circuitbreaker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-1-首先看一个正常的断路器："><a href="#1-1-1-首先看一个正常的断路器：" class="headerlink" title="1.1.1 首先看一个正常的断路器："></a>1.1.1 首先看一个正常的断路器：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取一个CircuitBreakerRegistry实例，可以调用ofDefaults获取一个CircuitBreakerRegistry实例，也可以自定义属性。</span></span><br><span class="line">    CircuitBreakerRegistry registry = CircuitBreakerRegistry.ofDefaults();</span><br><span class="line">    CircuitBreakerConfig config = CircuitBreakerConfig.custom()</span><br><span class="line">            <span class="comment">//故障率阈值百分比(百分之50)，超过这个阈值，断路器就会打开</span></span><br><span class="line">            .failureRateThreshold(<span class="number">50</span>)</span><br><span class="line">            <span class="comment">//断路器保持打开的时间，在到达设置的时间之后，断路器会进入到 half open 状态</span></span><br><span class="line">            .waitDurationInOpenState(Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">            <span class="comment">//当断路器处于half open 状态时，环形缓冲区的大小</span></span><br><span class="line">            .ringBufferSizeInHalfOpenState(<span class="number">2</span>)</span><br><span class="line">            .ringBufferSizeInClosedState(<span class="number">2</span>)</span><br><span class="line">            .build();</span><br><span class="line">    CircuitBreakerRegistry r1 = CircuitBreakerRegistry.of(config);</span><br><span class="line">    CircuitBreaker cb1 = r1.circuitBreaker(<span class="string">&quot;javaboy&quot;</span>);<span class="comment">//创建断路器</span></span><br><span class="line">    CircuitBreaker cb2 = r1.circuitBreaker(<span class="string">&quot;javaboy2&quot;</span>, config);</span><br><span class="line">    CheckedFunction0&lt;String&gt; supplier = CircuitBreaker.decorateCheckedSupplier(cb1, () -&gt; <span class="string">&quot;hello resilience4j&quot;</span>);</span><br><span class="line">    Try&lt;String&gt; result = Try.of(supplier)</span><br><span class="line">            .map(v -&gt; v + <span class="string">&quot; hello world&quot;</span>);</span><br><span class="line">    System.out.println(result.isSuccess());</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020110516574647.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-1-2-一个异常的断路器："><a href="#1-1-2-一个异常的断路器：" class="headerlink" title="1.1.2 一个异常的断路器："></a>1.1.2 一个异常的断路器：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CircuitBreakerConfig config = CircuitBreakerConfig.custom()</span><br><span class="line">                <span class="comment">//故障率阈值百分比，超过这个阈值，断路器就会打开</span></span><br><span class="line">                .failureRateThreshold(<span class="number">50</span>)</span><br><span class="line">                <span class="comment">//断路器保持打开的时间，在到达设置的时间之后，断路器会进入到 half open 状态</span></span><br><span class="line">                .waitDurationInOpenState(Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">//当断路器处于half open 状态时，环形缓冲区的大小</span></span><br><span class="line">                .ringBufferSizeInClosedState(<span class="number">2</span>)</span><br><span class="line">                .build();</span><br><span class="line">        CircuitBreakerRegistry r1 = CircuitBreakerRegistry.of(config);</span><br><span class="line">        CircuitBreaker cb1 = r1.circuitBreaker(<span class="string">&quot;javaboy&quot;</span>);</span><br><span class="line">        System.out.println(cb1.getState());<span class="comment">//获取断路器的一个状态</span></span><br><span class="line">        cb1.onError(<span class="number">0</span>, <span class="keyword">new</span> RuntimeException());</span><br><span class="line">        System.out.println(cb1.getState());<span class="comment">//获取断路器的一个状态</span></span><br><span class="line">        cb1.onError(<span class="number">0</span>, <span class="keyword">new</span> RuntimeException());</span><br><span class="line">        System.out.println(cb1.getState());<span class="comment">//获取断路器的一个状态</span></span><br><span class="line">     </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201111154203970.png#pic_center" alt="在这里插入图片描述"><br>把这段代码添加到上面代码的后面，重新测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...   </span><br><span class="line">CheckedFunction0&lt;String&gt; supplier = CircuitBreaker.decorateCheckedSupplier(cb1, () -&gt; <span class="string">&quot;hello resilience4j&quot;</span>);</span><br><span class="line">        Try&lt;String&gt; result = Try.of(supplier)</span><br><span class="line">                .map(v -&gt; v + <span class="string">&quot; hello world&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result.isSuccess()=&quot;</span>+result.isSuccess());</span><br><span class="line">        System.out.println(<span class="string">&quot;result.get()=&quot;</span>+result.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如下(由于断路器已经打开了，就无法执行下面的代码了)：<br><img src="https://img-blog.csdnimg.cn/20201111155017406.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>注意</strong>：由于 ringBufferSizeInClosedState 的值为2，表示当有两条数据时才会去统计故障率，所以，下面的手动故障测试，至少调用两次 onError，断路器才会打开。</p>
<h3 id="1-1-3-断路器重置"><a href="#1-1-3-断路器重置" class="headerlink" title="1.1.3 断路器重置"></a>1.1.3 断路器重置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">circuitBreaker.reset();</span><br></pre></td></tr></table></figure>
<h2 id="1-2-RateLimiter-限流"><a href="#1-2-RateLimiter-限流" class="headerlink" title="1.2 RateLimiter 限流"></a>1.2 RateLimiter 限流</h2><p>RateLimiter 本身和前面的断路器差不多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 限流 和断路器类似</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       RateLimiterConfig build = RateLimiterConfig.custom()</span><br><span class="line">               <span class="comment">// 阈值刷新的时间 1 秒</span></span><br><span class="line">               .limitRefreshPeriod(Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">               <span class="comment">// 限制频次</span></span><br><span class="line">               .limitForPeriod(<span class="number">2</span>)</span><br><span class="line">               <span class="comment">// 限流之后的冷却时间 1秒</span></span><br><span class="line">               .timeoutDuration(Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">               .build();</span><br><span class="line">       RateLimiter limiter = RateLimiter.of(<span class="string">&quot;learning&quot;</span>, build);</span><br><span class="line"></span><br><span class="line">       CheckedRunnable runnable = RateLimiter.decorateCheckedRunnable(limiter, () -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 执行4次</span></span><br><span class="line">       Try.run(runnable)</span><br><span class="line">               .andThenTry(runnable)</span><br><span class="line">               .andThenTry(runnable)</span><br><span class="line">               .andThenTry(runnable)</span><br><span class="line">               .onFailure(t -&gt; System.out.println(t.getMessage()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201112192406133.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-3-请求重试"><a href="#1-3-请求重试" class="headerlink" title="1.3 请求重试"></a>1.3 请求重试</h2><p>先引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 请求重试</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RetryConfig config = RetryConfig.custom()</span><br><span class="line">            <span class="comment">// 重试次数 【小于等于下面的count次数就抛出异常】</span></span><br><span class="line">            .maxAttempts(<span class="number">4</span>)</span><br><span class="line">            <span class="comment">// 重试间隔</span></span><br><span class="line">            .waitDuration(Duration.ofMillis(<span class="number">500</span>))</span><br><span class="line">            <span class="comment">// 重试异常</span></span><br><span class="line">            .retryExceptions(RuntimeException.class)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    Retry retry = Retry.of(<span class="string">&quot;leaning1&quot;</span>, config);</span><br><span class="line">    Retry.decorateRunnable(retry, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重试功能开启后 执行run方法 若抛出异常 会自动触发重试功能</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (count++ &lt; <span class="number">4</span>)&#123;</span><br><span class="line">                System.out.println(count);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201112194235400.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="2-Resilience4j-结合微服务"><a href="#2-Resilience4j-结合微服务" class="headerlink" title="2. Resilience4j 结合微服务"></a>2. Resilience4j 结合微服务</h1><p>Retry、CircuitBreaker、RateLimiter</p>
<h2 id="2-1-Retry-请求重试"><a href="#2-1-Retry-请求重试" class="headerlink" title="2.1 Retry 请求重试"></a>2.1 Retry 请求重试</h2><p>首先新建一个Spring boot 项目，创建时，添加如下依赖：<br><img src="https://img-blog.csdnimg.cn/20201113093954234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>创建成功后再添加 Resilience4j 的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span></span></span><br><span class="line"><span class="tag">&lt;!<span class="attr">--resilience4j-spring-boot2</span>中包含了<span class="attr">resilience4j</span> 的所有功能，但是没有配置的功能无法使用，需要将之从依赖中剔除掉  <span class="attr">--</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-spring-boot2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-circuitbreaker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-ratelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-bulkhead<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-timelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>resilience4j-spring-boot2中包含了resilience4j 的所有功能，但是没有配置的功能无法使用，需要将之从依赖中剔除掉。<br>配置yml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">resilience4j:</span><br><span class="line">  retry:</span><br><span class="line">    retry-aspect-order: 399 # 表示Retry优先级(级别高于比如ratelimiter bulkhead timelimiter) 值越小 优先级 越高</span><br><span class="line">    backends:</span><br><span class="line">      retryA: # 设置组名</span><br><span class="line">        maxRetryAttempts: 5 # 对比之前的案例 重试的次数</span><br><span class="line">        waitDuration: 500 # 重试等待 500毫秒</span><br><span class="line">        exponentialBackoffMultiplier: 1.1 # 间隔乘数(场景: 正好每次间隔为1的时候卡顿 它就有用了 间隔就变了 例如 1 1.1 1.21....)</span><br><span class="line">        retryExceptions:</span><br><span class="line">          - java.lang.RuntimeException</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: resilience4j</span><br><span class="line">server:</span><br><span class="line">  port: 5000</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:1111/eureka</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后创建RestTemplate和HelloService:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resilience4j2Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Resilience4j2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Retry(name = &quot;retryA&quot;)</span><span class="comment">//表示要使用的重试策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://127.0.0.1:1113/hello&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>浏览器访问: <a href="http://127.0.0.1:5000/hello">http:/127.0.0.1:5000/hello</a> ，观看 provider 控制台，发现错误打印了5次，与yml中的配置一致。</p>
<h2 id="2-2-CircuitBreaker-断路器"><a href="#2-2-CircuitBreaker-断路器" class="headerlink" title="2.2 CircuitBreaker 断路器"></a>2.2 CircuitBreaker 断路器</h2><p>首先去除掉circuitbreaker 的依赖。然后在yml 文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-spring-boot2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 没有配置的 先排除 不然会报错 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;exclusion&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;artifactId&gt;resilience4j-circuitbreaker&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;/exclusion&gt;--&gt;</span></span><br><span class="line"> </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-ratelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-bulkhead<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-timelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">resilience4j:</span><br><span class="line">  retry:</span><br><span class="line">    retry-aspect-order: 399 # 表示Retry优先级(级别高于比如ratelimiter bulkhead timelimiter) 值越小 优先级 越高</span><br><span class="line">    backends:</span><br><span class="line">      retryA: # 设置组名</span><br><span class="line">        maxRetryAttempts: 5 # 对比之前的案例 重试的次数</span><br><span class="line">        waitDuration: 500 # 重试等待 500毫秒</span><br><span class="line">        exponentialBackoffMultiplier: 1.1 # 间隔乘数(场景: 正好每次间隔为1的时候卡顿 它就有用了 间隔就变了 例如 1 1.1 1.21....)</span><br><span class="line">        retryExceptions:</span><br><span class="line">          - java.lang.RuntimeException</span><br><span class="line">  circuitbreaker: # 和之前的maven类似</span><br><span class="line">    instances:</span><br><span class="line">      cba:</span><br><span class="line">        ringBufferSizeInHalfOpenState: 3</span><br><span class="line">        ringBufferSizeInClosedState:  5</span><br><span class="line">        waitInterval: 5000</span><br><span class="line">        recordExceptions:</span><br><span class="line">          - org.springframework.web.client.HttpServerErrorException</span><br><span class="line">    circuit-breaker-aspect-order: 398 # 表示 circuitbreaker 优先级，比上面的399小 (先执行当前断路器)</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: resilience4j</span><br><span class="line">server:</span><br><span class="line">  port: 5000</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:1111/eureka</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置完成后，用 @CircuitBreaker 注解标记相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">//@Retry(name = &quot;retryA&quot;)//【Retry】表示要使用的重试策略</span></span><br><span class="line"><span class="meta">@CircuitBreaker(name = &quot;cba&quot; , fallbackMethod = &quot;error&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://127.0.0.1:1113/hello&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务降级方法中 不加参数Throwable 会报错提示缺少Throwable 要添加异常参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">(Throwable throwable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@CircuitBreaker 注解中的 name 属性用来指定 circuitbreaker 配置 ， fallbackMethod 属性用来指定服务降级的方法，需要注意的是，服务降级方法中，要添加异常参数 (Throwable)。</p>
<h2 id="2-3-RateLimiter-限流"><a href="#2-3-RateLimiter-限流" class="headerlink" title="2.3 RateLimiter 限流"></a>2.3 RateLimiter 限流</h2><p>RateLimiter 作为限流工具，主要在<strong>服务端</strong>使用，用来保护服务端的接口。<br>首先在 provider 中添加RateLimiter 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-spring-boot2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--  没有配置的 先排除 不然会报错 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-circuitbreaker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">&lt;!--ratelimiter依赖移除--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;exclusion&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;artifactId&gt;resilience4j-ratelimiter&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;/exclusion&gt;--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-bulkhead<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-timelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来，在 provider 的 application.properties 配置文件中去配置 RateLimiter：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 这里配置每一秒处理一个请求，多个请求就排队</span><br><span class="line">resilience4j.ratelimiter.limiters.rlA.limit-for-period=1</span><br><span class="line">resilience4j.ratelimiter.limiters.rlA.limit-refresh-period=1s</span><br><span class="line">resilience4j.ratelimiter.limiters.rlA.timeout-duration=1s</span><br></pre></td></tr></table></figure>
<p>配置 provider 的 Controller 层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    Integer port;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@RateLimiter(name = &quot;rltA&quot;)</span> <span class="comment">//通过@RateLimiter注解标记该接口限流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello provider：&quot;</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着在 resilience4j2 客户端模拟多个请求，启动 eureka、provider 、resilience4j 服务，访问 <a href="http://127.0.0.1:5000/hello1">http://127.0.0.1:5000/hello1</a> 查看限流效果。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Servic</span></span><br><span class="line"><span class="meta">@CircuitBreaker(name = &quot;cba&quot; , fallbackMethod = &quot;error&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限流配置 【模拟多次请求】</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            restTemplate.getForObject(<span class="string">&quot;http://127.0.0.1:1113/hello&quot;</span>, String.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success ratA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每秒处理一个请求。<br><img src="https://img-blog.csdnimg.cn/20201113164804885.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Config 笔记补充</title>
    <url>/2020/08/14/Spring%20Cloud%20Config%20%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85-springcloudconfig%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>@[TOC](Spring Cloud Config)</p>
<h1 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Spring Ccloud Config 是一个分布式系统配置管理的解决方案，它包含了 Client 和 Server 。配置文件放在 Server 端，通过接口的形式提供给 Client。</p>
<p><strong>主要功能</strong>：</p>
<ul>
<li>集中管理各个微服务/环境的配置文件(中央仓库 统一打包 发快递)</li>
<li>支持多种开发语言和高并发查询</li>
<li>提供server(服务端)和客户端(client)</li>
<li>配置文件一经修改 可快速生效 但是client立刻生效需要中间件</li>
<li>配置文件通过git/svn进行管理(支持版本回退)</li>
</ul>
<h2 id="1-2-准备工作-提交文件"><a href="#1-2-准备工作-提交文件" class="headerlink" title="1.2 准备工作-提交文件"></a>1.2 准备工作-提交文件</h2><p>在本地找一个位置，新建目录 client1 添加 3 个文件.properties结尾，上传到git上。 一个文件夹代表一个微服务。</p>
<p><img src="https://img-blog.csdnimg.cn/20201120113421795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-3-ConfigServer搭建"><a href="#1-3-ConfigServer搭建" class="headerlink" title="1.3 ConfigServer搭建"></a>1.3 ConfigServer搭建</h2><p>首先创建一个 ConfigServer 工程，添加如下依赖：</p>
<p><img src="https://img-blog.csdnimg.cn/20201120113711145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>完事后启动添加注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span>  <span class="comment">// 启动ConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=config-server</span><br><span class="line">server.port=8081</span><br><span class="line"></span><br><span class="line"># 配置文件仓库地址</span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/xxx/configRepo.git</span><br><span class="line"></span><br><span class="line"># 仓库中， 配置文件的目录</span><br><span class="line">spring.cloud.config.server.git.search-paths=client1</span><br><span class="line"></span><br><span class="line">spring.cloud.config.server.git.username=xxxx@163.com</span><br><span class="line">spring.cloud.config.server.git.password=</span><br></pre></td></tr></table></figure>

<p>然后启动 ConfigServer 项目，就可以访问配置文件了，访问地址： <a href="http://localhost:8081/client1/prod/main">http://localhost:8081/client1/prod/main</a> （github上面master分支现在已经没有了）</p>
<p>接下来修改本地配置文件并重新提交到 GitHub ，此时，刷新 ConfigServer 接口，就可以及时看到更改的内容。</p>
<p> <strong>访问规则</strong>：</p>
<ul>
<li>/{application}/{profile}[/{label}] /{application}-{profile}.yml</li>
<li>/{label}/{application}-{profile}.yml</li>
<li> /{application}-{profile}.properties</li>
<li> /{label}/{application}-{profile}.properties</li>
</ul>
<blockquote>
<p>{application} 就是应用名称，对应到配置文件上来，就是配置文件的名称部分，例如我上面创建的配置文件。<br>{profile} 就是配置文件的版本，我们的项目有开发版本、测试环境版本、生产环境版本，对应到配置文件上来就是以 application-{profile}.yml 加以区分，例如application-dev.yml、application-sit.yml、application-prod.yml。<br>{label} 表示 git 分支，默认是 master 分支，如果项目是以分支做区分也是可以的，那就可以通过不同的 label 来控制访问不同的配置文件了。</p>
</blockquote>
<h2 id="1-4-ConfigClient搭建"><a href="#1-4-ConfigClient搭建" class="headerlink" title="1.4 ConfigClient搭建"></a>1.4 ConfigClient搭建</h2><p>首先创建一个 Spring Boot 项目，添加如下依赖：</p>
<p><img src="https://img-blog.csdnimg.cn/20201121113602341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>项目创建成功后，在 Resoures 目录下，添加 <strong>boostrap.properties</strong> 配置(boostrap.properties 优先级高于 application.properties)，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 下面三行配置，分别对应 config-server 中的 &#123;application&#125;、&#123;profile&#125;以及&#123;label&#125;占位符</span><br><span class="line">spring.application.name=client1</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">spring.cloud.config.label=main</span><br><span class="line">spring.cloud.config.uri=http://localhost:8081</span><br><span class="line">server.port=8082</span><br></pre></td></tr></table></figure>
<p>接下来创建一个HelloController 测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;javaboy&#125;&quot;)</span></span><br><span class="line">    String javaboys;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> javaboys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost:8082/hello">http://localhost:8082/hello</a> </p>
<h2 id="1-5-配置"><a href="#1-5-配置" class="headerlink" title="1.5 配置"></a>1.5 配置</h2><p>使用占位符灵活控制查询目录。<br>修改 config-server 配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.server.git.search-paths=&#123;application&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 {application} 占位符，表示链接上来的 client1 的 spring.application.name 属性的值。<br>在 config-server 中，也可以用 {profile} 表示 client 的 spring.cloud.config.profile，也可以用 {label} 表示 client 的 spring.cloud.config.label<br>虽然在实际开发中，配置文件一般都是放在 Git 仓库，但是 config-server 也支持将配置文件放在 classpath 下。<br>在 config-server 中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 表示让 config-server 从 classpath 下查找配置，而不是去 Git 仓库中查找</span><br><span class="line">spring.profiles.active=native</span><br></pre></td></tr></table></figure>

<p>也可以在 config-server 中，添加如下配置，表示指定配置文件的位置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.server.native.search-locations=file:/E:/properties/</span><br></pre></td></tr></table></figure>
<h1 id="2-配置文件加解密"><a href="#2-配置文件加解密" class="headerlink" title="2. 配置文件加解密"></a>2. 配置文件加解密</h1><h2 id="2-1-常见加密方案"><a href="#2-1-常见加密方案" class="headerlink" title="2.1 常见加密方案"></a>2.1 常见加密方案</h2><ul>
<li>不可逆加密  </li>
<li>可逆加密</li>
</ul>
<p><strong>不可逆加密</strong>：</p>
<blockquote>
<p>理论上无法根据已加密的密文推导出明文(常用算法 MD5消息摘要算法 SHA安全散列算法) ，一般用在密码加密上。</p>
</blockquote>
<p><strong>可逆加密</strong>：</p>
<blockquote>
<p> <strong>对称加密</strong>：加密和解密密钥是一样的(算法 aes 3des des)。</p>
</blockquote>
<blockquote>
<p> <strong>非对称加密</strong>：加密的密钥和解密的密钥不同。加密的称为公钥，可以给任何人； 解密的叫私钥(只有自己知道)。 常见算法RSA</p>
</blockquote>
<h2 id="2-2-对称加密"><a href="#2-2-对称加密" class="headerlink" title="2.2 对称加密"></a>2.2 对称加密</h2><p>首先下载不限长度的JCE：<a href="https://www.oracle.com/technetwork/cn/java/javase/downloads/jce8-download-2133166-zhs.html">oracle中下载</a><br>将下载的文件解压，解压出来的 jar 拷贝到 Java 安装目录中： E:**\lib\security<br>然后，在 config-server 的 bootstrap.properties 配置文件中，添加如下内容配置密钥：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 密钥</span><br><span class="line">encrypt.key=javaboy</span><br></pre></td></tr></table></figure>
<p>然后启动 config-server 访问如下地址，查看密钥配置是否OK：<br><img src="https://img-blog.csdnimg.cn/2020112311460925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201123114810543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>然后在 postman 访问：<a href="http://localhost:8081/encrypt">http://localhost:8081/encrypt</a> ，这是一个 post 请求，访问该地址，可以对一段明文进行加密。把加密后的明文存储到Git仓库中，存储时，要加一个 <strong>{cipher}</strong> 前：<br><img src="https://img-blog.csdnimg.cn/20201123114959100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>修改本地文件如下，并提交至github 上去。<br><img src="https://img-blog.csdnimg.cn/2020112313543914.png#pic_center" alt="在这里插入图片描述"><br>然后访问： <a href="http://localhost:8081/client1/dev/main">http://localhost:8081/client1/dev/main</a> 查看效果，如下：<br><img src="https://img-blog.csdnimg.cn/20201123140003966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>config-client 需要重启才会感知并生效(后续考虑用中间件等办法解决)。config-client 重启后访问如下：<br><img src="https://img-blog.csdnimg.cn/20201123141904113.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-3-非对称加密"><a href="#2-3-非对称加密" class="headerlink" title="2.3 非对称加密"></a>2.3 非对称加密</h2><p>首先生成一个密钥对：<br>在命令行执行如下命令，生成 keystore :</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">keytool -genkeypair -alias config-server -keyalg RSA -keystore F:\BaiduNetdiskDownload\config-server.keystore</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令执行完后，拷贝生成的 keystore 文件到 config-server 的 resources 目录下。<br>然后在 config-server 的 bootstrap.properties 目录中，添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">encrypt.key-store.location=config-server.keystore</span><br><span class="line">encrypt.key-store.alias=config-server</span><br><span class="line">encrypt.key-store.password=111111</span><br><span class="line">encrypt.key-store.secret=111111</span><br></pre></td></tr></table></figure>
<p>在pom.xml 的 build 节点上，添加如下配置，防止 keystore 文件被过滤。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.keystore<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后重启 config-server ，测试方法与对称加密一致。<br><img src="https://img-blog.csdnimg.cn/20201123144941976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来加密文件 ，并cv 到github 上进行测试。<br><img src="https://img-blog.csdnimg.cn/20201123145525452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>重启/启动 config-server和 config-client ，访问如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123145812995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201123145744497.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="3-安全管理"><a href="#3-安全管理" class="headerlink" title="3. 安全管理"></a>3. 安全管理</h1><p>防止用户直接通过访问 config-server 看到配置文件内容，我们可以用 spring security 来保护 config-server 接口。<br>首先在 config-server 中添加 spring security 依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>添加完依赖后，config-server 中的接口就被保护起来了。<br>默认生成的密码不好记，所以我们可以在 config-server 中配置自己的密码。<br>在 config-server 的配置文件中，添加如下配置，固定用户名密码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.security.user.name=user</span><br><span class="line">spring.security.user.password=321</span><br></pre></td></tr></table></figure>
<p>然后在 config-client 的 bootstrap.properties 配置文件中，添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.username=user</span><br><span class="line">spring.cloud.config.password=321</span><br></pre></td></tr></table></figure>
<p>重 config-server和 config-client ，访问如下即成功：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123154633809.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="4-服务化"><a href="#4-服务化" class="headerlink" title="4. 服务化"></a>4. 服务化</h1><p>首先启动 Eureka 。<br>然后让 config-server 和 config-client 都注册到 Eureka。给他两添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在两个 application.properties 配置文件中配置注册信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</span><br></pre></td></tr></table></figure>
<p>接下来修改 config-client 配置文件，不再直接写死 config-server 地址。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 下面三行配置，分别对应 config-server 中的 &#123;application&#125;、&#123;profile&#125;以及&#123;label&#125;占位符</span><br><span class="line">spring.application.name=client1</span><br><span class="line">spring.cloud.config.profile=test</span><br><span class="line">spring.cloud.config.label=main</span><br><span class="line">#spring.cloud.config.uri=http://localhost:8081</span><br><span class="line"></span><br><span class="line"># 开启通过 eureka 获取 config-server 的功能</span><br><span class="line">spring.cloud.config.discovery.enabled=true</span><br><span class="line"># 配置 config-server 服务名称</span><br><span class="line">spring.cloud.config.discovery.service-id=config-server</span><br><span class="line">server.port=8082</span><br><span class="line"></span><br><span class="line">spring.cloud.config.username=user</span><br><span class="line">spring.cloud.config.password=321</span><br><span class="line"></span><br><span class="line"># 注册 eureka</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</span><br></pre></td></tr></table></figure>
<p>加入 eureka client 之后，启动 config-server 可能会报错。此时我们重新生成一个 jks 格式的密钥。cmd命令框：</p>
<blockquote>
<p>keytool -genkeypair -alias new-config-server -keyalg RSA -keypass 123456 -keystore D:\git\config-server.jks -storepass 123456</p>
</blockquote>
<p>生成之后，将文件拷贝到 configserver 的 resources 目录下，同时修改 bootstrap.properties 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 密钥 【对称加密】</span><br><span class="line">#encrypt.key=javaboy</span><br><span class="line"></span><br><span class="line">encrypt.key-store.location=classpath:config-server.jks</span><br><span class="line">encrypt.key-store.alias=mytestkey</span><br><span class="line">encrypt.key-store.password=111111</span><br><span class="line">encrypt.key-store.secret=111111</span><br><span class="line"></span><br><span class="line">spring.security.user.name=user</span><br><span class="line">spring.security.user.password=321</span><br></pre></td></tr></table></figure>
<p>同时修改 pom 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">		<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jks<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;include&gt;**/*.keystore&lt;/include&gt;--&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了得到效果 非对称加密那部分就不用了。修改 config-client 配置文件：</p>
<blockquote>
<p>config-client profile: test</p>
</blockquote>
<p>重启后访问成功如下：<br><img src="https://img-blog.csdnimg.cn/20201124100703488.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="5-动态刷新-config-client感知数据更新"><a href="#5-动态刷新-config-client感知数据更新" class="headerlink" title="5. 动态刷新(config-client感知数据更新)"></a>5. 动态刷新(config-client感知数据更新)</h1><p>当配置文件发生变化后，config-server 可以及时感知到变化，但是 config-client 不会及时感知到变化，默认情况下， config-client 只有重启才会加载到最新的配置文件（实际上这个在后面可以结合消息中间件来做，这里为了简单先这样做）。<br>首先给 config-client 添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，添加配置，使 refresh 端点暴露出来：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=refresh</span><br></pre></td></tr></table></figure>
<p>最后，再给 config-client 使用了配置文件的地方加上 @RefreshScope 注解，这样当配置改变后，只需要调用 refresh 端点，config-client 中的配置就可以自动刷新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;javaboy&#125;&quot;)</span></span><br><span class="line">    String javaboys;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> javaboys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来修改本地的配置文件并提交至 GitHub，内容如下(将test改为test123)：<br><img src="https://img-blog.csdnimg.cn/20201124113107466.png#pic_center" alt="在这里插入图片描述"><br>提交成功后，这个时候你如果不做其他操作的话，直接访问config-client ，实际上那个文件是不会变的。至此，以后只要配置文件发生变化，发送 post 请求，调用 <a href="http://localhost:8082/actuator/refresh">http://localhost:8082/actuator/refresh</a> 接口即可，配置文件就会自动刷新。<br><img src="https://img-blog.csdnimg.cn/2020112413555572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>调用成后再去访问 config-client 接口，发现已经改变，如下：<br><img src="https://img-blog.csdnimg.cn/20201124140001498.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="6-请求失败重试"><a href="#6-请求失败重试" class="headerlink" title="6. 请求失败重试"></a>6. 请求失败重试</h1><p>config-client 在调用 config-server 时，一样也可能发生请求失败的问题，这个时候我们可以配置一个请求重试的功能。<br>要给 config-client 添加重试功能，只需要添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，修改配置，开启失败快速响应（默认情况下，config-client 访问 config-server 时，如果它访问失败了，这个时候项目还是会继续启动，不会马上报错。而快速相应在这里访问失败会立马报错，进行重试）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 开启失败快速响应</span><br><span class="line">spring.cloud.config.fail-fast=true</span><br></pre></td></tr></table></figure>
<p>然后，注释掉配置文件的用户名和密码，重启 config-client ，此时加载配置文件失败，就会自动重试。</p>
<p>再次启动如下图：<br><img src="https://img-blog.csdnimg.cn/20201124142436567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291cnN0cm9uZ2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>也可以通过如下配置保证服务的可用性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 开启失败快速响应</span><br><span class="line">spring.cloud.config.fail-fast=true</span><br><span class="line"># 请求重试的初始间隔时间</span><br><span class="line">spring.cloud.config.retry.initial-interval=1000</span><br><span class="line"># 最大重试次数</span><br><span class="line">spring.cloud.config.retry.max-attempts=6</span><br><span class="line"># 重试时间间隔乘数</span><br><span class="line">spring.cloud.config.retry.multiplier=1.1</span><br><span class="line"># 最大间隔时间</span><br><span class="line">spring.cloud.config.retry.max-interval=2000</span><br></pre></td></tr></table></figure>

<p><strong>地址</strong>：<a href="https://github.com/astronger/springcloud-simple-samples">https://github.com/astronger/springcloud-simple-samples</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
</search>
